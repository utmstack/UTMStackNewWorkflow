import {HttpResponse} from '@angular/common/http';
import {Component, OnDestroy, OnInit} from '@angular/core';
import {ActivatedRoute, Router} from '@angular/router';
import {NgbModal} from '@ng-bootstrap/ng-bootstrap';
import {ResizeEvent} from 'angular-resizable-element';
import {UtmToastService} from '../../shared/alert/utm-toast.service';
import {ModalConfirmationComponent} from '../../shared/components/utm/util/modal-confirmation/modal-confirmation.component';
import {ITEMS_PER_PAGE} from '../../shared/constants/pagination.constants';
import {SortEvent} from '../../shared/directives/sortable/type/sort-event';
import {ActionInitParamsEnum, ActionInitParamsValueEnum} from '../../shared/enums/action-init-params.enum';
import {ElasticTimeEnum} from '../../shared/enums/elastic-time.enum';
import {ElasticFilterCommonType} from '../../shared/types/filter/elastic-filter-common.type';
import {TimeFilterType} from '../../shared/types/time-filter.type';
import {TASK_FIELDS_FILTERS, TASK_STATICS_FILTERS} from '../shared/constants/task-field.const';
import {TaskResultParamType} from '../shared/enums/task-result-param.type';
import {VsTaskFilterEnum} from '../shared/enums/vs-task-filter.enum';
import {VsTaskStatusEnum} from '../shared/enums/vs-task-status.enum';
import {VsTaskService} from '../shared/services/vs-task.service';
import {VsTaskFilterType} from '../shared/type/vs-task-filter.type';
import {VsTaskType} from '../shared/type/vs-task.type';
import {VsQuickScanComponent} from '../vulnerability-shared/components/vs-quick-scan/vs-quick-scan.component';
import {VsSeverityInfoComponent} from '../vulnerability-shared/components/vs-severity-info/vs-severity-info.component';

@Component({
  selector: 'app-vs-tasks',
  templateUrl: './vs-tasks.component.html',
  styleUrls: ['./vs-tasks.component.css']
})
export class VsTasksComponent implements OnInit, OnDestroy {
  tasks: VsTaskType[] = [];
  defaultTime: ElasticFilterCommonType = {time: ElasticTimeEnum.DAY, last: 7, label: 'last 7 days'};
  viewDetail: VsTaskType;
  loading = true;
  totalItems: any;
  pageWidth = window.innerWidth;
  filterWidth: number;
  tableWidth: number;
  request: VsTaskFilterType = {
    page: 0,
    sort: 'id,desc',
    size: ITEMS_PER_PAGE,
    taskStatus: null,
    taskName: null,
    taskCreationTimeIni: null,
    taskCreationTimeEnd: null,
    scanResultSeverityLabels: null,
    port: null,
    host: null,
    executionSources: null
  };
  interval: any;
  taskStatusEnum = VsTaskStatusEnum;
  fieldFilters = TASK_FIELDS_FILTERS;
  processing: string[] = [];

  constructor(private taskService: VsTaskService,
              private modalService: NgbModal,
              private router: Router,
              private activatedRoute: ActivatedRoute,
              private utmToastService: UtmToastService) {
    this.setInitialWidth();
  }

  ngOnInit() {
    this.activatedRoute.queryParams.subscribe(params => {
      if (params[ActionInitParamsEnum.ON_INIT_ACTION]
        && params[ActionInitParamsEnum.ON_INIT_ACTION] === ActionInitParamsValueEnum.SHOW_CREATE_MODAL) {
        this.newTask();
      }
    });
    this.interval = setInterval(() => this.getTask(), 30000);
  }

  ngOnDestroy() {
    clearInterval(this.interval);
  }

  getTask() {
    this.taskService.queryTask(this.request).subscribe(
      (res: HttpResponse<any>) => this.onSuccess(res.body, res.headers),
      (res: HttpResponse<any>) => this.onError(res.body)
    );
  }

  viewSeverityHelp() {
    const modal = this.modalService.open(VsSeverityInfoComponent, {centered: true});
  }

  newTask() {
    const modal = this.modalService.open(VsQuickScanComponent, {centered: true});
    modal.componentInstance.taskCreated.subscribe(task => {
      this.getTask();
    });
  }

  viewTaskResult(task: VsTaskType) {
    const queryParams = {};
    queryParams[TaskResultParamType.TYPE_DATA] = TaskResultParamType.TYPE_TASK;
    queryParams[TaskResultParamType.TASK_UUID] = task.taskUuid;
    this.router.navigate(['/vulnerability-scanner/task-result'], {queryParams});
  }

  loadPage(page: any) {
    this.request.page = page - 1;
    this.getTask();
  }

  stopTask(task: VsTaskType) {
    const deleteModalRef = this.modalService.open(ModalConfirmationComponent, {centered: true});
    deleteModalRef.componentInstance.header = 'Stop task';
    deleteModalRef.componentInstance.message = 'Are you sure that you want to stop this task';
    deleteModalRef.componentInstance.confirmBtnText = 'Stop';
    deleteModalRef.componentInstance.confirmBtnIcon = 'icon-stop2';
    deleteModalRef.componentInstance.confirmBtnType = 'delete';
    this.toggleProcessing(task.taskUuid);
    deleteModalRef.result.then(() => {
      this.taskService.stopTask({
        commandName: 'stop',
        taskId: task.taskUuid
      }).subscribe(response => {
        this.utmToastService.showSuccessBottom('Task ' + task.taskName + ' stopped successfully');
        this.toggleProcessing(task.taskUuid);
        this.getTask();
      }, error => {
        this.utmToastService.showError('Error stopping task',
          'Error stopping task, please contact with the support team');
        this.toggleProcessing(task.taskUuid);
      });
    });
  }

  onTimeChange($event: TimeFilterType) {
    this.request.taskCreationTimeIni = $event.timeFrom;
    this.request.taskCreationTimeEnd = $event.timeTo;
    this.getTask();
  }

  viewDetailTask(task: VsTaskType) {
    this.viewDetail = task;
  }

  toggleProcessing(taskId: string) {
    const index = this.processing.findIndex(value => value === taskId);
    if (index === -1) {
      this.processing.push(taskId);
    } else {
      this.processing.splice(index, 1);
    }
  }

  setInitialWidth() {
    if (this.pageWidth > 1980) {
      this.filterWidth = 350;
      this.tableWidth = this.pageWidth - this.filterWidth - 51;
    } else {
      this.filterWidth = 300;
      this.tableWidth = this.pageWidth - this.filterWidth - 51;
    }
    if (this.pageWidth > 2500) {
      this.filterWidth = 350;
      this.tableWidth = this.pageWidth - this.filterWidth - 51;
    }
    if (this.pageWidth > 4000) {
      this.filterWidth = 400;
      this.tableWidth = this.pageWidth - this.filterWidth - 51;
    }
  }

  onFilterChange($event: { prop: VsTaskFilterEnum, values: any }) {
    switch ($event.prop) {
      case VsTaskFilterEnum.PORTS:
        this.request.port = $event.values.length > 0 ? $event.values : null;
        break;
      case VsTaskFilterEnum.SEVERITY_LABELS:
        this.request.scanResultSeverityLabels = $event.values.length > 0 ? $event.values : null;
        break;
      case VsTaskFilterEnum.TASK_NAMES:
        this.request.taskName = $event.values.length > 0 ? $event.values : null;
        break;
      case VsTaskFilterEnum.HOSTS:
        this.request.host = $event.values.length > 0 ? $event.values : null;
        break;
      case VsTaskFilterEnum.STATUS:
        this.request.taskStatus = $event.values.length > 0 ? $event.values : null;
        break;
      case VsTaskFilterEnum.SOURCE:
        this.request.executionSources = $event.values.length > 0 ? $event.values : null;
        break;
    }
    // this.assetFiltersBehavior.$assetAppliedFilter.next(this.requestParam);
    // this.assetFiltersBehavior.$assetFilter.next(this.requestParam);
    this.getTask();
  }

  onResize($event: ResizeEvent) {
    if ($event.rectangle.width >= 250) {
      this.tableWidth = (this.pageWidth - $event.rectangle.width - 51);
      this.filterWidth = $event.rectangle.width;
    }
  }

  resetAllFilters() {
    for (const key of Object.keys(this.request)) {
      if (!TASK_STATICS_FILTERS.includes(key)) {
        this.request[key] = null;
      }
    }
    // this.assetFiltersBehavior.$assetFilter.next(this.requestParam);
    // this.getAssets();
  }

  onSortBy($event: SortEvent) {
    this.request.sort = $event.column + ',' + $event.direction;
    this.getTask();
  }

  private onSuccess(data, headers) {
    this.totalItems = headers.get('X-Total-Count');
    this.tasks = data;
    this.loading = false;
  }

  private onError(error) {
    this.utmToastService.showError('Error loading task',
      'Error while to get tasks list, please contact with the support team');
  }
}
