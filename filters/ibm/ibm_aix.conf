filter {
    # IBM AIX filter version 2.0.0

    split {
      field => "message"
      terminator => "<utm-log-separator>"
    }

    #Looking for datasource generated by an agent and parse original message
    if [message]=~/\[utm_stack_agent_ds=(.+)\]-(.+)/ {
      grok {
       match => {
          "message" => [ "\[utm_stack_agent_ds=%{DATA:dataSourceAgent}\]-%{GREEDYDATA:original_log_message}" ]
        }
      }
    }
    if [original_log_message] {
      mutate {
        update => { "message" => "%{[original_log_message]}" }
      }
    }

    if ![dataType] {
# The log destination is already identified by the agent so, don't need an entry point
#......................................................................#
            
            #......................................................................# 
            #Generating dataType field required by CurrelationRulesEngine
            mutate {
                add_field => { "dataType" => "ibm-aix" }
            }
            #......................................................................#
            #Using grok to parse header of the message
            grok {
                match => {
                    "message" => "(%{INT:not_defined})?(\s)?(<%{NUMBER:priority}>)?(%{INT:syslog_version})?%{SYSLOGTIMESTAMP:timestamp}(\s)%{GREEDYDATA:msg_init}"
                }
            }
            #......................................................................#
            #Checking that the msg_init field exists
            if ([msg_init]){
                #......................................................................#
                #Checking that the message contains Message forwarded from
                if "Message forwarded from" in [message]{
                    grok {
                        match => {
                            "msg_init" => "Message(\s)forwarded(\s)from(\s)%{DATA:dataSource}: %{GREEDYDATA:msg_all}"
                        }
                    }

                    if [msg_all]{
                        #...................................................................#
                        #Checking that the message contains TTY= or PWD= or COMMAND= or USER=
                        if (("TTY=" in [msg_all] and ";" in [msg_all]) or ("PWD=" in [msg_all] and ";" in [msg_all]) or ("USER=" in [msg_all] and ";" in [msg_all]) or 
                        ("COMMAND=" in [msg_all] and ";" in [msg_all])){
                            #......................................................................#
                            #Using grok to parse msg_all
                            grok {
                                match => {
                                    "msg_all" => "%{DATA:commandType} : %{GREEDYDATA:msg_with_tty}"
                                }
                            }

                            #......................................................................#
                            #Using grok to parse msg_with_tty individual fields
                            if "TTY=" in [msg_with_tty]{
                                grok { match => { "msg_with_tty" => ["TTY=%{DATA:tty} ; %{WORD}=","TTY=%{GREEDYDATA:tty}"] } }
                            }
                            if "PWD=" in [msg_with_tty]{
                                grok { match => { "msg_with_tty" => ["PWD=%{DATA:pwd} ; %{WORD}=","PWD=%{GREEDYDATA:pwd}"] } }
                            }
                            if "USER=" in [msg_with_tty]{
                                grok { match => { "msg_with_tty" => ["USER=%{DATA:user} ; %{WORD}=","USER=%{GREEDYDATA:user}"] } }
                            }
                            if "COMMAND=" in [msg_with_tty]{
                                grok { match => { "msg_with_tty" => ["COMMAND=%{DATA:command} ; %{WORD}=","COMMAND=%{GREEDYDATA:command}"] } }
                            }

                        }else if ("command continued" in [msg_all]){
                            #......................................................................#
                            #Using grok to parse msg_all
                            grok {
                                match => {
                                    "msg_all" => "%{GREEDYDATA:commandType} : \(command continued\) %{GREEDYDATA:command}"
                                }
                            }
                        }else if([msg_all]=~/\w+\[[0-9]+\]: /){
                            grok {
                                match => {
                                    "msg_all" => "%{DATA:eventType}\[%{INT:PID}\]: %{GREEDYDATA:msg}"
                                }
                            }

                            if [msg]{
                                #......................................................................#
                                #Format where the LENGTH, SESSIONID, ENTRYID, STATEMENT, USERID, USERHOST, ACTION, RETURNCODE, OBJ$CREATOR, OBJ$NAME, and OS$USERID fields exist
                                if ("LENGTH" in [message] or "SESSIONID" in [message] or "ENTRYID" in [message] or "STATEMENT" in [message] or "USERID" in [message] or "USERHOST" in [message] or "ACTION" in [message]
                                or "RETURNCODE" in [message] or "OBJ$CREATOR" in [message] or "OBJ$NAME" in [message] or "OS$USERID" in [message]){
                                    #......................................................................#
                                    #Using grok to parse msg individual fields
                                    if "LENGTH:" in [msg]{
                                        grok { match => { "msg" => ["LENGTH: \"%{DATA:length}\""] } }
                                    }
                                    if "SESSIONID:" in [msg]{
                                        grok { match => { "msg" => ["SESSIONID:(\s)?\[%{INT:irrelevant}\] \"%{DATA:sessionID}\""] } }
                                    }
                                    if "ENTRYID:" in [msg]{
                                        grok { match => { "msg" => ["ENTRYID:(\s)?\[%{INT:irrelevant}\] \"%{DATA:entryID}\""] } }
                                    }
                                    if "STATEMENT:" in [msg]{
                                        grok { match => { "msg" => ["STATEMENT:(\s)?\[%{INT:irrelevant}\] \"%{DATA:statement}\""] } }
                                    }
                                    if "USERID:" in [msg]{
                                        grok { match => { "msg" => ["USERID:(\s)?\[%{INT:irrelevant}\] \"%{DATA:userID}\""] } }
                                    }
                                    if "USERHOST:" in [msg]{
                                        grok { match => { "msg" => ["USERHOST:(\s)?\[%{INT:irrelevant}\] \"%{DATA:userHost}\""] } }
                                    }
                                    if "ACTION:" in [msg]{
                                        grok { match => { "msg" => ["ACTION:(\s)?\[%{INT:irrelevant}\] \"%{DATA:action}\""] } }
                                    }
                                    if "RETURNCODE:" in [msg]{
                                        grok { match => { "msg" => ["RETURNCODE:(\s)?\[%{INT:irrelevant}\] \"%{DATA:returnCode}\""] } }
                                    }
                                    if [msg] =~/OBJ(.+)CREATOR:/{
                                        grok { match => { "msg" => ["OBJ%{DATA:irrelevant}CREATOR:(\s)?\[%{INT:irrelevant}\] \"%{DATA:obj_creator}\""] } }
                                    }
                                    if [msg] =~/OBJ(.+)NAME:/{
                                        grok { match => { "msg" => ["OBJ%{DATA:irrelevant}NAME:(\s)?\[%{INT:irrelevant}\] \"%{DATA:obj_name}\""] } }
                                    }
                                    if [msg] =~/OS(.+)USERID:/{
                                        grok { match => { "msg" => ["OS%{DATA:irrelevant}USERID:(\s)?\[%{INT:irrelevant}\] \"%{DATA:OS_userID}\""] } }
                                    }

                                }else if ([msg]=~/from(.+)port/){
                                    grok {
                                        match => {
                                            "msg" => [
                                                "%{DATA:irrelevant}from user %{WORD:irrelevant} %{DATA:src_ip} port %{INT:src_port}(%{GREEDYDATA:irrelevant})?",
                                                "%{DATA:irrelevant}from %{DATA:src_ip} port %{INT:src_port}(%{GREEDYDATA:irrelevant})?"
                                                ]
                                        }
                                    }
                                }
                            }
                        }else {
                            grok {
                            match => {
                                "msg_all" => [
                                    "%{GREEDYDATA:eventType}:(\s)%{GREEDYDATA:msg}",
                                    "%{GREEDYDATA:msg}"
                                    ]
                            }
                            }
                        }
                    }
                    
                }else{
                    grok {
                        match => {
                            "msg_init" => "%{WORD:eventType}: %{DATA:irrelevant}\[%{INT:PID}\] %{GREEDYDATA:msg}"
                        }
                    }
                }
               
            }
            #.....................................................................#
            #Generating dataSource field required by Correlation Engine
            if (![dataSource]){
              if ([dataSourceAgent]){
                mutate {
                    rename => { "[dataSourceAgent]" => "[dataSource]" }
                }
              } else {
                mutate {
                    add_field => { "dataSource" => "%{host}" }
                }
              }
            }
            #......................................................................#
            #Generating utm.action field required by Correlation Engine
            if ([msg] and [msg]=~/([Dd]isconnected (by|from))|([Rr]eceived [Dd]isconnect)|([Cc]onnection (is )?(closed|reset))/){
                mutate {
					          add_field => { "[logx][utm][action]" => "Success" }
				        }
            }

            #......................................................................#
            #Adding all fields to json tree structure
            mutate {
                rename => { "message" => "[logx][ibm_aix][message]" }
                rename => { "priority" => "[logx][ibm_aix][priority]" }
                rename => { "commandType" => "[logx][ibm_aix][commandType]" }
                rename => { "tty" => "[logx][ibm_aix][tty]" }
                rename => { "pwd" => "[logx][ibm_aix][pwd]" }
                rename => { "user" => "[logx][ibm_aix][user]" }
                rename => { "command" => "[logx][ibm_aix][command]" }
                rename => { "eventType" => "[logx][ibm_aix][eventType]" }
                rename => { "msg" => "[logx][ibm_aix][msg]" }
                rename => { "length" => "[logx][ibm_aix][length]" }
                rename => { "sessionID" => "[logx][ibm_aix][sessionID]" }
                rename => { "entryID" => "[logx][ibm_aix][entryID]" }
                rename => { "statement" => "[logx][ibm_aix][statement]" }
                rename => { "userID" => "[logx][ibm_aix][userID]" }
                rename => { "userHost" => "[logx][ibm_aix][userHost]" }
                rename => { "action" => "[logx][ibm_aix][action]" }
                rename => { "returnCode" => "[logx][ibm_aix][returnCode]" }
                rename => { "obj_creator" => "[logx][ibm_aix][obj_creator]" }
                rename => { "obj_name" => "[logx][ibm_aix][obj_name]" }
                rename => { "OS_userID" => "[logx][ibm_aix][OS_userID]" }
                rename => { "src_ip" => "[logx][ibm_aix][src_ip]" }
                rename => { "src_port" => "[logx][ibm_aix][src_port]" }
                rename => { "PID" => "[logx][ibm_aix][PID]" }
            }
            #......................................................................#
            #Finally, remove unnecessary fields
            mutate {
                remove_field => ["@version","timestamp","path","type","syslog_version",
                "not_defined","msg_all","msg_init","irrelevant", "msg_with_tty",
                "original_log_message","headers", "tags", "dataSourceAgent"]
            }
    }
}
