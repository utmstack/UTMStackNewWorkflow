filter {

# pfSense filter version 2.0.0
# Based on https://docs.netgate.com/pfsense/en/latest/monitoring/logs/raw-filter-format.html

    split {
      field => "message"
      terminator => "<utm-log-separator>"
    }

    #Looking for datasource generated by an agent and parse original message
    if [message]=~/\[utm_stack_agent_ds=(.+)\]-(.+)/ {
      grok {
       match => {
          "message" => [ "\[utm_stack_agent_ds=%{DATA:dataSource}\]-%{GREEDYDATA:original_log_message}" ]
        }
      }
    }
    if [original_log_message] {
      mutate {
        update => { "message" => "%{[original_log_message]}" }
      }
    }

    if ![dataType] {
# The log destination is already identified by the agent so, don't need an entry point
#......................................................................# 
#Generating dataType field required by CurrelationRulesEngine
            mutate {
                add_field => { "dataType" => "firewall-pfsense" }
            }
            
#......................................................................#
#Using grok to parse header of the message
            grok {
                match => {
                    "message" => "(%{INT:not_defined})?(\s)?(<%{NUMBER:priority}>)?(%{INT:syslog_version})? %{TIMESTAMP_ISO8601:timestamp} %{IPORHOST:syslog_host} %{GREEDYDATA:msg_all}"
                }
            }

            #......................................................................#
            #Checking that the msg_all field exists
            if ([msg_all]){
                if [message]=~/ filterlog(.+),(match|\w+),(block|pass),(in|out),(4|6)/{
                    grok {
                        match => {
                            "msg_all" => "%{WORD:event_type}(\s)?(\[)?(%{NUMBER:pid})?(\])?( - -|:) %{GREEDYDATA:csv_msg}"
                        }
                    }
                    #.....................................................................#
                    #Check if csv_msg exists and parsing it
                    if [csv_msg]{
                        #Changing the empty fields by X0X and then eliminating them
                        mutate {
                            gsub => [
                                "csv_msg", ",,", ",X0X,"
                            ]
                        }
                        #The gsub is repeated, because the first time it leaves some intermediate fields empty
                        mutate {
                            gsub => [
                                "csv_msg", ",,", ",X0X,"
                            ]
                        }

                        if [message]=~/ filterlog(.+),(match|\w+),(block|pass),(in|out),4,(.+)(tcp|TCP|Tcp)/{
                            csv {
                                source => "csv_msg"
                                skip_header => "true"
                                columns => ["rule_number", "sub_rule_number", "anchor", "tracker", "real_interface", "reason", 
                                            "action", "direction", "ip_version", "ipv4_tos", "ipv4_ecn", "ipv4_ttl", "ipv4_id", 
                                            "ipv4_offset", "ipv4_flags", "ipv4_protocol_id", "proto", "ip_length", "src_ip", "dest_ip",
                                            "src_port", "dest_port", "data_length", "tcp_flags", "sequence_number", "ack_number", 
                                            "tcp_window", "urg", "tcp_options"]
                            }
                        }else if [message]=~/ filterlog(.+),(match|\w+),(block|pass),(in|out),4,(.+)(udp|UDP|Udp)/{
                            csv {
                                source => "csv_msg"
                                skip_header => "true"
                                columns => ["rule_number", "sub_rule_number", "anchor", "tracker", "real_interface", "reason", 
                                            "action", "direction", "ip_version", "ipv4_tos", "ipv4_ecn", "ipv4_ttl", "ipv4_id", 
                                            "ipv4_offset", "ipv4_flags", "ipv4_protocol_id", "proto", "ip_length", "src_ip", "dest_ip",
                                            "src_port", "dest_port", "data_length"]
                            }
                        } else if [message]=~/ filterlog(.+),(match|\w+),(block|pass),(in|out),4,(.+)(icmp|ICMP|Icmp)/{
                            csv {
                                source => "csv_msg"
                                skip_header => "true"
                                columns => ["rule_number", "sub_rule_number", "anchor", "tracker", "real_interface", "reason", 
                                            "action", "direction", "ip_version", "ipv4_tos", "ipv4_ecn", "ipv4_ttl", "ipv4_id", 
                                            "ipv4_offset", "ipv4_flags", "ipv4_protocol_id", "proto", "ip_length", "src_ip", "dest_ip",
                                            "icmp_type", "icmp_data1", "icmp_data2", "icmp_data3", "icmp_data4", "icmp_data5"]

                            }
                        } else if [message]=~/ filterlog(.+),(match|\w+),(block|pass),(in|out),6,(.+)(tcp|TCP|Tcp)/{
                            csv {
                                source => "csv_msg"
                                skip_header => "true"
                                columns => ["rule_number", "sub_rule_number", "anchor", "tracker", "real_interface", "reason", 
                                            "action", "direction", "ip_version", "ipv6_class", "ipv6_flow_label", "ipv6_hop_limit", "proto", 
                                            "ipv6_protocol_id", "ip_length", "src_ip", "dest_ip",
                                            "src_port", "dest_port", "data_length", "tcp_flags", "sequence_number", "ack_number", 
                                            "tcp_window", "urg", "tcp_options"]
                            }
                        }else if [message]=~/ filterlog(.+),(match|\w+),(block|pass),(in|out),6,(.+)(udp|UDP|Udp)/{
                            csv {
                                source => "csv_msg"
                                skip_header => "true"
                                columns => ["rule_number", "sub_rule_number", "anchor", "tracker", "real_interface", "reason", 
                                            "action", "direction", "ip_version", "ipv6_class", "ipv6_flow_label", "ipv6_hop_limit", "proto", 
                                            "ipv6_protocol_id", "ip_length", "src_ip", "dest_ip",
                                            "src_port", "dest_port", "data_length"]
                            }
                        } else if [message]=~/ filterlog(.+),(match|\w+),(block|pass),(in|out),6,(.+)(icmp|ICMP|Icmp)/{
                            csv {
                                source => "csv_msg"
                                skip_header => "true"
                                columns => ["rule_number", "sub_rule_number", "anchor", "tracker", "real_interface", "reason", 
                                            "action", "direction", "ip_version", "ipv6_class", "ipv6_flow_label", "ipv6_hop_limit", "proto", 
                                            "ipv6_protocol_id", "ip_length", "src_ip", "dest_ip",
                                            "icmp_type", "icmp_data1", "icmp_data2", "icmp_data3", "icmp_data4", "icmp_data5"]

                            }
                        }
                        #......................................................................# 
                        #Rename the csv fields:
                        mutate {
                            rename => { "[rule_number]" => "[csv_field][rule_number]" }
                            rename => { "[sub_rule_number]" => "[csv_field][sub_rule_number]" }
                            rename => { "[anchor]" => "[csv_field][anchor]" }
                            rename => { "[tracker]" => "[csv_field][tracker]" }
                            rename => { "[real_interface]" => "[csv_field][real_interface]" }
                            rename => { "[reason]" => "[csv_field][reason]" }
                            rename => { "[action]" => "[csv_field][action]" }
                            rename => { "[direction]" => "[csv_field][direction]" }
                            rename => { "[ip_version]" => "[csv_field][ip_version]" }
                            rename => { "[ipv4_tos]" => "[csv_field][ipv4_tos]" }
                            rename => { "[ipv4_ecn]" => "[csv_field][ipv4_ecn]" }
                            rename => { "[ipv4_ttl]" => "[csv_field][ipv4_ttl]" }
                            rename => { "[ipv4_id]" => "[csv_field][ipv4_id]" }
                            rename => { "[ipv4_offset]" => "[csv_field][ipv4_offset]" }
                            rename => { "[ipv4_flags]" => "[csv_field][ipv4_flags]" }
                            rename => { "[ipv4_protocol_id]" => "[csv_field][ipv4_protocol_id]" }
                            rename => { "[proto]" => "[csv_field][proto]" }
                            rename => { "[ip_length]" => "[csv_field][ip_length]" }
                            rename => { "[src_ip]" => "[csv_field][src_ip]" }
                            rename => { "[dest_ip]" => "[csv_field][dest_ip]" }
                            rename => { "[src_port]" => "[csv_field][src_port]" }
                            rename => { "[dest_port]" => "[csv_field][dest_port]" }
                            rename => { "[data_length]" => "[csv_field][data_length]" }
                            rename => { "[tcp_flags]" => "[csv_field][tcp_flags]" }
                            rename => { "[sequence_number]" => "[csv_field][sequence_number]" }
                            rename => { "[ack_number]" => "[csv_field][ack_number]" }
                            rename => { "[tcp_window]" => "[csv_field][tcp_window]" }
                            rename => { "[urg]" => "[csv_field][urg]" }
                            rename => { "[tcp_options]" => "[csv_field][tcp_options]" }
                            rename => { "[ipv6_class]" => "[csv_field][ipv6_class]" }
                            rename => { "[ipv6_flow_label]" => "[csv_field][ipv6_flow_label]" }
                            rename => { "[ipv6_hop_limit]" => "[csv_field][ipv6_hop_limit]" }
                            rename => { "[ipv6_protocol_id]" => "[csv_field][ipv6_protocol_id]" }
                            rename => { "[icmp_type]" => "[csv_field][icmp_type]" }
                            rename => { "[icmp_data1]" => "[csv_field][icmp_data1]" }
                            rename => { "[icmp_data2]" => "[csv_field][icmp_data2]" }
                            rename => { "[icmp_data3]" => "[csv_field][icmp_data3]" }
                            rename => { "[icmp_data4]" => "[csv_field][icmp_data4]" }
                            rename => { "[icmp_data5]" => "[csv_field][icmp_data5]" }
                        }

                        #......................................................................# 
                        # Delete empty csv fields with ruby code
                        if [csv_field] {
                            ruby {
                                code => '
                                    event.get("[csv_field]").each do |k, v|
                                        if (v == "X0X") 
                                            event.remove(k)
                                        else
                                            event.set("[logx][pfsense][#{k}]",v)
                                        end
                                    end   
                                    '
                            }
                        }                   
                    }
                }else if[message]=~/ [a-z-_\.]+( \d+)? - - /{
                    grok {
                        match => {
                            "msg_all" => "%{DATA:event_type}( %{NUMBER:pid})? - - (- )?%{GREEDYDATA:msg}"
                        }
                    }
                }else if [message]=~/ \/(.+?)( \d+)? - - \((.+?)\) [A-Z]+ \((.+?)\)/{
                    grok {
                        match => {
                            "msg_all" => "%{PATH:process}( %{NUMBER:pid})? - - \(%{DATA:user}\) %{WORD:command_action} \(%{PATH:process_path}\)(GREEDYDATA:)?"
                        }
                    }
                }


            }

            #......................................................................# 
            # Rename other fields
            mutate {
                rename => { "[event_type]" => "[logx][pfsense][event_type]" }
                rename => { "[msg]" => "[logx][pfsense][msg]" }
                rename => { "[pid]" => "[logx][pfsense][pid]" }
                rename => { "[priority]" => "[logx][pfsense][priority]" }
                rename => { "[user]" => "[logx][pfsense][user]" }
                rename => { "[cmd]" => "[logx][pfsense][cmd]" }
                rename => { "[process]" => "[logx][pfsense][process]" }
                rename => { "[command_action]" => "[logx][pfsense][command_action]" }
                rename => { "[process_path]" => "[logx][pfsense][process_path]" }
                rename => { "[message]" => "[logx][pfsense][message]" }
            }
            
            #.....................................................................#
            #Generating dataSource field required by Correlation Engine
            if [syslog_host]{
                mutate {
                    update => { "[dataSource]" => "%{[syslog_host]}" }
                }
                mutate {
                    rename => { "[syslog_host]" => "[logx][pfsense][syslog_host]" }
                }
            }
            if (![dataSource]){
                mutate {
                    add_field => { "dataSource" => "%{host}" }
                }
            }

            #......................................................................#
            #Generating action field for established connections
            if [logx][pfsense][action] and [logx][pfsense][action] == "pass"  {
                mutate {
                    add_field => { "[logx][utm][action]" => "Success" }
                }
            }
            if [logx][pfsense][msg] and [logx][pfsense][msg]=~/[Cc]onnection reset/{
                mutate {
                    add_field => { "[logx][utm][action]" => "Success" }
                }
            }

            #......................................................................#
            #Finally, remove unnecessary fields
            mutate {
                remove_field => ["@version","timestamp","path","type","syslog_version",
                "not_defined", "path", "event", "csv_msg", "csv_field", "msg_all"]
            }

 }
   #Also, remove unwanted fields if the message not match with conditions
   mutate {
      remove_field => ["@version","path","original_log_message","headers", "tags"]
   }
}
