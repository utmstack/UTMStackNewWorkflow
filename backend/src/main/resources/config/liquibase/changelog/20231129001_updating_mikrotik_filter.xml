<?xml version="1.0" encoding="utf-8"?>
<databaseChangeLog
    xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.5.xsd">

    <changeSet id="20231129001" author="Freddy">

        <sql dbms="postgresql" splitStatements="true" stripComments="true">
            <![CDATA[

            UPDATE utm_logstash_filter
            SET logstash_filter='filter {

# Mikrotik firewall filter version 2.0.2
# Based on https://wiki.mikrotik.com/wiki/Manual:System/Log (june, 2022)
# and https://wiki.mikrotik.com/wiki/Manual:Routing_Table_Matcher (june, 2022)
# and https://datatracker.ietf.org/doc/html/rfc3164 (june, 2022)
# and example logs provided

    split {
      field => "message"
      terminator => "<utm-log-separator>"
    }

    #Looking for datasource generated by an agent and parse original message
    if [message]=~/\[utm_stack_agent_ds=(.+)\]-(.+)/ {
      grok {
       match => {
          "message" => [ "\[utm_stack_agent_ds=%{DATA:dataSource}\]-%{GREEDYDATA:original_log_message}" ]
        }
      }
    }
    if [original_log_message] {
      mutate {
        update => { "message" => "%{[original_log_message]}" }
      }
    }

    if ![dataType] {
# The log destination is already identified by the agent so, don''t need an entry point
#......................................................................#
#Generating dataSource field required by CurrelationRulesEngine
#Checks if exists, if not evaluate to the host variable
           if (![dataSource]){
              mutate {
               add_field => { "dataSource" => "%{host}" }
              }
           }
#......................................................................#
#Generating dataType field required by CurrelationRulesEngine
              mutate {
               add_field => { "dataType" => "firewall-mikrotik" }
              }
#......................................................................#
#Using grok to parse header of the message
#First if message begins with time format
        if [message]=~/^\d/ {
          grok {
            match => {
              "message" => [
                 "(?<syslog_time>((2[0123])|([0-1][0-9])\:([0-5][0-9])\:([0-5][0-9]|60)))(\s)%{GREEDYDATA:mikrotik_msg}"
              ]
            }
          }
#else normal syslog RFC 3164
        }else {
          grok {
            match => {
              "message" => [
                 "(<%{NUMBER:priority}>)?(%{INT:syslog_version})?(\s)?(%{SYSLOGTIMESTAMP:syslog_time})?(\s)?%{GREEDYDATA:mikrotik_msg}"
              ]
            }
          }
        }
#......................................................................#
#If begins with, something like syslog with only time like: <181>1 11:06:31, needs to be parsed again
        if ![syslog_time] {
          if [mikrotik_msg] {
             grok {
               match => {
                 "mikrotik_msg" => [
                    "(?<syslog_time>((2[0123])|([0-1][0-9])\:([0-5][0-9])\:([0-5][0-9]|60)))(\s)%{GREEDYDATA:mikrotik_msg_tmp}"
                 ]
               }
             }
          #Set mikrotik_msg_tmp fieldname and value to mikrotik_msg (This one is used to parse the rest of the message field)
             mutate {
              rename => { "mikrotik_msg_tmp" => "mikrotik_msg" }
             }
          }
        }
#......................................................................#
#Using grok to parse rest of the message
        if [mikrotik_msg] {
          grok {
            match => {
              "mikrotik_msg" => [
                 "%{GREEDYDATA:topics}(\s)%{WORD:chain}:(\s)in:%{GREEDYDATA:in_iface}(\s)out:%{GREEDYDATA:out_iface}, src-mac %{DATA:src_mac}, proto %{GREEDYDATA:proto}, %{IP:src_ip}(\:%{INT:src_port})?->%{IP:dest_ip}(\:%{INT:dest_port})?, len %{INT:len}(%{GREEDYDATA:irrelevant})?"
              ]
            }
          }
        }
#......................................................................#
#Formatting number values
   mutate {
      convert => {
            "priority" => "integer"
            "len" => "integer"
            "src_port" => "integer"
            "dest_port" => "integer"
        }
   }
#......................................................................#
#Add the rest of fields to the tree structure
        mutate {
          rename => { "syslog_time" => "[logx][mikrotik_fw][syslog_time]" }
          rename => { "priority" => "[logx][mikrotik_fw][priority]" }
          rename => { "topics" => "[logx][mikrotik_fw][topics]" }
          rename => { "chain" => "[logx][mikrotik_fw][chain]" }
          rename => { "len" => "[logx][mikrotik_fw][len]" }
          rename => { "in_iface" => "[logx][mikrotik_fw][in_iface]" }
          rename => { "out_iface" => "[logx][mikrotik_fw][out_iface]" }
          rename => { "src_mac" => "[logx][mikrotik_fw][src_mac]" }
          rename => { "syslog_version" => "[logx][mikrotik_fw][syslog_version]" }
          rename => { "message" => "[logx][mikrotik_fw][message]" }

          #Rename fields used by correlation engine
          rename => { "src_ip" => "[logx][mikrotik_fw][src_ip]" }
          rename => { "src_port" => "[logx][mikrotik_fw][src_port]" }
          rename => { "dest_ip" => "[logx][mikrotik_fw][dest_ip]" }
          rename => { "dest_port" => "[logx][mikrotik_fw][dest_port]" }
          rename => { "proto" => "[logx][mikrotik_fw][proto]" }
        }


   #Finally, remove unnecessary fields
   mutate {
      remove_field => ["@version","path","tags","type","irrelevant","mikrotik_msg"]
   }
   #Generate action field
   if [logx][mikrotik_fw][src_ip] and [logx][mikrotik_fw][dest_ip] {
      if [logx][mikrotik_fw][proto] and ("TCP" in [logx][mikrotik_fw][proto]) {
        if ("FIN" in [logx][mikrotik_fw][proto] or "RST" in [logx][mikrotik_fw][proto] or "ACK" in [logx][mikrotik_fw][proto]){
          mutate { add_field => { "[logx][utm][action]" => "Success" } }
        }
      } else if [logx][mikrotik_fw][proto] and ([logx][mikrotik_fw][len] and [logx][mikrotik_fw][len]>0) {
          mutate { add_field => { "[logx][utm][action]" => "Success" } }
      }
   }

 }
   #Also, remove unwanted fields if the message not match with conditions
   mutate {
      remove_field => ["@version","path","original_log_message","headers"]
   }
}
',filter_version='2.0.2'
            WHERE id=1508;

            ]]>
        </sql>
    </changeSet>
</databaseChangeLog>
