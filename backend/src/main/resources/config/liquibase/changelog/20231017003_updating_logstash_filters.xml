<?xml version="1.0" encoding="utf-8"?>
<databaseChangeLog
    xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.5.xsd">

    <changeSet id="20231017003" author="Freddy">

        <sql dbms="postgresql" splitStatements="true" stripComments="true">
            <![CDATA[
----------------------------------------------------------------------------------------------------------------------------------------
-- ESET  --
----------------------------------------------------------------------------------------------------------------------------------------
UPDATE utm_logstash_filter SET filter_version='2.0.1',logstash_filter='filter {

# ESET filter version 2.0.1
# Based in https://help.eset.com/esmc_admin/70/en-US/events-exported-to-json-format.html#custom_keys
# and real logs provided
    split {
      field => "message"
      terminator => "<utm-log-separator>"
    }

    #Looking for datasource generated by an agent and parse original message
    if [message]=~/\[utm_stack_agent_ds=(.+)\]-(.+)/ {
     grok {
      match => {
        "message" => [ "\[utm_stack_agent_ds=%{DATA:dataSource}\]-%{GREEDYDATA:original_log_message}" ]
      }
     }
    }
    if [original_log_message] {
     mutate {
      update => { "message" => "%{[original_log_message]}" }
     }
    }

    if ![dataType] {
        #First, search for common fields to define the entry point
        if [message] and "event_type" in [message] and "source_uuid" in [message] and "occured" in [message] and "severity" in [message] {
#......................................................................#
#Generating dataSource field required by CurrelationRulesEngine
#Checks if exists, if not evaluate to the host variable
           if (![dataSource]){
              mutate {
               add_field => { "dataSource" => "%{host}" }
              }
           }
#......................................................................#
#Generating dataType field required by CurrelationRulesEngine
              mutate {
               add_field => { "dataType" => "antivirus-esmc-eset" }
              }
#......................................................................#
#Using grok to parse header of the message
          grok {
            match => {
              "message" => [
                 "(%{INT:not_defined})?(\s)?(<%{NUMBER:priority}>)?(%{INT:syslog_version})? %{DATA:syslog_time} %{DATA:syslog_host} %{DATA:syslog_app} %{INT:pid} - - %{GREEDYDATA:json_msg}"
              ]
            }
          }
#......................................................................#
#Using grok to get the json message
      if [json_msg] {
        if [json_msg] =~/^\{/ {
           json {
             source => "json_msg"
             target => "[logx][esmc_eset]"
           }
        } else {
			#Control if have a non ascii char at start of json message
            grok {
              match => {
               "json_msg" => [
                 "\W%{GREEDYDATA:json_msg_clean}"
               ]
              }
            }
            json {
             source => "json_msg_clean"
             target => "[logx][esmc_eset]"
            }
          }
      }
#......................................................................#
#Formatting number values
   mutate {
      convert => {
            "priority" => "integer"
        }
   }
#......................................................................#
#Add the rest of fields to the tree structure
        mutate {
          rename => { "[syslog_time]" => "[logx][esmc_eset][syslog_time]" }
          rename => { "[pid]" => "[logx][esmc_eset][syslog_pid]" }
          rename => { "[syslog_host]" => "[logx][esmc_eset][syslog_host]" }
          rename => { "[syslog_app]" => "[logx][esmc_eset][syslog_app]" }
          rename => { "[priority]" => "[logx][esmc_eset][syslog_priority]" }
          rename => { "[message]" => "[logx][esmc_eset][message]" }

          #Rename fields used by correlation engine
          rename => { "[logx][esmc_eset][source_address]" => "[logx][esmc_eset][src_ip]" }
          rename => { "[logx][esmc_eset][source_port]" => "[logx][esmc_eset][src_port]" }
          rename => { "[logx][esmc_eset][target_address]" => "[logx][esmc_eset][dest_ip]" }
          rename => { "[logx][esmc_eset][target_port]" => "[logx][esmc_eset][dest_port]" }
          rename => { "[logx][esmc_eset][protocol]" => "[logx][esmc_eset][proto]" }
        }


   #Finally, remove unnecessary fields
   mutate {
      remove_field => ["@version","path","tags","type","syslog_version","not_defined","json_msg","json_msg_clean"]
   }
  }
 }
   #Also, remove unwanted fields if the message not match with conditions
   mutate {
      remove_field => ["original_log_message","headers"]
   }
}
'
            WHERE id=1501;

----------------------------------------------------------------------------------------------------------------------------------------
-- KASPERSKY  --
----------------------------------------------------------------------------------------------------------------------------------------
UPDATE utm_logstash_filter
SET filter_version='2.0.1',logstash_filter='filter {

# KAV filter version 2.0.1
# Support Syslog CEF format
# Based in https://docs.centrify.com/Content/IntegrationContent/SIEM/arcsight-cef/arcsight-cef-format.htm
# and https://docs.devo.com/confluence/ndt/latest/devo-parsers/technologies-supported-in-cef-syslog-format/cef0-kaspersky
# and https://support.kaspersky.com/KLMS/8.2/en-US/151504.htm
# and https://support.kaspersky.com/ScanEngine/1.0/en-US/186767.htm

split {
  field => "message"
  terminator => "<utm-log-separator>"
}

  #Looking for datasource generated by an agent and parse original message
  if [message]=~/\[utm_stack_agent_ds=(.+)\]-(.+)/ {
    grok {
      match => {
        "message" => [ "\[utm_stack_agent_ds=%{DATA:dataSource}\]-%{GREEDYDATA:original_log_message}" ]
      }
    }
  }
  if [original_log_message] {
    mutate {
      update => { "message" => "%{[original_log_message]}" }
    }
  }

if ![dataType] {
        #First, search to define the entry point contain CEF:, contain |something
        if [message] and ("CEF:" in [message] and [message] =~/\|(\w+)?(\s)?Kaspersky(\s)?(\w+)?\|/
        and ( [message] =~/cs\d/ or "in=" in [message] or "out=" in [message] or "end=" in [message])){
#......................................................................#
#Generating dataSource field required by CurrelationRulesEngine
#Checks if exists, if not evaluate to the host variable
           if (![dataSource]){
              mutate {
               add_field => { "dataSource" => "%{host}" }
              }
           }
#......................................................................#
#Generating dataType field required by CurrelationRulesEngine
              mutate {
               add_field => { "dataType" => "antivirus-kaspersky" }
              }
#......................................................................#
#Using grok to parse header of the message
              if [message] =~/^(CEF)/ {
               grok {
                 match => {
                   "message" => [
                      "CEF:%{INT:cef_version}%{GREEDYDATA:cef_msg_all}"
                   ]
                 }
               }
              } else {
                grok {
                 match => {
                   "message" => [
                      "(%{INT:not_defined})?(\s)?(<%{NUMBER:priority}>)?(%{INT:syslog_version})? %{GREEDYDATA:syslog_date_host}CEF:(\s)?%{INT:cef_version}%{GREEDYDATA:cef_msg_all}"
                   ]
                 }
               }
              }
#......................................................................#
#Using grok to parse components of the cef_message
              if [cef_msg_all] {
               grok {
                 match => {
                   "cef_msg_all" => [
                      "\|%{DATA:embDeviceVendor}\|%{DATA:embDeviceProduct}\|%{DATA:deviceVersion}\|%{DATA:signatureID}\|%{DATA:desc_msg}\|%{DATA:cef_device_severity}\|(\s)?%{GREEDYDATA:cef_msg}"
                   ]
                 }
               }
              }
#......................................................................#
#Using the kv filter with default config, usefull in key-value logs
        if [cef_msg]{
          kv { source => "cef_msg" }
        }

#......................................................................#
#Remove fields that have issues with kv filter
   mutate {
      remove_field => ["destinationZoneURI","msg","customerURI","destinationZoneExternalID",
      "cs1","cs2","cs3","cs4","cs5","cs6","cs7","cs8","cs9","cs10","originalAgentZoneURI","flexString1","cat",
      "cs1Label","cs2Label","cs3Label","cs4Label","cs5Label","cs6Label","cs7Label","cs8Label","cs9Label","cs10Label",
      "cn1","cn2","cn3","cn4","cn5","cn6","cn7","cn8","cn9","cn10","cn1Label","cn2Label","cn3Label","cn4Label",
      "cn5Label","cn6Label","cn7Label","cn8Label","cn9Label","cn10Label"]
   }
#......................................................................#
#Using grok to parse kv issued fields
        if [cef_msg]{
          grok { match => { "cef_msg" => [ "destinationZoneURI=%{DATA:destinationZoneURI} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "msg=%{DATA:msg} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "customerURI=%{DATA:customerURI} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "destinationZoneExternalID=%{DATA:destinationZoneExternalID} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "cs1=%{DATA:cs1} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "cs2=%{DATA:cs2} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "cs3=%{DATA:cs3} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "cs4=%{DATA:cs4} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "cs5=%{DATA:cs5} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "cs6=%{DATA:cs6} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "cs7=%{DATA:cs7} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "cs8=%{DATA:cs8} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "cs9=%{DATA:cs9} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "cs10=%{DATA:cs10} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "cn1=%{DATA:cn1} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "cn2=%{DATA:cn2} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "cn3=%{DATA:cn3} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "cn4=%{DATA:cn4} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "cn5=%{DATA:cn5} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "cn6=%{DATA:cn6} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "cn7=%{DATA:cn7} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "cn8=%{DATA:cn8} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "cn9=%{DATA:cn9} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "cn10=%{DATA:cn10} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "originalAgentZoneURI=%{DATA:originalAgentZoneURI} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "flexString1=%{DATA:flexString1} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "cat=%{DATA:cat} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "cs1Label=%{DATA:cs1Label} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "cs2Label=%{DATA:cs2Label} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "cs3Label=%{DATA:cs3Label} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "cs4Label=%{DATA:cs4Label} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "cs5Label=%{DATA:cs5Label} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "cs6Label=%{DATA:cs6Label} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "cs7Label=%{DATA:cs7Label} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "cs8Label=%{DATA:cs8Label} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "cs9Label=%{DATA:cs9Label} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "cs10Label=%{DATA:cs10Label} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "cn1Label=%{DATA:cn1Label} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "cn2Label=%{DATA:cn2Label} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "cn3Label=%{DATA:cn3Label} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "cn4Label=%{DATA:cn4Label} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "cn5Label=%{DATA:cn5Label} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "cn6Label=%{DATA:cn6Label} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "cn7Label=%{DATA:cn7Label} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "cn8Label=%{DATA:cn8Label} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "cn9Label=%{DATA:cn9Label} %{WORD}=" ] } }
          grok { match => { "cef_msg" => [ "cn10Label=%{DATA:cn10Label} %{WORD}=" ] } }
        }
#......................................................................#
#Add the rest of fields to the tree structure
    #src can be in multiple fields
    if [src] {
        mutate {
          rename => { "[src]" => "[logx][kaspersky][src_ip]" }
        }
    } else if [cs4Label] and ("clientIp" in [cs4Label] or "ClientIp" in [cs4Label] or "ClientIP" in [cs4Label]) {
        mutate {
          rename => { "[cs4]" => "[logx][kaspersky][src_ip]" }
        }
    } else if [FromIPAddress] {
        mutate {
          rename => { "[FromIPAddress]" => "[logx][kaspersky][src_ip]" }
        }
    }
       mutate {

          #Rename fields used by correlation engine
          rename => { "[dst]" => "[logx][kaspersky][dest_ip]" }
          rename => { "[protocol]" => "[logx][kaspersky][proto]" }

          #Rename fields used by correlation engine
          rename => { "[at]" => "[logx][kaspersky][at]" }
          rename => { "[cs1]" => "[logx][kaspersky][cs1]" }
          rename => { "[cs2]" => "[logx][kaspersky][cs2]" }
          rename => { "[cs3]" => "[logx][kaspersky][cs3]" }
          rename => { "[cs4]" => "[logx][kaspersky][cs4]" }
          rename => { "[cs5]" => "[logx][kaspersky][cs5]" }
          rename => { "[cs6]" => "[logx][kaspersky][cs6]" }
          rename => { "[cs7]" => "[logx][kaspersky][cs7]" }
          rename => { "[cs8]" => "[logx][kaspersky][cs8]" }
          rename => { "[cs9]" => "[logx][kaspersky][cs9]" }
          rename => { "[cs10]" => "[logx][kaspersky][cs10]" }
          rename => { "[cs1Label]" => "[logx][kaspersky][cs1Label]" }
          rename => { "[cs2Label]" => "[logx][kaspersky][cs2Label]" }
          rename => { "[cs3Label]" => "[logx][kaspersky][cs3Label]" }
          rename => { "[cs4Label]" => "[logx][kaspersky][cs4Label]" }
          rename => { "[cs5Label]" => "[logx][kaspersky][cs5Label]" }
          rename => { "[cs6Label]" => "[logx][kaspersky][cs6Label]" }
          rename => { "[cs7Label]" => "[logx][kaspersky][cs7Label]" }
          rename => { "[cs8Label]" => "[logx][kaspersky][cs8Label]" }
          rename => { "[cs9Label]" => "[logx][kaspersky][cs9Label]" }
          rename => { "[cs10Label]" => "[logx][kaspersky][cs10Label]" }
          rename => { "[cn1]" => "[logx][kaspersky][cn1]" }
          rename => { "[cn2]" => "[logx][kaspersky][cn2]" }
          rename => { "[cn3]" => "[logx][kaspersky][cn3]" }
          rename => { "[cn4]" => "[logx][kaspersky][cn4]" }
          rename => { "[cn5]" => "[logx][kaspersky][cn5]" }
          rename => { "[cn6]" => "[logx][kaspersky][cn6]" }
          rename => { "[cn7]" => "[logx][kaspersky][cn7]" }
          rename => { "[cn8]" => "[logx][kaspersky][cn8]" }
          rename => { "[cn9]" => "[logx][kaspersky][cn9]" }
          rename => { "[cn10]" => "[logx][kaspersky][cn10]" }
          rename => { "[cn1Label]" => "[logx][kaspersky][cn1Label]" }
          rename => { "[cn2Label]" => "[logx][kaspersky][cn2Label]" }
          rename => { "[cn3Label]" => "[logx][kaspersky][cn3Label]" }
          rename => { "[cn4Label]" => "[logx][kaspersky][cn4Label]" }
          rename => { "[cn5Label]" => "[logx][kaspersky][cn5Label]" }
          rename => { "[cn6Label]" => "[logx][kaspersky][cn6Label]" }
          rename => { "[cn7Label]" => "[logx][kaspersky][cn7Label]" }
          rename => { "[cn8Label]" => "[logx][kaspersky][cn8Label]" }
          rename => { "[cn9Label]" => "[logx][kaspersky][cn9Label]" }
          rename => { "[cn10Label]" => "[logx][kaspersky][cn10Label]" }
          rename => { "[eventId]" => "[logx][kaspersky][eventId]" }
          rename => { "[externalId]" => "[logx][kaspersky][externalId]" }
          rename => { "[msg]" => "[logx][kaspersky][msg]" }
          rename => { "[end]" => "[logx][kaspersky][end]" }
          rename => { "[mrt]" => "[logx][kaspersky][mrt]" }
          rename => { "[in]" => "[logx][kaspersky][in]" }
          rename => { "[out]" => "[logx][kaspersky][out]" }
          rename => { "[customerID]" => "[logx][kaspersky][customerID]" }
          rename => { "[customerURI]" => "[logx][kaspersky][customerURI]" }
          rename => { "[catdt]" => "[logx][kaspersky][catdt]" }
          rename => { "[modelConfidence]" => "[logx][kaspersky][modelConfidence]" }
          rename => { "[cef_device_severity]" => "[logx][kaspersky][cef_device_severity]" }
          rename => { "[relevance]" => "[logx][kaspersky][relevance]" }
          rename => { "[assetCriticality]" => "[logx][kaspersky][assetCriticality]" }
          rename => { "[priority]" => "[logx][kaspersky][priority]" }
          rename => { "[art]" => "[logx][kaspersky][art]" }
          rename => { "[cat]" => "[logx][kaspersky][cat]" }
          rename => { "[deviceSeverity]" => "[logx][kaspersky][deviceSeverity]" }
          rename => { "[act]" => "[logx][kaspersky][act]" }
          rename => { "[rt]" => "[logx][kaspersky][rt]" }
          rename => { "[dhost]" => "[logx][kaspersky][dhost]" }
          rename => { "[destinationZoneID]" => "[logx][kaspersky][destinationZoneID]" }
          rename => { "[destinationZoneURI]" => "[logx][kaspersky][destinationZoneURI]" }
          rename => { "[destinationZoneExternalID]" => "[logx][kaspersky][destinationZoneExternalID]" }
          rename => { "[dntdom]" => "[logx][kaspersky][dntdom]" }
          rename => { "[dlong]" => "[logx][kaspersky][dlong]" }
          rename => { "[dlat]" => "[logx][kaspersky][dlat]" }
          rename => { "[fname]" => "[logx][kaspersky][fname]" }
          rename => { "[flexString1]" => "[logx][kaspersky][flexString1]" }
          rename => { "[cn3]" => "[logx][kaspersky][cn3]" }
          rename => { "[locality]" => "[logx][kaspersky][locality]" }
          rename => { "[ahost]" => "[logx][kaspersky][ahost]" }
          rename => { "[agt]" => "[logx][kaspersky][agt]" }
          rename => { "[amac]" => "[logx][kaspersky][amac]" }
          rename => { "[av]" => "[logx][kaspersky][av]" }
          rename => { "[atz]" => "[logx][kaspersky][atz]" }
          rename => { "[dvchost]" => "[logx][kaspersky][dvchost]" }
          rename => { "[dtz]" => "[logx][kaspersky][dtz]" }
          rename => { "[eventAnnotationStageUpdateTime]" => "[logx][kaspersky][eventAnnotationStageUpdateTime]" }
          rename => { "[eventAnnotationModificationTime]" => "[logx][kaspersky][eventAnnotationModificationTime]" }
          rename => { "[eventAnnotationAuditTrail]" => "[logx][kaspersky][eventAnnotationAuditTrail]" }
          rename => { "[eventAnnotationVersion]" => "[logx][kaspersky][eventAnnotationVersion]" }
          rename => { "[eventAnnotationFlags]" => "[logx][kaspersky][eventAnnotationFlags]" }
          rename => { "[eventAnnotationEndTime]" => "[logx][kaspersky][eventAnnotationEndTime]" }
          rename => { "[eventAnnotationManagerReceiptTime]" => "[logx][kaspersky][eventAnnotationManagerReceiptTime]" }
          rename => { "[originalAgentHostName]" => "[logx][kaspersky][originalAgentHostName]" }
          rename => { "[originalAgentAddress]" => "[logx][kaspersky][originalAgentAddress]" }
          rename => { "[originalAgentMacAddress]" => "[logx][kaspersky][originalAgentMacAddress]" }
          rename => { "[originalAgentZoneURI]" => "[logx][kaspersky][originalAgentZoneURI]" }
          rename => { "[originalAgentVersion]" => "[logx][kaspersky][originalAgentVersion]" }
          rename => { "[originalAgentId]" => "[logx][kaspersky][originalAgentId]" }
          rename => { "[originalAgentType]" => "[logx][kaspersky][originalAgentType]" }
          rename => { "[_cefVer]" => "[logx][kaspersky][_cefVer]" }
          rename => { "[ad.arcSightEventPath]" => "[logx][kaspersky][ad.arcSightEventPath]" }
          rename => { "[aid]" => "[logx][kaspersky][aid]" }
          rename => { "[signatureID]" => "[logx][kaspersky][signatureID]" }
          rename => { "[embDeviceVendor]" => "[logx][kaspersky][embDeviceVendor]" }
          rename => { "[embDeviceProduct]" => "[logx][kaspersky][embDeviceProduct]" }
          rename => { "[desc_msg]" => "[logx][kaspersky][desc_msg]" }
          rename => { "[cef_version]" => "[logx][kaspersky][cef_version]" }
          rename => { "[deviceVersion]" => "[logx][kaspersky][deviceVersion]" }
          rename => { "[severity]" => "[logx][kaspersky][severity]" }
          rename => { "[message]" => "[logx][kaspersky][message]" }

          #New fields detected in docs Kaspersky Security 8 for Linux Mail Server
          rename => { "[duser]" => "[logx][kaspersky][duser]" }
          rename => { "[suser]" => "[logx][kaspersky][suser]" }
          rename => { "[deviceProcessName]" => "[logx][kaspersky][deviceProcessName]" }
          rename => { "[cnt]" => "[logx][kaspersky][cnt]" }
          rename => { "[reason]" => "[logx][kaspersky][reason]" }
          rename => { "[outcome]" => "[logx][kaspersky][outcome]" }
          rename => { "[deviceCustomDate1]" => "[logx][kaspersky][deviceCustomDate1]" }
          rename => { "[deviceCustomDate1Label]" => "[logx][kaspersky][deviceCustomDate1Label]" }
          rename => { "[deviceServiceName]" => "[logx][kaspersky][deviceServiceName]" }
          rename => { "[deviceCustomDate2]" => "[logx][kaspersky][deviceCustomDate2]" }
          rename => { "[deviceCustomDate2Label]" => "[logx][kaspersky][deviceCustomDate2Label]" }
          rename => { "[fsize]" => "[logx][kaspersky][fsize]" }

          #New fields detected in docs Kaspersky Scan Engine
          rename => { "[dvcpid]" => "[logx][kaspersky][dvcpid]" }
          rename => { "[sproc]" => "[logx][kaspersky][sproc]" }
          rename => { "[dvc]" => "[logx][kaspersky][dvc]" }
          rename => { "[request]" => "[logx][kaspersky][request]" }
          rename => { "[fileHash]" => "[logx][kaspersky][fileHash]" }
          rename => { "[start]" => "[logx][kaspersky][start]" }

          #New fields detected in version 1.0.3 (real logs, SIEM)
          rename => { "[engine]" => "[logx][kaspersky][engine]" }
          rename => { "[method]" => "[logx][kaspersky][method]" }
          rename => { "[filePath]" => "[logx][kaspersky][filePath]" }
        }


   #Finally, remove unnecessary fields
   mutate {
      remove_field => ["@version","path","tags","type","syslog_version",
      "not_defined","cef_msg_all","cef_msg","syslog_date_host"]
   }
  }
 }
   #Also, remove unwanted fields if the message not match with conditions
   mutate {
      remove_field => ["original_log_message","headers"]
   }
}
'
WHERE id=1502;
----------------------------------------------------------------------------------------------------------------------------------------
-- SENTINELONE  --
----------------------------------------------------------------------------------------------------------------------------------------
UPDATE utm_logstash_filter
SET filter_version='2.0.1',logstash_filter='filter {

# SentinelOne filter version 2.0.1
# Support Syslog CEF format
# Based on https://docs.centrify.com/Content/IntegrationContent/SIEM/arcsight-cef/arcsight-cef-format.htm
# and https://docs.fortinet.com/document/fortisiem/6.1.0/external-systems-configuration-guide/298395/sentinelone

split {
  field => "message"
  terminator => "<utm-log-separator>"
}

  #Looking for datasource generated by an agent and parse original message
  if [message]=~/\[utm_stack_agent_ds=(.+)\]-(.+)/ {
    grok {
      match => {
        "message" => [ "\[utm_stack_agent_ds=%{DATA:dataSource}\]-%{GREEDYDATA:original_log_message}" ]
      }
    }
  }
  if [original_log_message] {
    mutate {
      update => { "message" => "%{[original_log_message]}" }
    }
  }

if ![dataType] {
        #First, search to define the entry point contain CEF:, contain |something, or look for SentinelOne
        if [message] and ( ( ("CEF:" in [message] and [message] =~/\|(\w+)?(\s)?SentinelOne(\s)?(\w+)?\|/ ) or [message] =~/(\w+)?(\s)SentinelOne(\s)(\w+)?/ )
        and ( "rt=" in [message] or "uuid=" in [message] or "suser=" in [message] or "cat=" in [message] ) ) {
#......................................................................#
#Generating dataSource field required by CurrelationRulesEngine
#Checks if exists, if not evaluate to the host variable
           if (![dataSource]){
              mutate {
               add_field => { "dataSource" => "%{host}" }
              }
           }
#......................................................................#
#Generating dataType field required by CurrelationRulesEngine
              mutate {
               add_field => { "dataType" => "antivirus-sentinel-one" }
              }
#......................................................................#
#If CEF formatted log do the parsing of the message if not
#delete strings parts with conflictive format in the message, to move to key->value pairs format
        if ("CEF:" in [message] ) {
#......................................................................#
#Using grok to parse header of the message
            grok {
              match => {
                "message" => [
                   "(%{INT:not_defined})?(\s)?(<%{NUMBER:priority}>)?(%{INT:syslog_version})?((\s)%{GREEDYDATA:syslog_date_host}(\s))?CEF:(\s)?%{INT:cef_version}%{GREEDYDATA:cef_msg_all}"
                ]
              }
            }
#......................................................................#
#Using grok to parse components of the cef_message_all
          if [cef_msg_all] {
            grok {
              match => {
                "cef_msg_all" => [
                   "\|%{DATA:embDeviceVendor}\|%{DATA:embDeviceProduct}\|%{DATA:deviceVersion}\|%{DATA:signatureID}\|%{DATA:act_msg}\|%{DATA:severity}\|%{GREEDYDATA:cef_msg}",
                   "\|%{DATA:embDeviceVendor}\|%{DATA:embDeviceProduct}\|%{DATA:signatureID}\|%{DATA:act_msg}\|%{DATA:severity}\|%{GREEDYDATA:cef_msg}",
                   "\|%{DATA:embDeviceVendor}\|%{DATA:embDeviceProduct}\|%{GREEDYDATA:cef_msg}"
                ]
              }
            }
          }
        } else {
#Extract the relevant part of the message, to clean after
            grok {
              match => {
                "message" => [
                   "(%{INT:not_defined})?(\s)?(<%{NUMBER:priority}>)?(%{INT:syslog_version})?((\s)%{GREEDYDATA:syslog_date_host}(\s))?SentinelOne(\s)%{WORD:irrelevant} %{WORD:irrelevant} %{GREEDYDATA:init_msg}"
                ]
              }
            }
            if [init_msg] {
               #If not CEF, log comes in [something@number something="xxxx"] format, we need only something="xxxx" to perform kv, so
               #First mutation replace ][something@number something= with something=, after this only the first occurrence of the format has to
               #be replaced
               mutate {
                 gsub => [
                   "init_msg", "\]\[(.+)@(\d+)(\s)\1=", " \1="
                 ]
               }
               #Second mutation delete the first occurence pending
               mutate {
                 gsub => [
                   "init_msg", "\[(.+)@(\d+)(\s)\1=", "\1="
                 ]
               }
               #Third mutation delete the last ] remaining
               grok {
                 match => {
                   "init_msg" => [
                      "%{GREEDYDATA:cef_msg}\]\s%{GREEDYDATA:end_msg}"
                   ]
                 }
               }
            }
        }
#......................................................................#
#First, replace whitespaces with default string after = to avoid kv issues, example:
#gattServices= manufacturerName=MFN, generates -> gattServices="manufacturerName=MFN"
#and should generate two fields: gattServices and manufacturerName
    if [cef_msg] {
      mutate {
        gsub => [
          "cef_msg", "(\w+)= ", "\1=X0X "
        ]
      }
#......................................................................#
#Using the kv filter with default config, usefull in key-value logs

      kv {
        source => "cef_msg"
        allow_duplicate_values => false
        target => "kv_field"
      }
    }
#......................................................................#
#Remove fields that have issues with kv filter (spaces or = in value)
   mutate {
      remove_field => ["[kv_field][rt]","[kv_field][destinationZoneURI]","[kv_field][msg]","[kv_field][customerURI]","[kv_field][destinationZoneExternalID]",
      "[kv_field][cs1]","[kv_field][cs2]","[kv_field][cs3]","[kv_field][cs4]","[kv_field][cs5]","[kv_field][cs6]","[kv_field][originalAgentZoneURI]","[kv_field][flexString1]","[kv_field][cat]",
      "[kv_field][cs1Label]","[kv_field][cs2Label]","[kv_field][cs3Label]","[kv_field][cs4Label]","[kv_field][cs5Label]","[kv_field][cs6Label]",
      "[kv_field][cn1]","[kv_field][cn2]","[kv_field][cn3]","[kv_field][cn4]","[kv_field][cn5]","[kv_field][cn6]","[kv_field][cn1Label]","[kv_field][cn2Label]","[kv_field][cn3Label]","[kv_field][cn4Label]","[kv_field][cn5Label]","[kv_field][cn6Label]",
      "[kv_field][suser]","[kv_field][ruleName]","[kv_field][duser]","[kv_field][accountName]","[kv_field][eventDesc]","[kv_field][endpointDeviceControlDeviceName]",
      "[kv_field][sourceAgentLastActivityTimestamp]","[kv_field][sourceAgentRegisterTimestamp]","[kv_field][manufacturerName]",
      "[kv_field][sourceUserName]","[kv_field][sourceGroupName]","[kv_field][siteName]",
      "[kv_field][deviceRuleType]"]
   }
#......................................................................#
#Using grok to parse kv issued fields
    if [cef_msg] {
          grok {
            match => {
              "cef_msg" => [
                 "rt=%{DATA:rt} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "destinationZoneURI=%{DATA:destinationZoneURI} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "msg=%{DATA:msg} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "customerURI=%{DATA:customerURI} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "destinationZoneExternalID=%{DATA:destinationZoneExternalID} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cs1=%{DATA:cs1} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cs2=%{DATA:cs2} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cs3=%{DATA:cs3} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cs4=%{DATA:cs4} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cs5=%{DATA:cs5} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cs6=%{DATA:cs6} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cn1=%{DATA:cn1} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cn2=%{DATA:cn2} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cn3=%{DATA:cn3} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cn4=%{DATA:cn4} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cn5=%{DATA:cn5} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cn6=%{DATA:cn6} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "originalAgentZoneURI=%{DATA:originalAgentZoneURI} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "flexString1=%{DATA:flexString1} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cat=%{DATA:cat} %{WORD}(\.%{WORD})?=","cat=%{GREEDYDATA:cat}"
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cs1Label=%{DATA:cs1Label} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cs2Label=%{DATA:cs2Label} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cs3Label=%{DATA:cs3Label} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cs4Label=%{DATA:cs4Label} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cs5Label=%{DATA:cs5Label} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cs6Label=%{DATA:cs6Label} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cn1Label=%{DATA:cn1Label} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cn2Label=%{DATA:cn2Label} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cn3Label=%{DATA:cn3Label} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cn4Label=%{DATA:cn4Label} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cn5Label=%{DATA:cn5Label} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "cn6Label=%{DATA:cn6Label} %{WORD}(\.%{WORD})?="
              ]
            }
          }
# New fields from real logs, version 1.0.2
# suser and duser are not new but now detected with spaces
          grok {
            match => {
              "cef_msg" => [
                 "suser=%{DATA:suser} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "duser=%{DATA:duser} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "ruleName=%{DATA:ruleName} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "eventDesc=%{DATA:eventDesc} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "accountName=%{DATA:accountName} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "endpointDeviceControlDeviceName=%{DATA:endpointDeviceControlDeviceName} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "sourceAgentLastActivityTimestamp=%{DATA:sourceAgentLastActivityTimestamp} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "sourceAgentRegisterTimestamp=%{DATA:sourceAgentRegisterTimestamp} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "manufacturerName=%{DATA:manufacturerName} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "sourceUserName=%{DATA:sourceUserName} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "sourceGroupName=%{DATA:sourceGroupName} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "siteName=%{DATA:siteName} %{WORD}(\.%{WORD})?="
              ]
            }
          }

          grok {
            match => {
              "cef_msg" => [
                 "deviceRuleType=%{DATA:deviceRuleType} %{WORD}(\.%{WORD})?="
              ]
            }
          }
    }
#......................................................................#
#Add fields to the tree structure
#......................................................................#
        mutate {
          #Rename the filds out of kv results
          rename => { "[signatureID]" => "[kv_field][signatureID]" }
          rename => { "[embDeviceVendor]" => "[kv_field][embDeviceVendor]" }
          rename => { "[embDeviceProduct]" => "[kv_field][embDeviceProduct]" }
          rename => { "[act_msg]" => "[kv_field][act_msg]" }
          rename => { "[cef_version]" => "[kv_field][cef_version]" }
          rename => { "[deviceVersion]" => "[kv_field][deviceVersion]" }
          rename => { "[priority]" => "[kv_field][priority]" }
          rename => { "[severity]" => "[kv_field][severity]" }
          rename => { "[end_msg]" => "[kv_field][end_msg]" }

          #Rename fields with kv issues (individual groks)
          rename => { "[cs1]" => "[kv_field][cs1]" }
          rename => { "[cs2]" => "[kv_field][cs2]" }
          rename => { "[cs3]" => "[kv_field][cs3]" }
          rename => { "[cs4]" => "[kv_field][cs4]" }
          rename => { "[cs5]" => "[kv_field][cs5]" }
          rename => { "[cs6]" => "[kv_field][cs6]" }
          rename => { "[cs1Label]" => "[kv_field][cs1Label]" }
          rename => { "[cs2Label]" => "[kv_field][cs2Label]" }
          rename => { "[cs3Label]" => "[kv_field][cs3Label]" }
          rename => { "[cs4Label]" => "[kv_field][cs4Label]" }
          rename => { "[cs5Label]" => "[kv_field][cs5Label]" }
          rename => { "[cs6Label]" => "[kv_field][cs6Label]" }
          rename => { "[cn1]" => "[kv_field][cn1]" }
          rename => { "[cn2]" => "[kv_field][cn2]" }
          rename => { "[cn3]" => "[kv_field][cn3]" }
          rename => { "[cn4]" => "[kv_field][cn4]" }
          rename => { "[cn5]" => "[kv_field][cn5]" }
          rename => { "[cn6]" => "[kv_field][cn6]" }
          rename => { "[cn1Label]" => "[kv_field][cn1Label]" }
          rename => { "[cn2Label]" => "[kv_field][cn2Label]" }
          rename => { "[cn3Label]" => "[kv_field][cn3Label]" }
          rename => { "[cn4Label]" => "[kv_field][cn4Label]" }
          rename => { "[cn5Label]" => "[kv_field][cn5Label]" }
          rename => { "[cn6Label]" => "[kv_field][cn6Label]" }
          rename => { "[msg]" => "[kv_field][msg]" }
          rename => { "[customerURI]" => "[kv_field][customerURI]" }
          rename => { "[cat]" => "[kv_field][cat]" }
          rename => { "[rt]" => "[kv_field][rt]" }
          rename => { "[destinationZoneURI]" => "[kv_field][destinationZoneURI]" }
          rename => { "[destinationZoneExternalID]" => "[kv_field][destinationZoneExternalID]" }
          rename => { "[message]" => "[kv_field][message]" }
          rename => { "[duser]" => "[kv_field][duser]" }
          rename => { "[suser]" => "[kv_field][suser]" }
          rename => { "[originalAgentZoneURI]" => "[kv_field][originalAgentZoneURI]" }
          rename => { "[flexString1]" => "[kv_field][flexString1]" }
          rename => { "[ruleName]" => "[kv_field][ruleName]" }
          rename => { "[accountName]" => "[kv_field][accountName]" }
          rename => { "[eventDesc]" => "[kv_field][eventDesc]" }
          rename => { "[endpointDeviceControlDeviceName]" => "[kv_field][endpointDeviceControlDeviceName]" }
          rename => { "[sourceAgentLastActivityTimestamp]" => "[kv_field][sourceAgentLastActivityTimestamp]" }
          rename => { "[sourceAgentRegisterTimestamp]" => "[kv_field][sourceAgentRegisterTimestamp]" }
          rename => { "[manufacturerName]" => "[kv_field][manufacturerName]" }
          rename => { "[sourceUserName]" => "[kv_field][sourceUserName]" }
          rename => { "[sourceGroupName]" => "[kv_field][sourceGroupName]" }
          rename => { "[siteName]" => "[kv_field][siteName]" }
          rename => { "[deviceRuleType]" => "[kv_field][deviceRuleType]" }
        }

    #src can be in multiple fields
    if [kv_field][src] {
        mutate {
          rename => { "[kv_field][src]" => "[kv_field][src_ip]" }
        }
    } else if [kv_field][cs4Label] and ("clientIp" in [kv_field][cs4Label]) {
        mutate {
          rename => { "[kv_field][cs4]" => "[kv_field][src_ip]" }
        }
    } else if [kv_field][FromIPAddress] {
        mutate {
          rename => { "[kv_field][FromIPAddress]" => "[kv_field][src_ip]" }
        }
    }
#......................................................................#
#Set null the fields with de X0X value (default string for null), and replace simple and double quotation
#also generate logx tree structure dynamically
          if [kv_field] {
            ruby {
                code => ''
                    event.get("[kv_field]").each do |k, v|
                          if (v == "X0X")
                            event.set("[logx][sentinel_one][#{k}]",nil)
                          elsif (k=~/^sourceIpAddresses\.((\d)+)$/)
                              event.set("[logx][sentinel_one][source_ip_base_list][#{k}]",v)
                              event.remove(k)
                          elsif (k=~/^sourceMacAddresses\.((\d)+)$/)
                              event.set("[logx][sentinel_one][source_mac_base_list][#{k}]",v)
                              event.remove(k)
                          elsif (k=~/^threatIndicatorsList\.((\d)+)$/)
                              event.set("[logx][sentinel_one][threat_ind_base_list][#{k}]",v)
                              event.remove(k)
                          elsif !(v.kind_of?(Array))
                              new_v = v.to_s.gsub(/\"/, "")
                              new_v = new_v.gsub(/\''/, "")
                              event.set("[logx][sentinel_one][#{k}]",new_v)
                          else
                              event.set("[logx][sentinel_one][#{k}]",v)
                          end
                       end
                    ''
            }
          }
#......................................................................#
#Implement fields represented by a list of fields
#All source ip address in a string separated by comma
          if [source_ip_base_list] {
            ruby {
                code => ''
                          field_verify=event.get("[logx][sentinel_one][source_ip_base_list]")
                          if field_verify
                            new_v=field_verify.to_hash.map{|k,v| "#{v}"}.join(", ")
                            event.set("[logx][sentinel_one][src_ip_list]",new_v)
                          end
                    ''
            }
          }
#All source mac address in a string separated by comma
          if [source_mac_base_list] {
            ruby {
                code => ''
                          field_verify=event.get("[logx][sentinel_one][source_mac_base_list]")
                          if field_verify
                            new_v=field_verify.to_hash.map{|k,v| "#{v}"}.join(", ")
                            event.set("[logx][sentinel_one][src_mac_list]",new_v)
                          end
                    ''
            }
          }
#All threat indicators in a string separated by comma
          if [threat_ind_base_list] {
            ruby {
                code => ''
                          field_verify=event.get("[logx][sentinel_one][threat_ind_base_list]")
                          if field_verify
                            new_v=field_verify.to_hash.map{|k,v| "#{v}"}.join(", ")
                            event.set("[logx][sentinel_one][threat_indicators_list]",new_v)
                          end
                    ''
            }
          }
#......................................................................#
#Renaming CEF formatted fields with multiple values inside, to match name of (multiple fields in one) in not CEF logs
   mutate {
          rename => { "[logx][sentinel_one][sourceMacAddresses]" => "[logx][sentinel_one][src_mac_list]" }
          rename => { "[logx][sentinel_one][threatIndicatorsList]" => "[logx][sentinel_one][threat_indicators_list]" }
          rename => { "[logx][sentinel_one][sourceIpAddresses]" => "[logx][sentinel_one][src_ip_list]" }
   }
#......................................................................#
   #Finally, remove unnecessary fields
   mutate {
      remove_field => ["@version","path","tags","type","syslog_version","kv_field",
      "not_defined","cef_msg_all","cef_msg","syslog_date_host","irrelevant","init_msg",
      "[logx][sentinel_one][threat_ind_base_list]","[logx][sentinel_one][source_mac_base_list]",
      "[logx][sentinel_one][source_ip_base_list]"]
   }
  }
 }
   #Also, remove unwanted fields if the message not match with conditions
   mutate {
      remove_field => ["original_log_message","headers"]
   }
}
'
WHERE id=1503;
----------------------------------------------------------------------------------------------------------------------------------------
-- CISCO ASA  --
----------------------------------------------------------------------------------------------------------------------------------------
UPDATE utm_logstash_filter
SET filter_version='2.0.1',logstash_filter='filter {

   split {
      field => "message"
      terminator => "<utm-log-separator>"
   }

     #Looking for datasource generated by an agent and parse original message
   if [message]=~/\[utm_stack_agent_ds=(.+)\]-(.+)/ {
    grok {
      match => {
        "message" => [ "\[utm_stack_agent_ds=%{DATA:dataSource}\]-%{GREEDYDATA:original_log_message}" ]
      }
    }
   }
   if [original_log_message] {
    mutate {
      update => { "message" => "%{[original_log_message]}" }
    }
   }

   if [message] and "%ASA-" in [message] {
#......................................................................#
#Filter version 2.0.1
# Cisco ASA based on examples provided and https://www.cisco.com/c/en/us/td/docs/security/asa/syslog/b_syslog.html (january 2022)
#Using grok to parse priority if present
    grok {
 			match => {
 				"message" => [
				"(<%{NUMBER:priority}>)?%{GREEDYDATA:cisco_msg_init}"
 				]
 			}
 		}
#......................................................................#
#Using grok to parse date and ip or host if present
	if [cisco_msg_init]{
      grok {
         match => {
          "cisco_msg_init" => [ "%{CISCOTIMESTAMP:fecha} (%{IPORHOST:ciscoDataSource})?(:)? %{GREEDYDATA:cisco_message}" ]
         }
      }
	}
#......................................................................#
#Generating dataSource field required by CurrelationRulesEngine
#Checks if ciscoDataSource exists, if true, the dataSource field take its value, if not, take the agent dataSource value
 if ([ciscoDataSource]){
        if [dataSource] {
          mutate {
            update => { "dataSource" => "%{[ciscoDataSource]}" }
          }
        } else {
          mutate {
            add_field => { "dataSource" => "%{ciscoDataSource}" }
          }
        }
 }
#Finally evaluates to the host variable if can not be calculated
 if ![dataSource] {
    mutate {
       add_field => { "dataSource" => "%{host}" }
     }
 }

#......................................................................#
#Generating dataType field required by CurrelationRulesEngine
   mutate {
		  add_field => {
			"dataType" => "firewall-cisco-asa"
		  }
	   }
#......................................................................#
#Using grok to parse ASA severity and message ID
	if [cisco_message]{
        grok {
 			match => {
 				"cisco_message" => [
				"%%{GREEDYDATA:cisco_tag}-%{INT:severity}-%{INT:messageid}: %{GREEDYDATA:cisco_msg}"
 				]
 			}
 		}
	}
#......................................................................#
#Begin ASA message processing by ID based on https://www.cisco.com/c/en/us/td/docs/security/asa/syslog/b_syslog.html
if [messageid] and [cisco_msg]{
	#......................................................................#
	#ASA-2-106001
	if [messageid]=="106001" {
			grok {
				match => {
					"cisco_msg" => [
					"%{WORD:direction} %{WORD:protocol} connection %{WORD:cisco_action} from %{IP:src_ip}/%{INT:src_port} to %{IP:dst_ip}/%{INT:dst_port} flags %{GREEDYDATA:tcp_flags} on interface %{GREEDYDATA:src_interface}"
					]
				}
			}
	}
	#......................................................................#
	#ASA-2-106017
	if [messageid]=="106017" {
			grok {
				match => {
					"cisco_msg" => [
					"%{WORD:cisco_action} IP due to %{GREEDYDATA:event_description} from %{GREEDYDATA:src_ip} to %{IPORHOST:dst_ip}"
					]
				}
			}
	}
	#......................................................................#
	#ASA-1-106021
	if [messageid]=="106021" {
			grok {
				match => {
					"cisco_msg" => [
					"%{WORD:cisco_action} protocol reverse path check from %{GREEDYDATA:src_ip} to %{GREEDYDATA:dst_ip} on interface %{GREEDYDATA:dst_interface}"
					]
				}
			}
	}
	#......................................................................#
	#ASA-2-106101
	if [messageid]=="106101" {
			grok {
				match => {
					"cisco_msg" => [
					"Number of cached %{GREEDYDATA:cisco_action} for ACL log has reached limit(\s)?\(%{INT:num_flows}(\s)?\)%{GREEDYDATA:irrelevant}?"
					]
				}
			}
	}
	#......................................................................#
	#ASA-6-106102,106103
	if [messageid]=="106102" or [messageid]=="106103"{
			grok {
				match => {
					"cisco_msg" => [
					"access-list %{GREEDYDATA:access_list} %{WORD:cisco_action} %{WORD:protocol} for user (''%{DATA:src_fwuser}''|%{DATA:src_fwuser}) %{DATA:src_interface}/%{IPORHOST:src_ip}(\s)?\((\s)?%{INT:src_port}(\s)?\)(\s)?->(\s)?%{DATA:dst_interface}/%{IPORHOST:dst_ip}(\s)?\((\s)?%{INT:dst_port}(\s)?\) hit-cnt %{INT:hit_count} %{GREEDYDATA:irrelevant}",
					"access-list %{GREEDYDATA:access_list} %{WORD:cisco_action} %{WORD:protocol} for user (''%{DATA:src_fwuser}''|%{DATA:src_fwuser}) %{DATA:src_interface}/%{IPORHOST:src_ip} %{INT:src_port} %{DATA:dst_interface}/%{IPORHOST:dst_ip} %{INT:dst_port} hit-cnt %{INT:hit_count} %{GREEDYDATA:irrelevant}"
					]
				}
			}
			if [cisco_action]{
				if [cisco_action] =~/(Permitted|permitted)/ {
					mutate {
						add_field => { "[logx][utm][action]" => "Success" }
					}
				}
			}
	}
	#......................................................................#
	#ASA-4-109017
	if [messageid]=="109017"{
			grok {
				match => {
					"cisco_msg" => [
					"User at %{GREEDYDATA:src_ip} exceeded auth proxy connection limit(\s)?\(%{GREEDYDATA:limit}(\s)?\)%{GREEDYDATA:irrelevant}?"
					]
				}
			}
	}
	#......................................................................#
	#ASA-109101,109102,109103
	if [messageid]=="109101" or [messageid]=="109102" or [messageid]=="109103"{
			grok {
				match => {
					"cisco_msg" => [
					"Received CoA %{WORD:cisco_action} request from %{IPORHOST:src_ip} for user (''%{DATA:src_fwuser}''|%{DATA:src_fwuser}), with audit-session-id: %{GREEDYDATA:audit_session_id}",
					"Received CoA %{WORD:cisco_action} from %{IPORHOST:src_ip}, but cannot find named session %{GREEDYDATA:audit_session_id}",
					"CoA %{WORD:cisco_action} from %{IPORHOST:src_ip} failed for user (''%{DATA:src_fwuser}''|%{DATA:src_fwuser}), with session ID: %{GREEDYDATA:audit_session_id}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#ASA-109201 to 109213
	if [messageid]>="109201" and [messageid]<="109213"{
			grok {
				match => {
					"cisco_msg" => [
					"UAUTH(:)? Session(\s|=)%{GREEDYDATA:session}, User(\s|=)(''%{DATA:src_fwuser}''|%{DATA:src_fwuser}), Assigned IP(\s|=)%{IPORHOST:src_ip}, %{GREEDYDATA:cisco_action}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#ASA-113004
	if [messageid]=="113004"{
			grok {
				match => {
					"cisco_msg" => [
					"AAA user %{WORD:aaa_type} Successful : server = %{GREEDYDATA:src_ip} : user = %{GREEDYDATA:src_fwuser}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#ASA-113005
	if [messageid]=="113005"{
			grok {
				match => {
					"cisco_msg" => [
					"AAA user authentication Rejected(\s)?:(\s)?reason(\s)?=(\s)?%{DATA:reason}(\s)?:(\s)?(server|Server)(\s)?=(\s)?%{IPORHOST:dst_ip}(\s)?:(\s)?(User|user)(\s)?=(\s)?%{DATA:src_fwuser}(\s)?:(\s)?(User|user) IP(\s)?=(\s)?%{IPORHOST:src_ip}"
					]
				}
			}
	}
	#......................................................................#
	#ASA-113008
	if [messageid]=="113008"{
			grok {
				match => {
					"cisco_msg" => [
					"AAA transaction status ACCEPT(\s)?:(\s)?(user|User)(\s)?=(\s)?%{GREEDYDATA:src_fwuser}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#ASA-113009
	if [messageid]=="113009"{
			grok {
				match => {
					"cisco_msg" => [
					"AAA retrieved default group policy \(%{GREEDYDATA:policy}\) for (user|User)(\s)?=(\s)?%{GREEDYDATA:src_fwuser}",
					"AAA retrieved default group policy %{GREEDYDATA:policy} for (user|User) %{GREEDYDATA:src_fwuser}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#ASA-113010
	if [messageid]=="113010"{
			grok {
				match => {
					"cisco_msg" => [
					"AAA challenge received for user (''%{DATA:src_fwuser}''|%{DATA:src_fwuser}) from server %{IPORHOST:src_ip}"
					]
				}
			}
	}
	#......................................................................#
	#ASA-113011
	if [messageid]=="113011"{
			grok {
				match => {
					"cisco_msg" => [
					"AAA retrieved user specific group policy %{GREEDYDATA:policy} for user %{GREEDYDATA:src_fwuser}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#ASA-113012
	if [messageid]=="113012"{
			grok {
				match => {
					"cisco_msg" => [
					"AAA user authentication Successful(\s)?: local database(\s)?: user(\s)?=(\s)?%{GREEDYDATA:src_fwuser}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#ASA-113013
	if [messageid]=="113013"{
			grok {
				match => {
					"cisco_msg" => [
					"AAA unable to complete the request Error(\s)?:(\s)?reason(\s)?=(\s)?%{GREEDYDATA:reason}:(\s)?user(\s)?=(\s)?%{GREEDYDATA:src_fwuser}"
					]
				}
			}
	}
	#......................................................................#
	#ASA-113014
	if [messageid]=="113014"{
			grok {
				match => {
					"cisco_msg" => [
					"AAA authentication server not accessible(\s)?: server(\s)?=(\s)?%{IPORHOST:src_ip}(\s)?:(\s)?user(\s)?=(\s)?%{GREEDYDATA:src_fwuser}"
					]
				}
			}
	}
	#......................................................................#
	#ASA-113015, 113017
	if [messageid]=="113015" or [messageid]=="113017"{
			grok {
				match => {
					"cisco_msg" => [
					"(AAA user authentication Rejected|AAA credentials rejected)(\s)?: reason(\s)?=(\s)?%{DATA:reason}(\s)?:(\s)?local database(\s)?:(\s)?user(\s)?=(\s)?(''%{DATA:src_fwuser}''|%{DATA:src_fwuser})(\s)?:(\s)?user IP(\s)?=(\s)?%{IPORHOST:src_ip}(%{GREEDYDATA:irrelevant})?"
					]
				}
			}
	}
	#......................................................................#
	#ASA-113016
	if [messageid]=="113016"{
			grok {
				match => {
					"cisco_msg" => [
					"AAA credentials rejected(\s)?: reason(\s)?=(\s)?%{GREEDYDATA:reason}:(\s)?server(\s)?=(\s)?%{IPORHOST:dst_ip}(\s)?:(\s)?user(\s)?=(\s)?(''%{DATA:src_fwuser}''|%{DATA:src_fwuser})(\s)?:(\s)?user IP(\s)?=(\s)?%{IPORHOST:src_ip}"
					]
				}
			}
	}
	#......................................................................#
	#ASA-113019
	if [messageid]=="113019"{
			grok {
				match => {
					"cisco_msg" => [
					"Group(\s)?=(\s)?%{GREEDYDATA:group}(\s)?,(\s)?Username(\s)?=(\s)?(''%{DATA:src_fwuser}''|%{DATA:src_fwuser})(\s)?,(\s)?IP(\s)?=(\s)?%{IPORHOST:src_ip}(\s)?,(\s)?Session disconnected.(\s)?Session Type:(\s)?%{GREEDYDATA:session_type}(\s)?,(\s)?Duration:(\s)?%{GREEDYDATA:duration}(\s)?,(\s)?Bytes xmt:(\s)?%{INT:bytes_xmt}(\s)?,(\s)?Bytes rcv:(\s)?%{INT:bytes_rcv}(\s)?,(\s)?Reason:(\s)?%{GREEDYDATA:reason}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#ASA-113031,113032,113033
	if [messageid]=="113031" or [messageid]=="113032" or [messageid]=="113033"{
			grok {
				match => {
					"cisco_msg" => [
					"Group %{GREEDYDATA:group} User (''%{DATA:src_fwuser}''|%{DATA:src_fwuser}) IP %{IPORHOST:src_ip} AnyConnect (vpn-filter|ipv6-vpn-filter) %{GREEDYDATA:filter} is an (IPv6|IPv4) ACL; ACL not applied.",
					"Group %{GREEDYDATA:group} User (''%{DATA:src_fwuser}''|%{DATA:src_fwuser}) IP %{IPORHOST:src_ip} AnyConnect session not allowed.(\s)?ACL parse error."
					]
				}
			}
	}
	#......................................................................#
	#ASA-113034,113035,113036,113038,113039
	if [messageid]>="113034" and [messageid]<="113039" and [messageid]!="113037"{
			grok {
				match => {
					"cisco_msg" => [
					"Group (<%{DATA:group}>|%{GREEDYDATA:group}) User (<%{DATA:src_fwuser}>|''%{DATA:src_fwuser}''|%{DATA:src_fwuser}) IP (<%{IPORHOST:src_ip}>|%{IPORHOST:src_ip}) %{GREEDYDATA:irrelevant}"
					]
				}
			}
			if [messageid] != "113036" {
				mutate {
					add_field => { "[logx][utm][action]" => "Success" }
				}
			}
	}
	#......................................................................#
	#ASA-113042
	if [messageid]=="113042"{
			grok {
				match => {
					"cisco_msg" => [
					"CoA: Non-HTTP connection from %{GREEDYDATA:src_interface}(\s)?:(\s)?%{IPORHOST:src_ip}(\s)?/(\s)?%{INT:src_port} to %{GREEDYDATA:dst_interface}(\s)?:(\s)?%{IPORHOST:dst_ip}(\s)?/%{INT:dst_port} for user (''%{DATA:src_fwuser}''|%{DATA:src_fwuser}) at %{IPORHOST:client_ip} %{GREEDYDATA:irrelevant}"
					]
				}
			}
	}
	#......................................................................#
	#ASA-201003
	if [messageid]=="201003"{
			grok {
				match => {
					"cisco_msg" => [
					"Embryonic limit exceeded %{INT:num_conns}(\s)?/%{INT:limit} for %{IPORHOST:src_ip}(\s)?/%{INT:src_port} \(%{IPORHOST:global_ip}(\s)?\) %{IPORHOST:dst_ip}(\s)?/%{INT:dst_port} on interface %{GREEDYDATA:dst_interface}"
					]
				}
			}
	}
	#......................................................................#
	#ASA-209003
	if [messageid]=="209003"{
			grok {
				match => {
					"cisco_msg" => [
					"Fragment database limit of %{INT:limit} exceeded:(\s)?src(\s)?=(\s)?%{DATA:src_ip}(\s)?,(\s)?dest(\s)?=(\s)?%{DATA:dst_ip}(\s)?,(\s)?proto(\s)?=(\s)?%{DATA:protocol}(\s)?,(\s)?id(\s)?=(\s)?%{GREEDYDATA:id}"
					]
				}
			}
	}
	#......................................................................#
	#ASA-316001
	if [messageid]=="316001"{
			grok {
				match => {
					"cisco_msg" => [
					"Denied new tunnel to %{IPORHOST:src_ip}%{GREEDYDATA:irrelevant}"
					]
				}
			}
	}
	#......................................................................#
	#ASA-316002
	if [messageid]=="316002"{
			grok {
				match => {
					"cisco_msg" => [
					"VPN Handle error:(\s)?protocol=%{GREEDYDATA:protocol}(\s)?,(\s)?src %{INT:in_if_num}(\s)?:(\s)?%{IPORHOST:src_ip},(\s)?dst %{INT:out_if_num}(\s)?:(\s)?%{IPORHOST:dst_ip}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#ASA-302003,302004
	if [messageid]=="302003" or [messageid]=="302004" {
			grok {
				match => {
					"cisco_msg" => [
					"(Built H245 connection|Pre-allocate H323 UDP backconnection) for foreign_address %{IPORHOST:src_ip}(/%{INT:src_port}|/)? (to(\s))?local_address %{IPORHOST:dst_ip}(/%{INT:dst_port}|/)?"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#ASA-302012
	if [messageid]=="302012"{
			grok {
				match => {
					"cisco_msg" => [
					"Pre-allocate H225 Call Signalling Connection for faddr %{GREEDYDATA:src_ip}/%{INT:src_port} to laddr %{GREEDYDATA:dst_ip}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#ASA-302013
	if [messageid]=="302013"{
			grok {
				match => {
					"cisco_msg" => [
					"Built %{WORD:direction} (Probe)?(\s)?%{WORD:protocol} %{GREEDYDATA:connection_id} for %{GREEDYDATA:src_interface}:(\s)?%{IPORHOST:src_ip}(\s)?/(\s)?%{INT:src_port}(\s)?\(%{IPORHOST:mapped_src_ip}(\s)?/(\s)?%{INT:mapped_src_port}(\s)?\)(\s)?(\((''%{DATA:src_fwuser}''|%{DATA:src_fwuser})(\s)?\))?(\s)?to %{GREEDYDATA:dst_interface}:(\s)?%{IPORHOST:dst_ip}(\s)?/(\s)?%{INT:dst_port}(\s)?\((\s)?%{IPORHOST:mapped_dst_ip}(\s)?/(\s)?%{INT:mapped_dst_port}(\s)?\)(\s)?(\((''%{DATA:dst_fwuser}''|%{DATA:dst_fwuser})(\s)?\))?(%{GREEDYDATA:irrelevant})?"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#ASA-302014
	if [messageid]=="302014"{
			grok {
				match => {
					"cisco_msg" => [
					"Teardown (Probe)?(\s)?%{WORD:protocol} connection %{GREEDYDATA:connection_id} for %{GREEDYDATA:src_interface}:(\s)?%{IPORHOST:src_ip}(\s)?/(\s)?%{INT:src_port} (\((\s)?(''%{DATA:src_fwuser}''|%{DATA:src_fwuser})(\s)?\))?(\s)?to %{GREEDYDATA:dst_interface}:(\s)?%{IPORHOST:dst_ip}(\s)?/(\s)?%{INT:dst_port} (\((\s)?(''%{DATA:dst_fwuser}''|%{DATA:dst_fwuser})(\s)?\))?(\s)?duration %{GREEDYDATA:duration} bytes %{INT:bytes_xmt}(%{GREEDYDATA:irrelevant})?"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#ASA-302015
	if [messageid]=="302015"{
			grok {
				match => {
					"cisco_msg" => [
					"Built %{WORD:direction} %{WORD:protocol} connection %{GREEDYDATA:connection_id} for %{GREEDYDATA:src_interface}:(\s)?%{IPORHOST:src_ip}(\s)?/(\s)?%{INT:src_port}(\s)?\(%{IPORHOST:mapped_src_ip}(\s)?/(\s)?%{INT:mapped_src_port}(\s)?\)(\s)?(\((\s)?(''%{DATA:src_fwuser}''|%{DATA:src_fwuser})(\s)?\))?(\s)?to %{GREEDYDATA:dst_interface}:(\s)?%{IPORHOST:dst_ip}(\s)?/(\s)?%{INT:dst_port}(\s)?\((\s)?%{IPORHOST:mapped_dst_ip}(\s)?/(\s)?%{INT:mapped_dst_port}(\s)?\)(\s)?(\((\s)?(''%{DATA:dst_fwuser}''|%{DATA:dst_fwuser})(\s)?\))?(%{GREEDYDATA:irrelevant})?"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#ASA-302016
	if [messageid]=="302016"{
			grok {
				match => {
					"cisco_msg" => [
					"Teardown %{WORD:protocol} connection %{GREEDYDATA:connection_id} for %{GREEDYDATA:src_interface}:(\s)?%{IPORHOST:src_ip}(\s)?/(\s)?%{INT:src_port}(\s)?(\((\s)?(''%{DATA:src_fwuser}''|%{DATA:src_fwuser})(\s)?\))? to %{GREEDYDATA:dst_interface}:(\s)?%{IPORHOST:dst_ip}(\s)?/(\s)?%{INT:dst_port}(\s)?(\((\s)?(''%{DATA:dst_fwuser}''|%{DATA:dst_fwuser})(\s)?\))? duration %{GREEDYDATA:duration} bytes %{INT:bytes_xmt}(%{GREEDYDATA:irrelevant})?"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#ASA-302017
	if [messageid]=="302017"{
			grok {
				match => {
					"cisco_msg" => [
					"Built %{WORD:direction} %{WORD:protocol} connection %{GREEDYDATA:connection_id} from %{GREEDYDATA:src_interface}:(\s)?%{IPORHOST:src_ip} \((\s)?%{IPORHOST:translated_src_ip}(\s)?\)(\s)?(\((\s)?(''%{DATA:src_fwuser}''|%{DATA:src_fwuser})(\s)?\))? to %{GREEDYDATA:dst_interface}:(\s)?%{IPORHOST:dst_ip}(\s)?/%{DATA:real_cid} \(%{IPORHOST:translated_dst_ip}(\s)?/%{DATA:translated_cid}\)(\s)?(\((\s)?(''%{DATA:dst_fwuser}''|%{DATA:dst_fwuser})(\s)?\))?(%{GREEDYDATA:irrelevant})?"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#ASA-302018
	if [messageid]=="302018"{
			grok {
				match => {
					"cisco_msg" => [
					"Teardown %{WORD:protocol} connection %{GREEDYDATA:connection_id} from %{GREEDYDATA:src_interface}:(\s)?%{IPORHOST:src_ip} \((\s)?%{IPORHOST:translated_src_ip}(\s)?\)(\s)?(\((\s)?(''%{DATA:src_fwuser}''|%{DATA:src_fwuser})(\s)?\))? to %{GREEDYDATA:dst_interface}:(\s)?%{IPORHOST:dst_ip}(\s)?/%{DATA:real_cid} \(%{IPORHOST:translated_dst_ip}(\s)?/%{DATA:translated_cid}\)(\s)?(\((\s)?(''%{DATA:dst_fwuser}''|%{DATA:dst_fwuser})(\s)?\))? duration %{GREEDYDATA:duration} bytes %{INT:bytes_xmt}(%{GREEDYDATA:irrelevant})?"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#ASA-302020
	if [messageid]=="302020"{
			grok {
				match => {
					"cisco_msg" => [
					"Built %{WORD:direction} %{WORD:protocol} connection for faddr (%{IPORHOST:dst_ip}|%{INT:dst_ip})/%{INT:dst_port}(\s)?(\((\s)?(''%{DATA:src_fwuser}''|%{DATA:src_fwuser})(\s)?\))?(\s)?gaddr %{GREEDYDATA:global_ip}/%{INT:global_port} laddr %{IPORHOST:src_ip}/%{INT:src_port}(\s)?(\((\s)?(''%{DATA:dst_fwuser}''|%{DATA:dst_fwuser})(\s)?\))? type %{INT:icmp_type} code %{INT:code}",
					"Built %{WORD:direction} %{WORD:protocol} connection for faddr (%{IPORHOST:dst_ip}|%{INT:dst_ip}) (\((\s)?(''%{DATA:src_fwuser}''|%{DATA:src_fwuser})(\s)?\))?(\s)?gaddr %{GREEDYDATA:global_ip} laddr %{IPORHOST:src_ip} (\((\s)?(''%{DATA:dst_fwuser}''|%{DATA:dst_fwuser})(\s)?\))?(\s)?type %{INT:icmp_type} code %{INT:code}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#ASA-302021
	if [messageid]=="302021"{
			grok {
				match => {
					"cisco_msg" => [
					"Teardown %{WORD:protocol} connection for faddr (%{IPORHOST:dst_ip}|%{INT:dst_ip})/%{INT:dst_port}(\s)?(\((\s)?(''%{DATA:src_fwuser}''|%{DATA:src_fwuser})(\s)?\))? gaddr %{GREEDYDATA:global_ip}/%{INT:global_port} laddr %{IPORHOST:src_ip}/%{INT:src_port}(\s)?(\((\s)?(''%{DATA:dst_fwuser}''|%{DATA:dst_fwuser})(\s)?\))? type %{INT:icmp_type} code %{INT:code}",
					"Teardown %{WORD:protocol} connection for faddr (%{IPORHOST:dst_ip}|%{INT:dst_ip})(\s)?(\((\s)?(''%{DATA:src_fwuser}''|%{DATA:src_fwuser})(\s)?\))? gaddr %{GREEDYDATA:global_ip} laddr %{IPORHOST:src_ip} (\((\s)?(''%{DATA:dst_fwuser}''|%{DATA:dst_fwuser})(\s)?\))?(\s)?type %{INT:icmp_type} code %{INT:code}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#ASA-302022,302024,302026
	if [messageid]=="302022" or [messageid]=="302024" or [messageid]=="302026" {
			grok {
				match => {
					"cisco_msg" => [
					"Built %{GREEDYDATA:role} stub %{WORD:protocol} connection for %{GREEDYDATA:src_interface}:(\s)?%{IPORHOST:src_ip}(\s)?/(\s)?%{INT:src_port}(\s)?\((\s)?%{IPORHOST:mapped_src_ip}(\s)?/(\s)?%{INT:mapped_src_port}(\s)?\) to %{GREEDYDATA:dst_interface}:(\s)?%{IPORHOST:dst_ip}(\s)?/(\s)?%{INT:dst_port}(\s)?\((\s)?%{IPORHOST:mapped_dst_ip}(\s)?/(\s)?%{INT:mapped_dst_port}(\s)?\)(%{GREEDYDATA:irrelevant})?",
					"Built %{GREEDYDATA:role} stub %{WORD:protocol} connection for %{GREEDYDATA:src_interface}:(\s)?%{IPORHOST:src_ip}(\s)?/(\s)?%{INT:src_port}(\s)?\((\s)?%{IPORHOST:mapped_src_ip}(\s)?\) to %{GREEDYDATA:dst_interface}:(\s)?%{IPORHOST:dst_ip}(\s)?/(\s)?%{INT:dst_port}(\s)?\((\s)?%{IPORHOST:mapped_dst_ip}(\s)?\)(%{GREEDYDATA:irrelevant})?"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#ASA-302023,302025,302027
	if [messageid]=="302023" or [messageid]=="302025" or [messageid]=="302027"{
			grok {
				match => {
					"cisco_msg" => [
					"Teardown stub %{WORD:protocol} connection for %{GREEDYDATA:src_interface}:(\s)?%{IPORHOST:src_ip}(\s)?/(\s)?%{INT:src_port} to %{GREEDYDATA:dst_interface}:(\s)?%{IPORHOST:dst_ip}(\s)?/(\s)?%{INT:dst_port} duration %{GREEDYDATA:duration} forwarded bytes %{INT:bytes_xmt} %{GREEDYDATA:reason}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#ASA-302033,302034
	if [messageid]=="302033" or [messageid]=="302034" {
			grok {
				match => {
					"cisco_msg" => [
					"(Pre-allocated|Unable to pre-allocate) H323 GUP Connection for faddr %{GREEDYDATA:src_interface}:(\s)?%{IPORHOST:src_ip}(\s)?/(\s)?%{INT:src_port} to laddr %{GREEDYDATA:dst_interface}:(\s)?%{IPORHOST:dst_ip}(\s)?/(\s)?%{INT:dst_port}(%{GREEDYDATA:irrelevant})?"
					]
				}
			}
			if [messageid] == "302033" {
				mutate {
					add_field => { "[logx][utm][action]" => "Success" }
				}
			}
	}
	#......................................................................#
	#ASA-302035
	if [messageid]=="302035" {
			grok {
				match => {
					"cisco_msg" => [
					"Built %{WORD:direction} %{WORD:protocol} connection %{GREEDYDATA:connection_id} for %{DATA:src_interface}:(\s)?%{IPORHOST:src_ip}(\s)?/(\s)?%{INT:src_port}(\s)?\((\s)?%{IPORHOST:mapped_src_ip}(\s)?/(\s)?%{INT:mapped_src_port}(\s)?\)(\s)?(\(%{DATA:info_user1}\))? to %{DATA:dst_interface}:(\s)?%{IPORHOST:dst_ip}(\s)?/(\s)?%{INT:dst_port}(\s)?\((\s)?%{IPORHOST:mapped_dst_ip}(\s)?/(\s)?%{INT:mapped_dst_port}(\s)?\)(\s)?(\(%{DATA:info_user2}\))?(%{GREEDYDATA:toEnd})?"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
			#Decoding user optional of the source interface
			if [info_user1] {
			grok {
				match => {
					"info_user1" => [
					"(\s)?%{DATA:src_fwuser}(\s)?,(\s)?%{DATA:src_fwuser}(\s)?"
					]
				}
			}
			}
			#Decoding user optional of the destination interface
			if [info_user2] {
			grok {
				match => {
					"info_user2" => [
					"(\s)?%{DATA:dst_fwuser}(\s)?,(\s)?%{DATA:dst_fwuser}(\s)?"
					]
				}
			}
			}
			#Decoding reason and emitter user
			if [toEnd]{
				if "(" in [toEnd] {
				grok {
					match => {
						"toEnd" => [
						"(\s)?\((\s)?%{DATA:src_fwuser}(\s)?\)(%{GREEDYDATA:irrelevant})?"
						]
					}
				}
				}
			}
			#Finally deleting unnecessary fields
			mutate {
				remove_field => ["info_user1","info_user2","toEnd"]
			}
	}
	#......................................................................#
	#ASA-302036
	if [messageid]=="302036" {
			grok {
				match => {
					"cisco_msg" => [
					"Teardown %{WORD:protocol} connection %{GREEDYDATA:connection_id} for %{DATA:src_interface}:(\s)?%{IPORHOST:src_ip}(\s)?/(\s)?%{INT:src_port}(\s)?(\(%{DATA:info_user1}\))? to %{DATA:dst_interface}:(\s)?%{IPORHOST:dst_ip}(\s)?/(\s)?%{INT:dst_port}(\s)?(\(%{DATA:info_user2}\))? duration %{GREEDYDATA:duration} bytes %{INT:bytes_xmt} %{GREEDYDATA:reasonToEnd}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
			#Decoding user optional of the source interface
			if [info_user1] {
			grok {
				match => {
					"info_user1" => [
					"(\s)?%{DATA:src_fwuser}(\s)?,(\s)?%{DATA:src_fwuser}(\s)?"
					]
				}
			}
			}
			#Decoding user optional of the destination interface
			if [info_user2] {
			grok {
				match => {
					"info_user2" => [
					"(\s)?%{DATA:dst_fwuser}(\s)?,(\s)?%{DATA:dst_fwuser}(\s)?"
					]
				}
			}
			}
			#Decoding reason and emitter user
			if [reasonToEnd]{
				if "(" in [reasonToEnd] {
				grok {
					match => {
						"reasonToEnd" => [
						"%{GREEDYDATA:reason} \((\s)?%{DATA:src_fwuser}(\s)?\)(%{GREEDYDATA:irrelevant})?"
						]
					}
				}
				}else {
					mutate {
					add_field => { "reason" => "%{reasonToEnd}" }
					}
				}
			}
			#Finally deleting unnecessary fields
			mutate {
				remove_field => ["info_user1","info_user2","reasonToEnd"]
			}
	}
	#......................................................................#
	#ASA-302303
	if [messageid]=="302303" {
			grok {
				match => {
					"cisco_msg" => [
					"Built %{WORD:protocol} state-bypass connection %{GREEDYDATA:connection_id} from %{GREEDYDATA:src_interface}:(\s)?%{IPORHOST:src_ip}(\s)?/(\s)?%{INT:src_port}(\s)?\((\s)?%{IPORHOST:mapped_src_ip}(\s)?/(\s)?%{INT:mapped_src_port}(\s)?\) to %{GREEDYDATA:dst_interface}:(\s)?%{IPORHOST:dst_ip}(\s)?/(\s)?%{INT:dst_port}(\s)?\((\s)?%{IPORHOST:mapped_dst_ip}(\s)?/(\s)?%{INT:mapped_dst_port}(\s)?\)(%{GREEDYDATA:irrelevant})?"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#ASA-302304
	if [messageid]=="302304" {
			grok {
				match => {
					"cisco_msg" => [
					"Teardown %{WORD:protocol} state-bypass connection %{GREEDYDATA:connection_id} from %{GREEDYDATA:src_interface}:(\s)?%{IPORHOST:src_ip}(\s)?/(\s)?%{INT:src_port} to %{GREEDYDATA:dst_interface}:(\s)?%{IPORHOST:dst_ip}(\s)?/(\s)?%{INT:dst_port} %{GREEDYDATA:duration},(\s)?%{INT:bytes_xmt}(\s)?,%{GREEDYDATA:reason}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#ASA-302305
	if [messageid]=="302305" {
			grok {
				match => {
					"cisco_msg" => [
					"Built %{WORD:protocol} state-bypass connection %{GREEDYDATA:connection_id} for %{DATA:src_interface}:(\s)?%{IPORHOST:src_ip}(\s)?/(\s)?%{INT:src_port}(\s)?\((\s)?%{IPORHOST:mapped_src_ip}(\s)?/(\s)?%{INT:mapped_src_port}(\s)?\)(\s)?(\(%{DATA:info_user1}\))? to %{DATA:dst_interface}:(\s)?%{IPORHOST:dst_ip}(\s)?/(\s)?%{INT:dst_port}(\s)?\((\s)?%{IPORHOST:mapped_dst_ip}(\s)?/(\s)?%{INT:mapped_dst_port}(\s)?\)(\s)?(\(%{DATA:info_user2}\))?(%{GREEDYDATA:irrelevant})?"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
			#Decoding user optional of the source interface
			if [info_user1] {
			grok {
				match => {
					"info_user1" => [
					"(\s)?%{DATA:src_fwuser}(\s)?,(\s)?%{DATA:src_fwuser}(\s)?"
					]
				}
			}
			}
			#Decoding user optional of the destination interface
			if [info_user2] {
			grok {
				match => {
					"info_user2" => [
					"(\s)?%{DATA:dst_fwuser}(\s)?,(\s)?%{DATA:dst_fwuser}(\s)?"
					]
				}
			}
			}
			#Finally deleting unnecessary fields
			mutate {
				remove_field => ["info_user1","info_user2"]
			}
	}
	#......................................................................#
	#ASA-302306
	if [messageid]=="302306" {
			grok {
				match => {
					"cisco_msg" => [
					"Teardown %{WORD:protocol} state-bypass connection %{GREEDYDATA:connection_id} for %{DATA:src_interface}:(\s)?%{IPORHOST:src_ip}(\s)?/(\s)?%{INT:src_port}(\s)?(\(%{DATA:info_user1}\))? to %{DATA:dst_interface}:(\s)?%{IPORHOST:dst_ip}(\s)?/(\s)?%{INT:dst_port}(\s)?(\(%{DATA:info_user2}\))? duration %{GREEDYDATA:duration} bytes %{INT:bytes_xmt} %{GREEDYDATA:reason}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
			#Decoding user optional of the source interface
			if [info_user1] {
			grok {
				match => {
					"info_user1" => [
					"(\s)?%{DATA:src_fwuser}(\s)?,(\s)?%{DATA:src_fwuser}(\s)?"
					]
				}
			}
			}
			#Decoding user optional of the destination interface
			if [info_user2] {
			grok {
				match => {
					"info_user2" => [
					"(\s)?%{DATA:dst_fwuser}(\s)?,(\s)?%{DATA:dst_fwuser}(\s)?"
					]
				}
			}
			}
			#Finally deleting unnecessary fields
			mutate {
				remove_field => ["info_user1","info_user2","reasonToEnd"]
			}
	}
	#......................................................................#
	#ASA-305009
	if [messageid]=="305009" {
			grok {
				match => {
					"cisco_msg" => [
					"Built (dynamic|static) translation from %{DATA:src_interface}(\s)?(\(%{DATA:acl_name}\))?:%{IPORHOST:src_ip} (\((\s)?(''%{DATA:src_fwuser}''|%{DATA:src_fwuser})(\s)?\))?(\s)?to %{DATA:dst_interface}(\s)?:%{GREEDYDATA:dst_ip}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#ASA-305010
	if [messageid]=="305010" {
			grok {
				match => {
					"cisco_msg" => [
					"Teardown (dynamic|static) translation from %{GREEDYDATA:src_interface}:(\s)?%{IPORHOST:src_ip} (\((\s)?(''%{DATA:src_fwuser}''|%{DATA:src_fwuser})(\s)?\))?(\s)?to %{GREEDYDATA:dst_interface}:(\s)?%{IPORHOST:dst_ip} duration %{GREEDYDATA:duration}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#ASA-305011
	if [messageid]=="305011" {
			grok {
				match => {
					"cisco_msg" => [
					"Built (dynamic|static) %{WORD:protocol} translation from %{GREEDYDATA:src_interface}:(\s)?%{IPORHOST:src_ip}(\s)?/(\s)?%{INT:src_port} (\((\s)?(''%{DATA:src_fwuser}''|%{DATA:src_fwuser})(\s)?\))?(\s)?to %{GREEDYDATA:dst_interface}:(\s)?%{IPORHOST:dst_ip}(\s)?/(\s)?%{INT:dst_port}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#ASA-305012
	if [messageid]=="305012" {
			grok {
				match => {
					"cisco_msg" => [
					"Teardown (dynamic|static) %{WORD:protocol} translation from %{DATA:src_interface}(\s)?(\(%{DATA:acl_name}\))?:%{IPORHOST:src_ip}(\s)?/(\s)?%{INT:src_port} (\((\s)?(''%{DATA:src_fwuser}''|%{DATA:src_fwuser})(\s)?\))?(\s)?to %{GREEDYDATA:dst_interface}:(\s)?%{IPORHOST:dst_ip}(\s)?/(\s)?%{INT:dst_port} duration %{GREEDYDATA:duration}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#.......................................................................#
	#ASA-322001
	if [messageid]=="322001" {
			grok {
				match => {
					"cisco_msg" => [
					"%{WORD:cisco_action} MAC address %{DATA:src_mac_address},(\s)?%{GREEDYDATA:event_description} on interface %{GREEDYDATA:src_interface}"
					]
				}
			}
	}
	#......................................................................#
	#ASA-322002
	if [messageid]=="322002" {
			grok {
				match => {
					"cisco_msg" => [
					"%{WORD:protocol} %{DATA:event_description} for arp %{WORD:http_message} received from host %{DATA:src_mac_address} on interface %{DATA:src_interface}(\s)?.(\s)?This host is advertising MAC Address %{DATA:src_fake_mac_address} for IP Address %{IPORHOST:src_ip}(\s)?,(\s)?which is (statically|dynamically) bound to MAC Address %{GREEDYDATA:src_real_mac_address}"
					]
				}
			}
	}
	#......................................................................#
	#ASA-322003
	if [messageid]=="322003" {
			grok {
				match => {
					"cisco_msg" => [
					"%{WORD:protocol} %{DATA:event_description} for arp %{WORD:http_message} received from host %{DATA:src_mac_address} on interface %{DATA:src_interface}(\s)?.(\s)?This host is advertising MAC Address %{DATA:src_fake_mac_address} for IP Address %{IPORHOST:src_ip}(\s)?,(\s)?which %{GREEDYDATA:irrelevant}"
					]
				}
			}
	}
	#......................................................................#
	#ASA-400007,400008,400009,400026,400027,400028,400029,400030,400031,400032,400033
	if [messageid]=="400007" or [messageid]=="400008" or [messageid]=="400009" or [messageid]=="400026" or [messageid]=="400027" or [messageid]=="400028" or [messageid]=="400029" or [messageid]=="400030" or [messageid]=="400031" or [messageid]=="400032" or [messageid]=="400033"{
			grok {
				match => {
					"cisco_msg" => [
					"IPS:%{INT:signature_id} %{DATA:signature_title} from %{GREEDYDATA:src_ip} to %{GREEDYDATA:dst_ip} on interface %{GREEDYDATA:dst_interface}"
					]
				}
			}
		if [signature_title]{
			grok {
				match => {
					"signature_title" => [
					"%{WORD:protocol}%{GREEDYDATA:irrelevant}"
					]
				}
			}
		}
	}
	#......................................................................#
	#ASA-400023,400024,400041
	if [messageid]=="400023" or [messageid]=="400024" or [messageid]=="400041"{
			grok {
				match => {
					"cisco_msg" => [
					"IPS:%{INT:signature_id} %{DATA:signature_title} from %{GREEDYDATA:src_ip} to %{GREEDYDATA:dst_ip} on interface %{GREEDYDATA:dst_interface}"
					]
				}
			}
		if [signature_title]{
			grok {
				match => {
					"signature_title" => [
					"%{WORD:irrelevant} %{WORD:protocol}%{GREEDYDATA:irrelevant}"
					]
				}
			}
		}
	}
	#......................................................................#
	#ASA-400025,400050
	if [messageid]=="400025" or [messageid]=="400050"{
			grok {
				match => {
					"cisco_msg" => [
					"IPS:%{INT:signature_id} %{DATA:signature_title} from %{GREEDYDATA:src_ip} to %{GREEDYDATA:dst_ip} on interface %{GREEDYDATA:dst_interface}"
					]
				}
	}
	}
	#......................................................................#
	#ASA-402114
	if [messageid]=="402114" {
			grok {
				match => {
					"cisco_msg" => [
					"IPSEC:(\s)?Received an %{WORD:protocol} packet(\s)?\(SPI=%{DATA:spi}(\s)?,(\s)?sequence number=%{DATA:seq_num}(\s)?\) from %{GREEDYDATA:src_ip} to %{GREEDYDATA:dst_ip} with an %{GREEDYDATA:event_description}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#ASA-402115
	if [messageid]=="402115" {
			grok {
				match => {
					"cisco_msg" => [
					"IPSEC: Received a packet from %{GREEDYDATA:src_ip} to %{GREEDYDATA:dst_ip} containing %{WORD:act_proto} data instead of %{WORD:protocol}%{GREEDYDATA:irrelevant}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#ASA-402116
	if [messageid]=="402116" {
			grok {
				match => {
					"cisco_msg" => [
					"IPSEC: Received an %{WORD:protocol} packet(\s)?\(SPI=%{DATA:spi}(\s)?,(\s)?sequence number=%{DATA:seq_num}(\s)?\) from %{GREEDYDATA:src_ip} \(%{DATA:username}(\s)?\) to %{IPORHOST:dst_ip}(\s)?.%{GREEDYDATA:event_description}.(\s)?The packet specifies its destination as %{GREEDYDATA:pkt_daddr}(\s)?,(\s)?its source as %{GREEDYDATA:pkt_saddr}(\s)?,(\s)?and its protocol as %{GREEDYDATA:pkt_prot}(\s)?.(\s)?The SA specifies its local proxy as %{DATA:id_daddr}(\s)?/%{DATA:id_dmask}(\s)?/%{DATA:id_dprot}(\s)?/%{DATA:dst_port} and its remote proxy as %{DATA:id_saddr}(\s)?/%{DATA:id_smask}(\s)?/%{DATA:id_sprot}(\s)?/%{GREEDYDATA:src_port}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#ASA-402117
	if [messageid]=="402117" {
			grok {
				match => {
					"cisco_msg" => [
					"IPSEC: Received a non-IPsec \(%{WORD:protocol}(\s)?\) packet from %{GREEDYDATA:src_ip} to %{IPORHOST:dst_ip}%{GREEDYDATA:irrelevant}?"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#.......................................................................#
	#ASA-402118
	if [messageid]=="402118" {
			grok {
				match => {
					"cisco_msg" => [
					"IPSEC: Received an %{WORD:protocol} packet \(SPI=%{DATA:spi}(\s)?,(\s)?sequence number(=)?(\s)?%{DATA:seq_num}(\s)?\) from %{GREEDYDATA:src_ip} \(%{DATA:username}(\s)?\) to %{GREEDYDATA:dst_ip} containing an %{GREEDYDATA:event_description} fragment of length %{GREEDYDATA:frag_len} with offset %{GREEDYDATA:frag_offset}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#ASA-402119,402120
	if [messageid]=="402119" or [messageid]=="402120" {
			grok {
				match => {
					"cisco_msg" => [
					"IPSEC: Received an %{WORD:protocol} packet \(SPI=%{DATA:spi}(\s)?,(\s)?sequence number=%{DATA:seq_num}(\s)?\) from %{GREEDYDATA:src_ip} \(%{DATA:username}(\s)?\) to %{GREEDYDATA:dst_ip} that %{GREEDYDATA:event_description}"
					]
				}
			}
			if [messageid]=="402119"{
				mutate {
					add_field => { "[logx][utm][action]" => "Success" }
				}
			}
	}
	#......................................................................#
	#ASA-402128
	if [messageid]=="402128" {
			grok {
				match => {
					"cisco_msg" => [
					"CRYPTO: An attempt to allocate a large memory block failed,(\s)?size:(\s)?%{GREEDYDATA:size}(\s)?,(\s)?limit:(\s)?%{GREEDYDATA:limit}"
					]
				}
	}
	}
	#......................................................................#
	#ASA-405001
	if [messageid]=="405001" {
			grok {
				match => {
					"cisco_msg" => [
					"Received %{WORD:protocol} %{WORD:http_message} %{WORD:event_description} from %{IPORHOST:src_ip}(\s)?/%{DATA:src_mac_address} on interface %{DATA:src_interface} with existing ARP entry %{IPORHOST:src_real_ip}(\s)?/%{GREEDYDATA:src_real_mac_address}"
					]
				}
	}
	}
	#......................................................................#
	#ASA-405002
	if [messageid]=="405002" {
			grok {
				match => {
					"cisco_msg" => [
					"Received %{GREEDYDATA:event_description} from %{IPORHOST:src_ip}(\s)?/%{DATA:src_mac_address} for %{GREEDYDATA:irrelevant}"
					]
				}
	}
	}
	#......................................................................#
	#ASA-406001
	if [messageid]=="406001" {
			grok {
				match => {
					"cisco_msg" => [
					"%{WORD:protocol} port command low port(\s)?:(\s)?%{IPORHOST:src_ip}(\s)?/(\s)?%{INT:src_port} to %{GREEDYDATA:dst_ip} on interface %{GREEDYDATA:dst_interface}"
					]
				}
	}
	}
	#......................................................................#
	#ASA-406002
	if [messageid]=="406002" {
			grok {
				match => {
					"cisco_msg" => [
					"%{WORD:protocol} port command %{DATA:event_description}:(\s)?IP_address(\s)?\(%{IPORHOST:src_ip}(\s)?\) to %{GREEDYDATA:dst_ip} on interface %{GREEDYDATA:dst_interface}"
					]
				}
	}
	}
	#......................................................................#
	#ASA-407002
	if [messageid]=="407002" {
			grok {
				match => {
					"cisco_msg" => [
					"Embryonic limit %{INT:num_conns}(\s)?/%{INT:limit} for through connections exceeded.%{IPORHOST:src_ip}(\s)?/%{INT:src_port} to %{GREEDYDATA:global_ip} \(%{IPORHOST:dst_ip}(\s)?\)(\s)?/%{INT:dst_port} on interface %{GREEDYDATA:dst_interface}"
					]
				}
	}
	}
	#......................................................................#
	#ASA-603109
	if [messageid]=="603109" {
			grok {
				match => {
					"cisco_msg" => [
					"Teardown %{WORD:protocol} Tunnel at %{GREEDYDATA:src_interface},(\s)?tunnel-id(\s)?=(\s)?%{INT:tunnel_id}(\s)?,(\s)?remote-peer(\s)?=(\s)?%{IPORHOST:src_ip}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#ASA-605004
	if [messageid]=="605004" {
			grok {
				match => {
					"cisco_msg" => [
					"%{GREEDYDATA:event_description} from %{GREEDYDATA:src_ip}/%{INT:src_port} to %{GREEDYDATA:dst_interface}:%{GREEDYDATA:dst_ip}/%{INT:dst_port} for user %{GREEDYDATA:username}"
					]
				}
			}
	}
	#......................................................................#
	#ASA-617100
	if [messageid]=="617100" {
			grok {
				match => {
					"cisco_msg" => [
					"Teardown %{INT:num_conns} connection(\s)?(\(s\))? for user %{GREEDYDATA:src_ip}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#ASA-106018
	if [messageid]=="106018" {
			grok {
				match => {
					"cisco_msg" => [
					"%{WORD:protocol} packet type %{INT:icmp_type} %{WORD:cisco_action} by %{WORD:direction} list %{GREEDYDATA:access_list} src %{GREEDYDATA:src_ip} dest %{GREEDYDATA:dst_ip}"
					]
				}
			}
	}
	#......................................................................#
	#ASA-106020
	if [messageid]=="106020" {
			grok {
				match => {
					"cisco_msg" => [
					"%{WORD:cisco_action} IP teardrop fragment \(size(\s)?=(\s)?%{INT:fragment_size},(\s)?offset(\s)?=(\s)?%{INT:fragment_offset}\) from %{GREEDYDATA:src_ip} to %{GREEDYDATA:dst_ip}"
					]
				}
			}
	}
	#......................................................................#
	#ASA-611301
	if [messageid]=="611301" {
			grok {
				match => {
					"cisco_msg" => [
					"VPNClient:(\s)?%{WORD:protocol} configured for Client Mode with no split tunneling:(\s)?NAT address:(\s)?%{GREEDYDATA:src_ip}"
					]
				}
			}
	}
	#......................................................................#
	#ASA-611303
	if [messageid]=="611303" {
			grok {
				match => {
					"cisco_msg" => [
					"VPNClient:(\s)?%{WORD:protocol} configured for Client Mode with split tunneling: NAT address:(\s)?%{GREEDYDATA:nat_address} Split Tunnel Networks: %{GREEDYDATA:src_ip}/%{GREEDYDATA:src_masc} %{GREEDYDATA:dst_ip}/%{GREEDYDATA:dst_masc}"
					]
				}
			}
	}
	#......................................................................#
	#ASA-611304
	if [messageid]=="611304" {
			grok {
				match => {
					"cisco_msg" => [
					"VPNClient:(\s)?%{WORD:protocol} exemption configured for Network Extension Mode with split tunneling: Split Tunnel Networks: %{GREEDYDATA:src_ip}/%{GREEDYDATA:src_masc} %{GREEDYDATA:dst_ip}/%{GREEDYDATA:dst_masc}"
					]
				}
			}
	}
	#......................................................................#
	#ASA-611307
	if [messageid]=="611307" {
			grok {
				match => {
					"cisco_msg" => [
					"VPNClient:(\s)?Head end:(\s)?%{GREEDYDATA:src_ip}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#ASA-611309
	if [messageid]=="611309" {
			grok {
				match => {
					"cisco_msg" => [
					"VPNClient:(\s)?%{WORD:cisco_action} from head end and uninstalling previously downloaded policy:(\s)?Head End:(\s)?%{GREEDYDATA:src_ip}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#ASA-611310,611311
	if [messageid]=="611310" or [messageid]=="611311" {
			grok {
				match => {
					"cisco_msg" => [
					"VNPClient:(\s)?XAUTH %{WORD:cisco_action}:(\s)?Peer:(\s)?%{GREEDYDATA:src_ip}"
					]
				}
			}
			if [messageid]=="611310" {
				mutate {
					add_field => { "[logx][utm][action]" => "Success" }
				}
			}
	}
	#......................................................................#
	#ASA-611314
	if [messageid]=="611314" {
			grok {
				match => {
					"cisco_msg" => [
					"VPNClient: Load Balancing Cluster with Virtual IP:(\s)?%{GREEDYDATA:src_ip} has redirected the to server %{GREEDYDATA:dst_ip}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#ASA-611315
	if [messageid]=="611315" {
			grok {
				match => {
					"cisco_msg" => [
					"VPNClient:(\s)?%{WORD:cisco_action} from Load Balancing Cluster member %{GREEDYDATA:src_ip}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#ASA-611318
	if [messageid]=="611318" {
			grok {
				match => {
					"cisco_msg" => [
					"VPNClient:(\s)?User %{GREEDYDATA:cisco_action}:(\s)?Auth Server IP:(\s)?%{GREEDYDATA:src_ip} Auth Server Port:(\s)?%{INT:dst_port} Idle Timeout: %{INT:timeout}"
					]
				}
			}
	}
	#......................................................................#
	#ASA-710003
	if [messageid]=="710003" {
			grok {
				match => {
					"cisco_msg" => [
					"%{WORD:protocol} %{GREEDYDATA:cisco_action} by ACL from %{IPORHOST:src_ip}(\s)?/%{INT:src_port} to %{WORD:dst_interface}(\s)?(\s)?:(\s)?%{IPORHOST:dst_ip}(\s)?/%{INT:dst_port}%{GREEDYDATA:irrelevant}?"
					]
				}
			}
	}
	#......................................................................#
	#ASA-713252,713253
	if [messageid]=="713252" or [messageid]=="713253" {
			grok {
				match => {
					"cisco_msg" => [
					"Group = %{GREEDYDATA:group},(\s)?Username(\s)?=(\s)?(''%{DATA:src_fwuser}''|%{DATA:src_fwuser})(\s)?,(\s)?IP(\s)?=(\s)?%{GREEDYDATA:src_ip},(\s)?Integrity Firewall Server is not available.%{GREEDYDATA:irrelevant}"
					]
				}
			}
			if [messageid]=="713253" {
				mutate {
					add_field => { "[logx][utm][action]" => "Success" }
				}
			}
	}
	#......................................................................#
	#ASA-716001,716002,716003
	if [messageid]=="716001" or [messageid]=="716002" or [messageid]=="716003" {
			grok {
				match => {
					"cisco_msg" => [
					"Group (<%{DATA:group}>|%{GREEDYDATA:group}) User (<%{DATA:src_fwuser}>|''%{DATA:src_fwuser}''|%{DATA:src_fwuser}) IP (<%{IPORHOST:src_ip}>|%{IPORHOST:src_ip}) WebVPN %{GREEDYDATA:cisco_action}"
					]
				}
			}
			mutate {
					add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#ASA-716004,716006,716007,716009
	if [messageid]=="716004" or [messageid]=="716006" or [messageid]=="716007" or [messageid]=="716009" {
			grok {
				match => {
					"cisco_msg" => [
					"Group (<%{DATA:group}>|%{GREEDYDATA:group}) User (<%{DATA:src_fwuser}>|''%{DATA:src_fwuser}''|%{DATA:src_fwuser}) WebVPN %{GREEDYDATA:cisco_action}"
					]
				}
			}
			if [messageid]=="716004" {
				mutate {
					add_field => { "[logx][utm][action]" => "Success" }
				}
			}
	}
	#......................................................................#
	#ASA-716005
	if [messageid]=="716005" {
			grok {
				match => {
					"cisco_msg" => [
					"Group (<%{DATA:group}>|%{GREEDYDATA:group}) User (<%{DATA:src_fwuser}>|''%{DATA:src_fwuser}''|%{DATA:src_fwuser}) WebVPN ACL Parse Error:(\s)?%{GREEDYDATA:reason}"
					]
				}
			}
	}
	#......................................................................#
	#ASA-716038
	if [messageid]=="716038" {
			grok {
				match => {
					"cisco_msg" => [
					"Group (<%{DATA:group}>|%{GREEDYDATA:group}) User (<%{DATA:src_fwuser}>|''%{DATA:src_fwuser}''|%{DATA:src_fwuser}) IP %{IPORHOST:src_ip} %{GREEDYDATA:cisco_action}, Session %{GREEDYDATA:irrelevant}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#ASA-716039
	if [messageid]=="716039" {
			grok {
				match => {
					"cisco_msg" => [
					"%{GREEDYDATA:cisco_action},(\s)?group(\s)?=(\s)?%{GREEDYDATA:group} user(\s)?=(\s)?(''%{DATA:src_fwuser}''|%{DATA:src_fwuser})(\s)?,(\s)?Session %{GREEDYDATA:irrelevant}"
					]
				}
			}
	}
	#......................................................................#
	#ASA-719017,719019,719020,719021,719022,719023
	if [messageid]=="719017" or [messageid]=="719019" or [messageid]=="719020"
	or [messageid]=="719021" or [messageid]=="719022" or [messageid]=="719023" {
			grok {
				match => {
					"cisco_msg" => [
					"WebVPN user(:)?(\s)?(''%{DATA:src_fwuser}''|%{DATA:src_fwuser}) %{GREEDYDATA:cisco_action}"
					]
				}
			}
			if [messageid]=="719020" or [messageid]=="719022" {
				mutate {
					add_field => { "[logx][utm][action]" => "Success" }
				}
			}
	}
	#......................................................................#
	#ASA-719018
	if [messageid]=="719018" {
			grok {
				match => {
					"cisco_msg" => [
					"WebVPN user:(\s)?(''%{DATA:src_fwuser}''|%{DATA:src_fwuser}) ACL ID %{GREEDYDATA:access_list} not %{GREEDYDATA:irrelevant}"
					]
				}
			}
			mutate {
				add_field => { "[logx][cisco_asa][reason]" => "ACL not found" }
			}
	}
	#......................................................................#
	#ASA-719024
	if [messageid]=="719024" {
			grok {
				match => {
					"cisco_msg" => [
					"Email Proxy %{GREEDYDATA:cisco_action}:(\s)?session(\s)?=(\s)?%{GREEDYDATA:session} user(\s)?=(\s)?(''%{DATA:src_fwuser}''|%{DATA:src_fwuser}) addr(\s)?=(\s)?%{GREEDYDATA:src_ip}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#ASA-609002
	if [messageid]=="609002" {
			grok {
				match => {
					"cisco_msg" => [
					"Teardown local-host %{GREEDYDATA:zone-name}/\*(\s)?:(\s)?%{GREEDYDATA:src_ip} duration %{GREEDYDATA:duration}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#ASA-611305
	if [messageid]=="611305" {
			grok {
				match => {
					"cisco_msg" => [
					"VPNClient(\s)?:(\s)?DHCP Policy installed(\s)?:(\s)?Primary DNS(\s)?:(\s)?%{GREEDYDATA:primary_dns_ip} Secondary DNS(\s)?:(\s)?%{GREEDYDATA:secondary_dns_ip} Primary WINS(\s)?:(\s)?%{GREEDYDATA:primary_wins_ip} Secondary WINS(\s)?:(\s)?%{GREEDYDATA:secondary_wins_ip}"
					]
				}
			}
	}
	#......................................................................#
	#ASA-733100
	if [messageid]=="733100" {
			grok {
				match => {
					"cisco_msg" => [
					"(\[)?%{DATA:object}(\])? drop rate(\s)?(-)?%{INT:rate_id} exceeded. Current burst rate is %{INT:current_rate_val} per second(,)?(\s)?(_)?max configured rate is %{INT:current_rate_val_max}(\s)?;(\s)?Current average rate is %{INT:average_rate_val} per second(,)?(\s)?(_)?max configured rate is %{INT:average_rate_val_max}(\s)?;(\s)?Cumulative total count is %{INT:total_cnt}%{GREEDYDATA:irrelevant}?"
					]
				}
			}
	}
	#......................................................................#
	#ASA-733101
	if [messageid]=="733101" {
			grok {
				match => {
					"cisco_msg" => [
					"%{WORD:object} %{GREEDYDATA:dst_ip} is targeted. Current burst rate is %{INT:current_rate_val} per second,(\s)?max configured rate is %{INT:current_rate_val_max}(\s)?;(\s)?Current average rate is %{INT:average_rate_val} per second,(\s)?max configured rate is %{INT:average_rate_val_max}(\s)?;(\s)?Cumulative total count is %{INT:total_cnt}%{GREEDYDATA:irrelevant}?",
					"%{WORD:object} %{GREEDYDATA:src_ip} is attacking. Current burst rate is %{INT:current_rate_val} per second,(\s)?max configured rate is %{INT:current_rate_val_max}(\s)?;(\s)?Current average rate is %{INT:average_rate_val} per second,(\s)?max configured rate is %{INT:average_rate_val_max}(\s)?;(\s)?Cumulative total count is %{INT:total_cnt}%{GREEDYDATA:irrelevant}?"

					]
				}
			}
	}
	#......................................................................#
	#ASA-733102
	if [messageid]=="733102" {
			grok {
				match => {
					"cisco_msg" => [
					"Threat-detection add(s)? host %{GREEDYDATA:src_ip} to %{GREEDYDATA:irrelevant}?"

					]
				}
			}
	}
	#......................................................................#
	#ASA-733103
	if [messageid]=="733103" {
			grok {
				match => {
					"cisco_msg" => [
					"Threat-detection removes host %{GREEDYDATA:src_ip} from %{GREEDYDATA:irrelevant}?"
					]
				}
			}
	}
	#......................................................................#
	#ASA-733104,733105
	if [messageid]=="733104" or [messageid]=="733105" {
			grok {
				match => {
					"cisco_msg" => [
					"TD_SYSLOG_%{DATA:protocol}_%{DATA:cisco_action}_AVERAGE_RATE_EXCEED%{GREEDYDATA:irrelevant}?",
					"TD_SYSLOG_%{DATA:protocol}_%{DATA:cisco_action}_BURST_RATE_EXCEED%{GREEDYDATA:irrelevant}?"
					]
				}
			}
	}
}
#......................................................................#
#Decoding severity
if [severity]{
	if [severity] == "1" {
		mutate {
			add_field => {
				"[logx][cisco_asa][severityLabel]" => "Alert"
			}
		}
	}
	if [severity] == "2" {
		mutate {
			add_field => {
				"[logx][cisco_asa][severityLabel]" => "Critical"
			}
		}
	}
	if [severity] == "3" {
		mutate {
			add_field => {
				"[logx][cisco_asa][severityLabel]" => "Error"
			}
		}
	}
	if [severity] == "4" {
		mutate {
			add_field => {
				"[logx][cisco_asa][severityLabel]" => "Warning"
			}
		}
	}
	if [severity] == "5" {
		mutate {
			add_field => {
				"[logx][cisco_asa][severityLabel]" => "Notification"
			}
		}
	}
	if [severity] == "6" {
		mutate {
			add_field => {
				"[logx][cisco_asa][severityLabel]" => "Informational"
			}
		}
	}
	if [severity] == "7" {
		mutate {
			add_field => {
				"[logx][cisco_asa][severityLabel]" => "Debugging"
			}
		}
	}
}
#......................................................................#
#Formatting number values
if [severity]{
	mutate { convert => {"severity" => "integer"}}
}
if [messageid]{
	mutate { convert => {"messageid" => "integer"}}
}
if [src_port]{
	mutate { convert => {"src_port" => "integer"}}
}
if [dst_port]{
	mutate { convert => {"dst_port" => "integer"}}
}
if [hit_count]{
	mutate { convert => {"hit_count" => "integer"}}
}
if [bytes_xmt]{
	mutate { convert => {"bytes_xmt" => "integer"}}
}
if [bytes_rcv]{
	mutate { convert => {"bytes_rcv" => "integer"}}
}
if [in_if_num]{
	mutate { convert => {"in_if_num" => "integer"}}
}
if [out_if_num]{
	mutate { convert => {"out_if_num" => "integer"}}
}
if [mapped_src_port]{
	mutate { convert => {"mapped_src_port" => "integer"}}
}
if [mapped_dst_port]{
	mutate { convert => {"mapped_dst_port" => "integer"}}
}
if [icmp_type]{
	mutate { convert => {"icmp_type" => "integer"}}
}
if [code]{
	mutate { convert => {"code" => "integer"}}
}
if [tunnel_id]{
	mutate { convert => {"tunnel_id" => "integer"}}
}
if [num_conns]{
	mutate { convert => {"num_conns" => "integer"}}
}
if [fragment_size]{
	mutate { convert => {"fragment_size" => "integer"}}
}
if [fragment_offset]{
	mutate { convert => {"fragment_offset" => "integer"}}
}
if [timeout]{
	mutate { convert => {"timeout" => "integer"}}
}
if [global_port]{
	mutate { convert => {"global_port" => "integer"}}
}
#......................................................................#
#Then add all possible fields to the json tree structure

   mutate {
      rename => { "priority" => "[logx][cisco_asa][priority]" }
      rename => { "severity" => "[logx][cisco_asa][severity]" }
      rename => { "message" => "[logx][cisco_asa][message]" }
      rename => { "messageid" => "[logx][cisco_asa][messageid]" }
      rename => { "cisco_action" => "[logx][cisco_asa][cisco_action]" }
      rename => { "protocol" => "[logx][cisco_asa][proto]" }
      rename => { "src_ip" => "[logx][cisco_asa][src_ip]" }
      rename => { "src_port" => "[logx][cisco_asa][src_port]" }
      rename => { "src_mac_address" => "[logx][cisco_asa][src_mac_address]" }
      rename => { "dst_ip" => "[logx][cisco_asa][dest_ip]" }
      rename => { "dst_port" => "[logx][cisco_asa][dest_port]" }
      rename => { "direction" => "[logx][cisco_asa][direction]" }
      rename => { "src_interface" => "[logx][cisco_asa][src_interface]" }
      rename => { "dst_interface" => "[logx][cisco_asa][dst_interface]" }
      rename => { "tcp_flags" => "[logx][cisco_asa][tcp_flags]" }
      rename => { "event_description" => "[logx][cisco_asa][event_desc]" }
      rename => { "limit" => "[logx][cisco_asa][limit]" }
      rename => { "num_conns" => "[logx][cisco_asa][num_conns]" }
      rename => { "global_ip" => "[logx][cisco_asa][global_ip]" }
      rename => { "spi" => "[logx][cisco_asa][spi]" }
      rename => { "seq_num" => "[logx][cisco_asa][seq_num]" }
      rename => { "username" => "[logx][cisco_asa][src_user]" }
      rename => { "http_message" => "[logx][cisco_asa][http_message]" }
      rename => { "src_real_mac_address" => "[logx][cisco_asa][src_real_mac_address]" }

      #New fields from ASA-1-106101
      rename => { "num_flows" => "[logx][cisco_asa][num_flows]" }

      #New fields from ASA-6-106102
      rename => { "access_list" => "[logx][cisco_asa][access_list_id]" }
      rename => { "src_fwuser" => "[logx][cisco_asa][src_user]" }
      rename => { "hit_count" => "[logx][cisco_asa][hit_count]" }

      #New fields from ASA-4-109017
      rename => { "limit" => "[logx][cisco_asa][limit]" }

      #New fields from ASA-109101,109102,109103
      rename => { "audit_session_id" => "[logx][cisco_asa][audit_session_id]" }

      #New fields from ASA-109201 to 109213
      rename => { "session" => "[logx][cisco_asa][session]" }

      #New fields from ASA-113004
      rename => { "aaa_type" => "[logx][cisco_asa][aaa_type]" }

      #New fields from ASA-113009
      rename => { "policy" => "[logx][cisco_asa][policy]" }

      #New fields from ASA-113013
      rename => { "reason" => "[logx][cisco_asa][reason]" }

      #New fields from ASA-113019
      rename => { "group" => "[logx][cisco_asa][group]" }
      rename => { "session_type" => "[logx][cisco_asa][session_type]" }
      rename => { "duration" => "[logx][cisco_asa][duration]" }
      rename => { "bytes_xmt" => "[logx][cisco_asa][bytes_xmt]" }
      rename => { "bytes_rcv" => "[logx][cisco_asa][bytes_rcv]" }

      #New fields from ASA-113031
      rename => { "filter" => "[logx][cisco_asa][filter]" }

      #New fields from ASA-113042
      rename => { "client_ip" => "[logx][cisco_asa][client_ip]" }

      #New fields from ASA-4-209003
      rename => { "id" => "[logx][cisco_asa][id]" }

      #New fields from ASA-316002
      rename => { "in_if_num" => "[logx][cisco_asa][in_if_num]" }
      rename => { "out_if_num" => "[logx][cisco_asa][out_if_num]" }

      #New fields from ASA-302002,322003
      rename => { "src_fake_mac_address" => "[logx][cisco_asa][src_fake_mac_address]" }

      #New fields from ASA-302013
      rename => { "connection_id" => "[logx][cisco_asa][connection_id]" }
      rename => { "mapped_src_ip" => "[logx][cisco_asa][mapped_src_ip]" }
      rename => { "mapped_src_port" => "[logx][cisco_asa][mapped_src_port]" }
      rename => { "mapped_dst_ip" => "[logx][cisco_asa][mapped_dst_ip]" }
      rename => { "mapped_dst_port" => "[logx][cisco_asa][mapped_dst_port]" }
      rename => { "dst_fwuser" => "[logx][cisco_asa][dst_user]" }

      #New fields from ASA-302017
      rename => { "translated_src_ip" => "[logx][cisco_asa][translated_src_ip]" }
      rename => { "translated_dst_ip" => "[logx][cisco_asa][translated_dst_ip]" }
      rename => { "translated_cid" => "[logx][cisco_asa][translated_cid]" }
      rename => { "real_cid" => "[logx][cisco_asa][real_cid]" }

      #New fields from ASA-302021
      rename => { "icmp_type" => "[logx][cisco_asa][icmp_type]" }
      rename => { "code" => "[logx][cisco_asa][code]" }

      #New fields from ASA-302020
      rename => { "global_port" => "[logx][cisco_asa][global_port]" }

      #New fields from ASA-302022
      rename => { "role" => "[logx][cisco_asa][role]" }

      #New fields from ASA-305012
      rename => { "acl_name" => "[logx][cisco_asa][access_list_name]" }

      #New fields from ASA-400007 to 400009,400023 to 400033,400041,400050
      rename => { "signature_id" => "[logx][cisco_asa][signature_id]" }
      rename => { "signature_title" => "[logx][cisco_asa][signature_title]" }

      #New fields from ASA-4-402115
      rename => { "act_proto" => "[logx][cisco_asa][act_proto]" }

      #New fields from ASA-4-402116
      rename => { "pkt_daddr" => "[logx][cisco_asa][pkt_daddr]" }
      rename => { "pkt_saddr" => "[logx][cisco_asa][pkt_saddr]" }
      rename => { "pkt_prot" => "[logx][cisco_asa][pkt_prot]" }
      rename => { "id_daddr" => "[logx][cisco_asa][id_daddr]" }
      rename => { "id_dmask" => "[logx][cisco_asa][id_dmask]" }
      rename => { "id_dprot" => "[logx][cisco_asa][id_dprot]" }
      rename => { "id_saddr" => "[logx][cisco_asa][id_saddr]" }
      rename => { "id_smask" => "[logx][cisco_asa][id_smask]" }
      rename => { "id_sprot" => "[logx][cisco_asa][id_sprot]" }

      #New fields from ASA-4-402118
      rename => { "frag_len" => "[logx][cisco_asa][frag_len]" }
      rename => { "frag_offset" => "[logx][cisco_asa][frag_offset]" }

      #New fields from ASA-5-402128
      rename => { "size" => "[logx][cisco_asa][size]" }

      #New fields from ASA-4-405001
      rename => { "src_real_ip" => "[logx][cisco_asa][src_real_ip]" }

      #New fields from ASA-603109
      rename => { "tunnel_id" => "[logx][cisco_asa][tunnel_id]" }

      #New fields from ASA-106020
      rename => { "fragment_size" => "[logx][cisco_asa][fragment_size]" }
      rename => { "fragment_offset" => "[logx][cisco_asa][fragment_offset]" }

      #New fields from ASA-611303
      rename => { "nat_address" => "[logx][cisco_asa][nat_address]" }
      rename => { "src_masc" => "[logx][cisco_asa][src_masc]" }
      rename => { "dst_masc" => "[logx][cisco_asa][dst_masc]" }

      #New fields from ASA-611305
      rename => { "primary_dns_ip" => "[logx][cisco_asa][primary_dns_ip]" }
      rename => { "secondary_dns_ip" => "[logx][cisco_asa][secondary_dns_ip]" }
      rename => { "primary_wins_ip" => "[logx][cisco_asa][primary_wins_ip]" }
      rename => { "secondary_wins_ip" => "[logx][cisco_asa][secondary_wins_ip]" }

      #New fields from ASA-611318
      rename => { "timeout" => "[logx][cisco_asa][timeout]" }

      #New fields from ASA-609002
      rename => { "zone-name" => "[logx][cisco_asa][zone-name]" }

      #New fields from ASA-733100,733101
      rename => { "object" => "[logx][cisco_asa][object]" }
      rename => { "rate_id" => "[logx][cisco_asa][rate_id]" }
      rename => { "current_rate_val" => "[logx][cisco_asa][current_rate_val]" }
      rename => { "current_rate_val_max" => "[logx][cisco_asa][current_rate_val_max]" }
      rename => { "average_rate_val" => "[logx][cisco_asa][average_rate_val]" }
      rename => { "average_rate_val_max" => "[logx][cisco_asa][average_rate_val_max]" }
      rename => { "total_cnt" => "[logx][cisco_asa][total_cnt]" }

   }

   #Finally, remove unnecessary fields
   mutate {
      remove_field => ["@version","path","cisco_tag","cisco_msg_init","cisco_message","fecha",
      "irrelevant","cisco_msg","ciscoDataSource"]
   }
  }
   #Also, remove unwanted fields if the message not match with conditions
   mutate {
      remove_field => ["original_log_message","headers"]
   }
}
'
WHERE id=301;
----------------------------------------------------------------------------------------------------------------------------------------
-- CISCO SWITCH  --
----------------------------------------------------------------------------------------------------------------------------------------
UPDATE utm_logstash_filter
SET filter_version='2.0.1',logstash_filter='filter {
#......................................................................#
# Cisco Switches bassed on https://www.cisco.com/c/en/us/td/docs/ios/15_0sy/system/messages/15sysmg.pdf (july, 2022)
# https://www.cisco.com/c/en/us/support/ios-nx-os-software/index.html (november 2022)
# Support CISCO IOS from 15 SY to IOS XE v17
# Filter version 2.0.1

  split {
    field => "message"
    terminator => "<utm-log-separator>"
  }

    #Looking for datasource generated by an agent and parse original message
  if [message]=~/\[utm_stack_agent_ds=(.+)\]-(.+)/ {
    grok {
      match => {
        "message" => [ "\[utm_stack_agent_ds=%{DATA:dataSource}\]-%{GREEDYDATA:original_log_message}" ]
      }
    }
  }
  if [original_log_message] {
    mutate {
      update => { "message" => "%{[original_log_message]}" }
    }
  }


  if [message] and [message] =~/%(\w|_)+-((\b\w+\b-\b\w+\b-)?)(\d)-([A-Z]|_)+/{
    grok {
      match => { "message" => [
           "(<%{POSINT:syslog_pri}>)?(%{INT}: )?%{SYSLOGTIMESTAMP:syslog_timestamp}: %%{CISCO_REASON:facility}-((?<sub_facility>(\b\w+\b-\b\w+\b))-)?%{INT:severity_level}-%{CISCO_REASON:facility_mnemonic}: %{GREEDYDATA:cisco_msg}",
           "(<%{POSINT:syslog_pri}>)?(%{INT}: )?%{SYSLOGTIMESTAMP:syslog_timestamp}: %%{WORD:card_type}-%{INT}-MSG:(\s)?%{WORD:card_slot} %%{CISCO_REASON:facility}-((?<sub_facility>(\b\w+\b-\b\w+\b))-)?%{INT:severity_level}-%{CISCO_REASON:facility_mnemonic}: %{GREEDYDATA:cisco_msg}"
           ]
      }
    }
    if [facility] and ([facility] !="ASA" and [facility] !="FTD") {
#......................................................................#
#Generating dataSource field required by CurrelationRulesEngine
#Checks if exists, if not evaluate to the host variable
     if (![dataSource]){
        mutate { add_field => { "dataSource" => "%{host}" } }
     }
#......................................................................#
#Generating dataType field required by CurrelationRulesEngine
        mutate { add_field => { "dataType" => "cisco-switch" } }
#......................................................................#
#Decoding syslog_pri fields
       if [syslog_pri] {
         syslog_pri {
           use_labels => true
         }
       }
#Decoding CISCO Severity
       if [severity_level] {
          if [severity_level] == "0"{
             mutate { add_field => { "[logx][cisco_switch][severity_label]" => "emergency" } }
          } else if [severity_level] == "1"{
             mutate { add_field => { "[logx][cisco_switch][severity_label]" => "alert" } }
          } else if [severity_level] == "2"{
             mutate { add_field => { "[logx][cisco_switch][severity_label]" => "critical" } }
          } else if [severity_level] == "3"{
             mutate { add_field => { "[logx][cisco_switch][severity_label]" => "error" } }
          } else if [severity_level] == "4"{
             mutate { add_field => { "[logx][cisco_switch][severity_label]" => "warning" } }
          } else if [severity_level] == "5"{
             mutate { add_field => { "[logx][cisco_switch][severity_label]" => "notification" } }
          } else if [severity_level] == "6"{
             mutate { add_field => { "[logx][cisco_switch][severity_label]" => "informational" } }
          } else if [severity_level] == "7"{
             mutate { add_field => { "[logx][cisco_switch][severity_label]" => "debugging" } }
          }
       }
#......................................................................#
#Formatting number values
       if [severity_level]{
	        mutate { convert => {"severity_level" => "integer"} }
       }

#......................................................................#
#Generating default values if field is not present
       if ![sub_facility] {
          mutate { add_field => { "[sub_facility]" => "NP" } }
       }
       if ![card_type] {
          mutate { add_field => { "[card_type]" => "NP" } }
       }
       if ![card_slot] {
          mutate { add_field => { "[card_slot]" => "NP" } }
       }
#Generating logx structure
        mutate {
          rename => { "syslog_pri" => "[logx][cisco_switch][syslog_pri]" }
          rename => { "syslog_timestamp" => "[logx][cisco_switch][syslog_timestamp]" }
          rename => { "facility" => "[logx][cisco_switch][facility]" }
          rename => { "severity_level" => "[logx][cisco_switch][severity_level]" }
          rename => { "facility_mnemonic" => "[logx][cisco_switch][facility_mnemonic]" }
          rename => { "cisco_msg" => "[logx][cisco_switch][cisco_msg]" }
          rename => { "syslog_facility_code" => "[logx][cisco_switch][syslog_facility_code]" }
          rename => { "syslog_facility" => "[logx][cisco_switch][syslog_facility]" }
          rename => { "syslog_severity_code" => "[logx][cisco_switch][syslog_severity_code]" }
          rename => { "syslog_severity" => "[logx][cisco_switch][syslog_severity]" }
          rename => { "message" => "[logx][cisco_switch][message]" }

          #Added in v1.1.1
          rename => { "sub_facility" => "[logx][cisco_switch][sub_facility]" }
          rename => { "card_type" => "[logx][cisco_switch][card_type]" }
          rename => { "card_slot" => "[logx][cisco_switch][card_slot]" }
        }
#Finally, remove unnecessary fields
        mutate {
          remove_field => ["@version","path"]
        }
    }
  }
   #Also, remove unwanted fields if the message not match with conditions
   mutate {
      remove_field => ["original_log_message","headers"]
   }
}
'
WHERE id=1510;
----------------------------------------------------------------------------------------------------------------------------------------
-- CISCO FIREPOWER  --
----------------------------------------------------------------------------------------------------------------------------------------
UPDATE utm_logstash_filter
SET filter_version='2.0.1',logstash_filter='filter {

   split {
      field => "message"
      terminator => "<utm-log-separator>"
   }

   #Looking for datasource generated by an agent and parse original message
   if [message]=~/\[utm_stack_agent_ds=(.+)\]-(.+)/ {
    grok {
      match => {
        "message" => [ "\[utm_stack_agent_ds=%{DATA:dataSource}\]-%{GREEDYDATA:original_log_message}" ]
      }
    }
   }
   if [original_log_message] {
    mutate {
      update => { "message" => "%{[original_log_message]}" }
    }
   }

   if [message] and "%FTD-" in [message] {
#......................................................................#
#Filter version 2.0.1
# Cisco Firepower bassed on https://www.cisco.com/c/en/us/td/docs/security/firepower/Syslogs/b_fptd_syslog_guide.html (january 2022)
#Using grok to parse priority if present
      grok {
       match => {
        "message" => [
          "(<%{NUMBER:priority}>)?%{GREEDYDATA:cisco_msg_init}"
        ]
       }
      }
#......................................................................#
#Using grok to parse date and ip or host if present
  if [cisco_msg_init]{
     grok {
      match => {
       "cisco_msg_init" => [
         "%{CISCOTIMESTAMP:fecha} (%{IPORHOST:ciscoDataSource})?(:)? %{GREEDYDATA:cisco_message}"
       ]
      }
     }
  }
#......................................................................#
#Generating dataSource field required by CurrelationRulesEngine
#Checks if ciscoDataSource exists, if true, the dataSource field take its value, if not, take the agent dataSource value
 if ([ciscoDataSource]){
        if [dataSource] {
          mutate {
            update => { "dataSource" => "%{[ciscoDataSource]}" }
          }
        } else {
          mutate {
            add_field => { "dataSource" => "%{ciscoDataSource}" }
          }
        }
 }
#Finally evaluates to the host variable if can not be calculated
 if ![dataSource] {
    mutate {
       add_field => { "dataSource" => "%{host}" }
     }
 }

#......................................................................#
#Generating dataType field required by CurrelationRulesEngine
   mutate {
     add_field => {
       "dataType" => "firewall-cisco-firepower"
     }
   }
#......................................................................#
#Using grok to parse Firepower severity and message ID
	if [cisco_message]{
        grok {
 			match => {
 				"cisco_message" => [
				"%%{GREEDYDATA:cisco_tag}-%{INT:severity}-%{INT:messageid}: %{GREEDYDATA:cisco_msg}"
 				]
 			}
 		}
	}
#......................................................................#
#Begin Firepower message processing by ID based on https://www.cisco.com/c/en/us/td/docs/security/firepower/Syslogs/b_fptd_syslog_guide.html (january 2022)
if [messageid] and [cisco_msg]{
	#......................................................................#
	#FTD-2-106001
	if [messageid]=="106001" {
			grok {
				match => {
					"cisco_msg" => [
					"%{WORD:direction} %{WORD:protocol} connection %{WORD:cisco_action} from %{IP:src_ip}/%{INT:src_port} to %{IP:dst_ip}/%{INT:dst_port} flags %{GREEDYDATA:tcp_flags} on interface %{GREEDYDATA:src_interface}"
					]
				}
			}
	}
	#......................................................................#
	#FTD-2-106017
	if [messageid]=="106017" {
			grok {
				match => {
					"cisco_msg" => [
					"%{WORD:cisco_action} IP due to %{GREEDYDATA:event_description} from %{GREEDYDATA:src_ip} to %{IPORHOST:dst_ip}"
					]
				}
			}
	}
	#......................................................................#
	#FTD-2-106101
	if [messageid]=="106101" {
			grok {
				match => {
					"cisco_msg" => [
					"Number of cached %{GREEDYDATA:cisco_action} for ACL log has reached limit(\s)?\(%{INT:num_flows}(\s)?\)%{GREEDYDATA:irrelevant}?"
					]
				}
			}
	}
	#......................................................................#
	#FTD-6-106102,106103
	if [messageid]=="106102" or [messageid]=="106103"{
			grok {
				match => {
					"cisco_msg" => [
					"access-list %{GREEDYDATA:access_list} %{WORD:cisco_action} %{WORD:protocol} for user (''%{DATA:src_fwuser}''|%{DATA:src_fwuser}) %{DATA:src_interface}/%{IPORHOST:src_ip}(\s)?\((\s)?%{INT:src_port}(\s)?\)(\s)?->(\s)?%{DATA:dst_interface}/%{IPORHOST:dst_ip}(\s)?\((\s)?%{INT:dst_port}(\s)?\) hit-cnt %{INT:hit_count} %{GREEDYDATA:irrelevant}",
					"access-list %{GREEDYDATA:access_list} %{WORD:cisco_action} %{WORD:protocol} for user (''%{DATA:src_fwuser}''|%{DATA:src_fwuser}) %{DATA:src_interface}/%{IPORHOST:src_ip} %{INT:src_port} %{DATA:dst_interface}/%{IPORHOST:dst_ip} %{INT:dst_port} hit-cnt %{INT:hit_count} %{GREEDYDATA:irrelevant}"
					]
				}
			}
			if [cisco_action]{
				if [cisco_action] =~/(Permitted|permitted)/ {
					mutate {
						add_field => { "[logx][utm][action]" => "Success" }
					}
				}
			}
	}
	#......................................................................#
	#FTD-109101,109102,109103
	if [messageid]=="109101" or [messageid]=="109102" or [messageid]=="109103"{
			grok {
				match => {
					"cisco_msg" => [
					"Received CoA %{WORD:cisco_action} request from %{IPORHOST:src_ip} for user (''%{DATA:src_fwuser}''|%{DATA:src_fwuser}), with audit-session-id: %{GREEDYDATA:audit_session_id}",
					"Received CoA %{WORD:cisco_action} from %{IPORHOST:src_ip}, but cannot find named session %{GREEDYDATA:audit_session_id}",
					"CoA %{WORD:cisco_action} from %{IPORHOST:src_ip} failed for user (''%{DATA:src_fwuser}''|%{DATA:src_fwuser}), with session ID: %{GREEDYDATA:audit_session_id}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#FTD-109201 to 109213
	if [messageid]>="109201" and [messageid]<="109213"{
			grok {
				match => {
					"cisco_msg" => [
					"UAUTH(:)? Session(\s|=)%{GREEDYDATA:session}, User(\s|=)(''%{DATA:src_fwuser}''|%{DATA:src_fwuser}), Assigned IP(\s|=)%{IPORHOST:src_ip}, %{GREEDYDATA:cisco_action}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#FTD-113004
	if [messageid]=="113004"{
			grok {
				match => {
					"cisco_msg" => [
					"AAA user %{WORD:aaa_type} Successful : server = %{IPORHOST:src_ip} : user = %{GREEDYDATA:src_fwuser}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#FTD-113005
	if [messageid]=="113005"{
			grok {
				match => {
					"cisco_msg" => [
					"AAA user authentication Rejected(\s)?:(\s)?reason(\s)?=(\s)?%{DATA:reason}(\s)?:(\s)?(server|Server)(\s)?=(\s)?%{IPORHOST:dst_ip}(\s)?:(\s)?(User|user)(\s)?=(\s)?%{DATA:src_fwuser}(\s)?:(\s)?(User|user) IP(\s)?=(\s)?%{IPORHOST:src_ip}"
					]
				}
			}
	}
	#......................................................................#
	#FTD-113008
	if [messageid]=="113008"{
			grok {
				match => {
					"cisco_msg" => [
					"AAA transaction status ACCEPT(\s)?:(\s)?(user|User)(\s)?=(\s)?%{GREEDYDATA:src_fwuser}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#FTD-113009
	if [messageid]=="113009"{
			grok {
				match => {
					"cisco_msg" => [
					"AAA retrieved default group policy \(%{GREEDYDATA:policy}\) for (user|User)(\s)?=(\s)?%{GREEDYDATA:src_fwuser}",
					"AAA retrieved default group policy %{GREEDYDATA:policy} for (user|User) %{GREEDYDATA:src_fwuser}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#FTD-113010
	if [messageid]=="113010"{
			grok {
				match => {
					"cisco_msg" => [
					"AAA challenge received for user (''%{DATA:src_fwuser}''|%{DATA:src_fwuser}) from server %{IPORHOST:src_ip}"
					]
				}
			}
	}
	#......................................................................#
	#FTD-113011
	if [messageid]=="113011"{
			grok {
				match => {
					"cisco_msg" => [
					"AAA retrieved user specific group policy %{GREEDYDATA:policy} for user %{GREEDYDATA:src_fwuser}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#FTD-113012
	if [messageid]=="113012"{
			grok {
				match => {
					"cisco_msg" => [
					"AAA user authentication Successful(\s)?: local database(\s)?: user(\s)?=(\s)?%{GREEDYDATA:src_fwuser}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#FTD-113013
	if [messageid]=="113013"{
			grok {
				match => {
					"cisco_msg" => [
					"AAA unable to complete the request Error(\s)?:(\s)?reason(\s)?=(\s)?%{GREEDYDATA:reason}:(\s)?user(\s)?=(\s)?%{GREEDYDATA:src_fwuser}"
					]
				}
			}
	}
	#......................................................................#
	#FTD-113014
	if [messageid]=="113014"{
			grok {
				match => {
					"cisco_msg" => [
					"AAA authentication server not accessible(\s)?: server(\s)?=(\s)?%{IPORHOST:src_ip}(\s)?:(\s)?user(\s)?=(\s)?%{GREEDYDATA:src_fwuser}"
					]
				}
			}
	}
	#......................................................................#
	#FTD-113015, 113017
	if [messageid]=="113015" or [messageid]=="113017"{
			grok {
				match => {
					"cisco_msg" => [
					"(AAA user authentication Rejected|AAA credentials rejected)(\s)?: reason(\s)?=(\s)?%{DATA:reason}(\s)?:(\s)?local database(\s)?:(\s)?user(\s)?=(\s)?(''%{DATA:src_fwuser}''|%{DATA:src_fwuser})(\s)?:(\s)?user IP(\s)?=(\s)?%{IPORHOST:src_ip}(%{GREEDYDATA:irrelevant})?"
					]
				}
			}
	}
	#......................................................................#
	#FTD-113016
	if [messageid]=="113016"{
			grok {
				match => {
					"cisco_msg" => [
					"AAA credentials rejected(\s)?: reason(\s)?=(\s)?%{GREEDYDATA:reason}:(\s)?server(\s)?=(\s)?%{IPORHOST:dst_ip}(\s)?:(\s)?user(\s)?=(\s)?(''%{DATA:src_fwuser}''|%{DATA:src_fwuser})(\s)?:(\s)?user IP(\s)?=(\s)?%{IPORHOST:src_ip}"
					]
				}
			}
	}
	#......................................................................#
	#FTD-113019
	if [messageid]=="113019"{
			grok {
				match => {
					"cisco_msg" => [
					"Group(\s)?=(\s)?%{GREEDYDATA:group}(\s)?,(\s)?Username(\s)?=(\s)?(''%{DATA:src_fwuser}''|%{DATA:src_fwuser})(\s)?,(\s)?IP(\s)?=(\s)?%{IPORHOST:src_ip}(\s)?,(\s)?Session disconnected.(\s)?Session Type:(\s)?%{GREEDYDATA:session_type}(\s)?,(\s)?Duration:(\s)?%{GREEDYDATA:duration}(\s)?,(\s)?Bytes xmt:(\s)?%{INT:bytes_xmt}(\s)?,(\s)?Bytes rcv:(\s)?%{INT:bytes_rcv}(\s)?,(\s)?Reason:(\s)?%{GREEDYDATA:reason}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#FTD-113031,113032,113033
	if [messageid]=="113031" or [messageid]=="113032" or [messageid]=="113033"{
			grok {
				match => {
					"cisco_msg" => [
					"Group %{GREEDYDATA:group} User (''%{DATA:src_fwuser}''|%{DATA:src_fwuser}) IP %{IPORHOST:src_ip} AnyConnect (vpn-filter|ipv6-vpn-filter) %{GREEDYDATA:filter} is an (IPv6|IPv4) ACL; ACL not applied.",
					"Group %{GREEDYDATA:group} User (''%{DATA:src_fwuser}''|%{DATA:src_fwuser}) IP %{IPORHOST:src_ip} AnyConnect session not allowed.(\s)?ACL parse error."
					]
				}
			}
	}
	#......................................................................#
	#FTD-113034,113035,113036,113038,113039
	if [messageid]>="113034" and [messageid]<="113039" and [messageid]!="113037"{
			grok {
				match => {
					"cisco_msg" => [
					"Group (<%{DATA:group}>|%{GREEDYDATA:group}) User (<%{DATA:src_fwuser}>|''%{DATA:src_fwuser}''|%{DATA:src_fwuser}) IP (<%{IPORHOST:src_ip}>|%{IPORHOST:src_ip}) %{GREEDYDATA:irrelevant}"
					]
				}
			}
			if [messageid] != "113036" {
				mutate {
					add_field => { "[logx][utm][action]" => "Success" }
				}
			}
	}
	#......................................................................#
	#FTD-113042
	if [messageid]=="113042"{
			grok {
				match => {
					"cisco_msg" => [
					"CoA: Non-HTTP connection from %{GREEDYDATA:src_interface}(\s)?:(\s)?%{IPORHOST:src_ip}(\s)?/(\s)?%{INT:src_port} to %{GREEDYDATA:dst_interface}(\s)?:(\s)?%{IPORHOST:dst_ip}(\s)?/%{INT:dst_port} for user (''%{DATA:src_fwuser}''|%{DATA:src_fwuser}) at %{IPORHOST:client_ip} %{GREEDYDATA:irrelevant}"
					]
				}
			}
	}
	#......................................................................#
	#FTD-201003
	if [messageid]=="201003"{
			grok {
				match => {
					"cisco_msg" => [
					"Embryonic limit exceeded %{INT:num_conns}(\s)?/%{INT:limit} for %{IPORHOST:src_ip}(\s)?/%{INT:src_port} \(%{IPORHOST:global_ip}(\s)?\) %{IPORHOST:dst_ip}(\s)?/%{INT:dst_port} on interface %{GREEDYDATA:dst_interface}"
					]
				}
			}
	}
	#......................................................................#
	#FTD-209003
	if [messageid]=="209003"{
			grok {
				match => {
					"cisco_msg" => [
					"Fragment database limit of %{INT:limit} exceeded:(\s)?src(\s)?=(\s)?%{DATA:src_ip}(\s)?,(\s)?dest(\s)?=(\s)?%{DATA:dst_ip}(\s)?,(\s)?proto(\s)?=(\s)?%{DATA:protocol}(\s)?,(\s)?id(\s)?=(\s)?%{GREEDYDATA:id}"
					]
				}
			}
	}
	#......................................................................#
	#FTD-316001
	if [messageid]=="316001"{
			grok {
				match => {
					"cisco_msg" => [
					"Denied new tunnel to %{IPORHOST:src_ip}%{GREEDYDATA:irrelevant}"
					]
				}
			}
	}
	#......................................................................#
	#FTD-316002
	if [messageid]=="316002"{
			grok {
				match => {
					"cisco_msg" => [
					"VPN Handle error:(\s)?protocol=%{GREEDYDATA:protocol}(\s)?,(\s)?src %{INT:in_if_num}(\s)?:(\s)?%{IPORHOST:src_ip},(\s)?dst %{INT:out_if_num}(\s)?:(\s)?%{IPORHOST:dst_ip}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#FTD-302003,302004
	if [messageid]=="302003" or [messageid]=="302004" {
			grok {
				match => {
					"cisco_msg" => [
					"(Built H245 connection|Pre-allocate H323 UDP backconnection) for foreign_address %{IPORHOST:src_ip}(/%{INT:src_port}|/)? (to(\s))?local_address %{IPORHOST:dst_ip}(/%{INT:dst_port}|/)?"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#FTD-302012
	if [messageid]=="302012"{
			grok {
				match => {
					"cisco_msg" => [
					"Pre-allocate H225 Call Signalling Connection for faddr %{GREEDYDATA:src_ip}/%{INT:src_port} to laddr %{GREEDYDATA:dst_ip}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#FTD-302013
	if [messageid]=="302013"{
			grok {
				match => {
					"cisco_msg" => [
					"Built %{WORD:direction} (Probe)?(\s)?%{WORD:protocol} %{GREEDYDATA:connection_id} for %{GREEDYDATA:src_interface}:(\s)?%{IPORHOST:src_ip}(\s)?/(\s)?%{INT:src_port}(\s)?\(%{IPORHOST:mapped_src_ip}(\s)?/(\s)?%{INT:mapped_src_port}(\s)?\)(\s)?(\((''%{DATA:src_fwuser}''|%{DATA:src_fwuser})(\s)?\))?(\s)?to %{GREEDYDATA:dst_interface}:(\s)?%{IPORHOST:dst_ip}(\s)?/(\s)?%{INT:dst_port}(\s)?\((\s)?%{IPORHOST:mapped_dst_ip}(\s)?/(\s)?%{INT:mapped_dst_port}(\s)?\)(\s)?(\((''%{DATA:dst_fwuser}''|%{DATA:dst_fwuser})(\s)?\))?(%{GREEDYDATA:irrelevant})?"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#FTD-302014
	if [messageid]=="302014"{
			grok {
				match => {
					"cisco_msg" => [
					"Teardown (Probe)?(\s)?%{WORD:protocol} connection %{GREEDYDATA:connection_id} for %{GREEDYDATA:src_interface}:(\s)?%{IPORHOST:src_ip}(\s)?/(\s)?%{INT:src_port} (\((\s)?(''%{DATA:src_fwuser}''|%{DATA:src_fwuser})(\s)?\))?(\s)?to %{GREEDYDATA:dst_interface}:(\s)?%{IPORHOST:dst_ip}(\s)?/(\s)?%{INT:dst_port} (\((\s)?(''%{DATA:dst_fwuser}''|%{DATA:dst_fwuser})(\s)?\))?(\s)?duration %{GREEDYDATA:duration} bytes %{INT:bytes_xmt}(%{GREEDYDATA:irrelevant})?"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#FTD-302015
	if [messageid]=="302015"{
			grok {
				match => {
					"cisco_msg" => [
					"Built %{WORD:direction} %{WORD:protocol} connection %{GREEDYDATA:connection_id} for %{GREEDYDATA:src_interface}:(\s)?%{IPORHOST:src_ip}(\s)?/(\s)?%{INT:src_port}(\s)?\(%{IPORHOST:mapped_src_ip}(\s)?/(\s)?%{INT:mapped_src_port}(\s)?\)(\s)?(\((\s)?(''%{DATA:src_fwuser}''|%{DATA:src_fwuser})(\s)?\))?(\s)?to %{GREEDYDATA:dst_interface}:(\s)?%{IPORHOST:dst_ip}(\s)?/(\s)?%{INT:dst_port}(\s)?\((\s)?%{IPORHOST:mapped_dst_ip}(\s)?/(\s)?%{INT:mapped_dst_port}(\s)?\)(\s)?(\((\s)?(''%{DATA:dst_fwuser}''|%{DATA:dst_fwuser})(\s)?\))?(%{GREEDYDATA:irrelevant})?"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#FTD-302016
	if [messageid]=="302016"{
			grok {
				match => {
					"cisco_msg" => [
					"Teardown %{WORD:protocol} connection %{GREEDYDATA:connection_id} for %{GREEDYDATA:src_interface}:(\s)?%{IPORHOST:src_ip}(\s)?/(\s)?%{INT:src_port}(\s)?(\((\s)?(''%{DATA:src_fwuser}''|%{DATA:src_fwuser})(\s)?\))? to %{GREEDYDATA:dst_interface}:(\s)?%{IPORHOST:dst_ip}(\s)?/(\s)?%{INT:dst_port}(\s)?(\((\s)?(''%{DATA:dst_fwuser}''|%{DATA:dst_fwuser})(\s)?\))? duration %{GREEDYDATA:duration} bytes %{INT:bytes_xmt}(%{GREEDYDATA:irrelevant})?"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#FTD-302017
	if [messageid]=="302017"{
			grok {
				match => {
					"cisco_msg" => [
					"Built %{WORD:direction} %{WORD:protocol} connection %{GREEDYDATA:connection_id} from %{GREEDYDATA:src_interface}:(\s)?%{IPORHOST:src_ip} \((\s)?%{IPORHOST:translated_src_ip}(\s)?\)(\s)?(\((\s)?(''%{DATA:src_fwuser}''|%{DATA:src_fwuser})(\s)?\))? to %{GREEDYDATA:dst_interface}:(\s)?%{IPORHOST:dst_ip}(\s)?/%{DATA:real_cid} \(%{IPORHOST:translated_dst_ip}(\s)?/%{DATA:translated_cid}\)(\s)?(\((\s)?(''%{DATA:dst_fwuser}''|%{DATA:dst_fwuser})(\s)?\))?(%{GREEDYDATA:irrelevant})?"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#FTD-302018
	if [messageid]=="302018"{
			grok {
				match => {
					"cisco_msg" => [
					"Teardown %{WORD:protocol} connection %{GREEDYDATA:connection_id} from %{GREEDYDATA:src_interface}:(\s)?%{IPORHOST:src_ip} \((\s)?%{IPORHOST:translated_src_ip}(\s)?\)(\s)?(\((\s)?(''%{DATA:src_fwuser}''|%{DATA:src_fwuser})(\s)?\))? to %{GREEDYDATA:dst_interface}:(\s)?%{IPORHOST:dst_ip}(\s)?/%{DATA:real_cid} \(%{IPORHOST:translated_dst_ip}(\s)?/%{DATA:translated_cid}\)(\s)?(\((\s)?(''%{DATA:dst_fwuser}''|%{DATA:dst_fwuser})(\s)?\))? duration %{GREEDYDATA:duration} bytes %{INT:bytes_xmt}(%{GREEDYDATA:irrelevant})?"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#FTD-302020
	if [messageid]=="302020"{
			grok {
				match => {
					"cisco_msg" => [
					"Built %{WORD:direction} %{WORD:protocol} connection for faddr (%{IPORHOST:dst_ip}|%{INT:dst_ip})/%{INT:dst_port}(\s)?(\((\s)?(''%{DATA:src_fwuser}''|%{DATA:src_fwuser})(\s)?\))?(\s)?gaddr %{GREEDYDATA:global_ip}/%{INT:global_port} laddr %{IPORHOST:src_ip}/%{INT:src_port}(\s)?(\((\s)?(''%{DATA:dst_fwuser}''|%{DATA:dst_fwuser})(\s)?\))? type %{INT:icmp_type} code %{INT:code}",
					"Built %{WORD:direction} %{WORD:protocol} connection for faddr (%{IPORHOST:dst_ip}|%{INT:dst_ip}) (\((\s)?(''%{DATA:src_fwuser}''|%{DATA:src_fwuser})(\s)?\))?(\s)?gaddr %{GREEDYDATA:global_ip} laddr %{IPORHOST:src_ip} (\((\s)?(''%{DATA:dst_fwuser}''|%{DATA:dst_fwuser})(\s)?\))?(\s)?type %{INT:icmp_type} code %{INT:code}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#FTD-302021
	if [messageid]=="302021"{
			grok {
				match => {
					"cisco_msg" => [
					"Teardown %{WORD:protocol} connection for faddr (%{IPORHOST:dst_ip}|%{INT:dst_ip})/%{INT:dst_port}(\s)?(\((\s)?(''%{DATA:src_fwuser}''|%{DATA:src_fwuser})(\s)?\))? gaddr %{GREEDYDATA:global_ip}/%{INT:global_port} laddr %{IPORHOST:src_ip}/%{INT:src_port}(\s)?(\((\s)?(''%{DATA:dst_fwuser}''|%{DATA:dst_fwuser})(\s)?\))? type %{INT:icmp_type} code %{INT:code}",
					"Teardown %{WORD:protocol} connection for faddr (%{IPORHOST:dst_ip}|%{INT:dst_ip})(\s)?(\((\s)?(''%{DATA:src_fwuser}''|%{DATA:src_fwuser})(\s)?\))? gaddr %{GREEDYDATA:global_ip} laddr %{IPORHOST:src_ip} (\((\s)?(''%{DATA:dst_fwuser}''|%{DATA:dst_fwuser})(\s)?\))?(\s)?type %{INT:icmp_type} code %{INT:code}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#FTD-302022,302024,302026
	if [messageid]=="302022" or [messageid]=="302024" or [messageid]=="302026" {
			grok {
				match => {
					"cisco_msg" => [
					"Built %{GREEDYDATA:role} stub %{WORD:protocol} connection for %{GREEDYDATA:src_interface}:(\s)?%{IPORHOST:src_ip}(\s)?/(\s)?%{INT:src_port}(\s)?\((\s)?%{IPORHOST:mapped_src_ip}(\s)?/(\s)?%{INT:mapped_src_port}(\s)?\) to %{GREEDYDATA:dst_interface}:(\s)?%{IPORHOST:dst_ip}(\s)?/(\s)?%{INT:dst_port}(\s)?\((\s)?%{IPORHOST:mapped_dst_ip}(\s)?/(\s)?%{INT:mapped_dst_port}(\s)?\)(%{GREEDYDATA:irrelevant})?",
					"Built %{GREEDYDATA:role} stub %{WORD:protocol} connection for %{GREEDYDATA:src_interface}:(\s)?%{IPORHOST:src_ip}(\s)?/(\s)?%{INT:src_port}(\s)?\((\s)?%{IPORHOST:mapped_src_ip}(\s)?\) to %{GREEDYDATA:dst_interface}:(\s)?%{IPORHOST:dst_ip}(\s)?/(\s)?%{INT:dst_port}(\s)?\((\s)?%{IPORHOST:mapped_dst_ip}(\s)?\)(%{GREEDYDATA:irrelevant})?"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#FTD-302023,302025,302027
	if [messageid]=="302023" or [messageid]=="302025" or [messageid]=="302027"{
			grok {
				match => {
					"cisco_msg" => [
					"Teardown stub %{WORD:protocol} connection for %{GREEDYDATA:src_interface}:(\s)?%{IPORHOST:src_ip}(\s)?/(\s)?%{INT:src_port} to %{GREEDYDATA:dst_interface}:(\s)?%{IPORHOST:dst_ip}(\s)?/(\s)?%{INT:dst_port} duration %{GREEDYDATA:duration} forwarded bytes %{INT:bytes_xmt} %{GREEDYDATA:reason}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#FTD-302033,302034
	if [messageid]=="302033" or [messageid]=="302034" {
			grok {
				match => {
					"cisco_msg" => [
					"(Pre-allocated|Unable to pre-allocate) H323 GUP Connection for faddr %{GREEDYDATA:src_interface}:(\s)?%{IPORHOST:src_ip}(\s)?/(\s)?%{INT:src_port} to laddr %{GREEDYDATA:dst_interface}:(\s)?%{IPORHOST:dst_ip}(\s)?/(\s)?%{INT:dst_port}(%{GREEDYDATA:irrelevant})?"
					]
				}
			}
			if [messageid] == "302033" {
				mutate {
					add_field => { "[logx][utm][action]" => "Success" }
				}
			}
	}
	#......................................................................#
	#FTD-302035
	if [messageid]=="302035" {
			grok {
				match => {
					"cisco_msg" => [
					"Built %{WORD:direction} %{WORD:protocol} connection %{GREEDYDATA:connection_id} for %{DATA:src_interface}:(\s)?%{IPORHOST:src_ip}(\s)?/(\s)?%{INT:src_port}(\s)?\((\s)?%{IPORHOST:mapped_src_ip}(\s)?/(\s)?%{INT:mapped_src_port}(\s)?\)(\s)?(\(%{DATA:info_user1}\))? to %{DATA:dst_interface}:(\s)?%{IPORHOST:dst_ip}(\s)?/(\s)?%{INT:dst_port}(\s)?\((\s)?%{IPORHOST:mapped_dst_ip}(\s)?/(\s)?%{INT:mapped_dst_port}(\s)?\)(\s)?(\(%{DATA:info_user2}\))?(%{GREEDYDATA:toEnd})?"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
			#Decoding user optional of the source interface
			if [info_user1] {
			grok {
				match => {
					"info_user1" => [
					"(\s)?%{DATA:src_fwuser}(\s)?,(\s)?%{DATA:src_fwuser}(\s)?"
					]
				}
			}
			}
			#Decoding user optional of the destination interface
			if [info_user2] {
			grok {
				match => {
					"info_user2" => [
					"(\s)?%{DATA:dst_fwuser}(\s)?,(\s)?%{DATA:dst_fwuser}(\s)?"
					]
				}
			}
			}
			#Decoding reason and emitter user
			if [toEnd]{
				if "(" in [toEnd] {
				grok {
					match => {
						"toEnd" => [
						"(\s)?\((\s)?%{DATA:src_fwuser}(\s)?\)(%{GREEDYDATA:irrelevant})?"
						]
					}
				}
				}
			}
			#Finally deleting unnecessary fields
			mutate {
				remove_field => ["info_user1","info_user2","toEnd"]
			}
	}
	#......................................................................#
	#FTD-302036
	if [messageid]=="302036" {
			grok {
				match => {
					"cisco_msg" => [
					"Teardown %{WORD:protocol} connection %{GREEDYDATA:connection_id} for %{DATA:src_interface}:(\s)?%{IPORHOST:src_ip}(\s)?/(\s)?%{INT:src_port}(\s)?(\(%{DATA:info_user1}\))? to %{DATA:dst_interface}:(\s)?%{IPORHOST:dst_ip}(\s)?/(\s)?%{INT:dst_port}(\s)?(\(%{DATA:info_user2}\))? duration %{GREEDYDATA:duration} bytes %{INT:bytes_xmt} %{GREEDYDATA:reasonToEnd}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
			#Decoding user optional of the source interface
			if [info_user1] {
			grok {
				match => {
					"info_user1" => [
					"(\s)?%{DATA:src_fwuser}(\s)?,(\s)?%{DATA:src_fwuser}(\s)?"
					]
				}
			}
			}
			#Decoding user optional of the destination interface
			if [info_user2] {
			grok {
				match => {
					"info_user2" => [
					"(\s)?%{DATA:dst_fwuser}(\s)?,(\s)?%{DATA:dst_fwuser}(\s)?"
					]
				}
			}
			}
			#Decoding reason and emitter user
			if [reasonToEnd]{
				if "(" in [reasonToEnd] {
				grok {
					match => {
						"reasonToEnd" => [
						"%{GREEDYDATA:reason} \((\s)?%{DATA:src_fwuser}(\s)?\)(%{GREEDYDATA:irrelevant})?"
						]
					}
				}
				}else {
					mutate {
					add_field => { "reason" => "%{reasonToEnd}" }
					}
				}
			}
			#Finally deleting unnecessary fields
			mutate {
				remove_field => ["info_user1","info_user2","reasonToEnd"]
			}
	}
	#......................................................................#
	#FTD-302303
	if [messageid]=="302303" {
			grok {
				match => {
					"cisco_msg" => [
					"Built %{WORD:protocol} state-bypass connection %{GREEDYDATA:connection_id} from %{GREEDYDATA:src_interface}:(\s)?%{IPORHOST:src_ip}(\s)?/(\s)?%{INT:src_port}(\s)?\((\s)?%{IPORHOST:mapped_src_ip}(\s)?/(\s)?%{INT:mapped_src_port}(\s)?\) to %{GREEDYDATA:dst_interface}:(\s)?%{IPORHOST:dst_ip}(\s)?/(\s)?%{INT:dst_port}(\s)?\((\s)?%{IPORHOST:mapped_dst_ip}(\s)?/(\s)?%{INT:mapped_dst_port}(\s)?\)(%{GREEDYDATA:irrelevant})?"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#FTD-302304
	if [messageid]=="302304" {
			grok {
				match => {
					"cisco_msg" => [
					"Teardown %{WORD:protocol} state-bypass connection %{GREEDYDATA:connection_id} from %{GREEDYDATA:src_interface}:(\s)?%{IPORHOST:src_ip}(\s)?/(\s)?%{INT:src_port} to %{GREEDYDATA:dst_interface}:(\s)?%{IPORHOST:dst_ip}(\s)?/(\s)?%{INT:dst_port} %{GREEDYDATA:duration},(\s)?%{INT:bytes_xmt}(\s)?,%{GREEDYDATA:reason}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#FTD-302305
	if [messageid]=="302305" {
			grok {
				match => {
					"cisco_msg" => [
					"Built %{WORD:protocol} state-bypass connection %{GREEDYDATA:connection_id} for %{DATA:src_interface}:(\s)?%{IPORHOST:src_ip}(\s)?/(\s)?%{INT:src_port}(\s)?\((\s)?%{IPORHOST:mapped_src_ip}(\s)?/(\s)?%{INT:mapped_src_port}(\s)?\)(\s)?(\(%{DATA:info_user1}\))? to %{DATA:dst_interface}:(\s)?%{IPORHOST:dst_ip}(\s)?/(\s)?%{INT:dst_port}(\s)?\((\s)?%{IPORHOST:mapped_dst_ip}(\s)?/(\s)?%{INT:mapped_dst_port}(\s)?\)(\s)?(\(%{DATA:info_user2}\))?(%{GREEDYDATA:irrelevant})?"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
			#Decoding user optional of the source interface
			if [info_user1] {
			grok {
				match => {
					"info_user1" => [
					"(\s)?%{DATA:src_fwuser}(\s)?,(\s)?%{DATA:src_fwuser}(\s)?"
					]
				}
			}
			}
			#Decoding user optional of the destination interface
			if [info_user2] {
			grok {
				match => {
					"info_user2" => [
					"(\s)?%{DATA:dst_fwuser}(\s)?,(\s)?%{DATA:dst_fwuser}(\s)?"
					]
				}
			}
			}
			#Finally deleting unnecessary fields
			mutate {
				remove_field => ["info_user1","info_user2"]
			}
	}
	#......................................................................#
	#FTD-302306
	if [messageid]=="302306" {
			grok {
				match => {
					"cisco_msg" => [
					"Teardown %{WORD:protocol} state-bypass connection %{GREEDYDATA:connection_id} for %{DATA:src_interface}:(\s)?%{IPORHOST:src_ip}(\s)?/(\s)?%{INT:src_port}(\s)?(\(%{DATA:info_user1}\))? to %{DATA:dst_interface}:(\s)?%{IPORHOST:dst_ip}(\s)?/(\s)?%{INT:dst_port}(\s)?(\(%{DATA:info_user2}\))? duration %{GREEDYDATA:duration} bytes %{INT:bytes_xmt} %{GREEDYDATA:reason}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
			#Decoding user optional of the source interface
			if [info_user1] {
			grok {
				match => {
					"info_user1" => [
					"(\s)?%{DATA:src_fwuser}(\s)?,(\s)?%{DATA:src_fwuser}(\s)?"
					]
				}
			}
			}
			#Decoding user optional of the destination interface
			if [info_user2] {
			grok {
				match => {
					"info_user2" => [
					"(\s)?%{DATA:dst_fwuser}(\s)?,(\s)?%{DATA:dst_fwuser}(\s)?"
					]
				}
			}
			}
			#Finally deleting unnecessary fields
			mutate {
				remove_field => ["info_user1","info_user2","reasonToEnd"]
			}
	}
	#......................................................................#
	#FTD-305009
	if [messageid]=="305009" {
			grok {
				match => {
					"cisco_msg" => [
					"Built (dynamic|static) translation from %{DATA:src_interface}(\s)?(\(%{DATA:acl_name}\))?:%{IPORHOST:src_ip} (\((\s)?(''%{DATA:src_fwuser}''|%{DATA:src_fwuser})(\s)?\))?(\s)?to %{DATA:dst_interface}(\s)?:%{GREEDYDATA:dst_ip}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#FTD-305010
	if [messageid]=="305010" {
			grok {
				match => {
					"cisco_msg" => [
					"Teardown (dynamic|static) translation from %{GREEDYDATA:src_interface}:(\s)?%{IPORHOST:src_ip} (\((\s)?(''%{DATA:src_fwuser}''|%{DATA:src_fwuser})(\s)?\))?(\s)?to %{GREEDYDATA:dst_interface}:(\s)?%{IPORHOST:dst_ip} duration %{GREEDYDATA:duration}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#FTD-305011
	if [messageid]=="305011" {
			grok {
				match => {
					"cisco_msg" => [
					"Built (dynamic|static) %{WORD:protocol} translation from %{GREEDYDATA:src_interface}:(\s)?%{IPORHOST:src_ip}(\s)?/(\s)?%{INT:src_port} (\((\s)?(''%{DATA:src_fwuser}''|%{DATA:src_fwuser})(\s)?\))?(\s)?to %{GREEDYDATA:dst_interface}:(\s)?%{IPORHOST:dst_ip}(\s)?/(\s)?%{INT:dst_port}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#FTD-305012
	if [messageid]=="305012" {
			grok {
				match => {
					"cisco_msg" => [
					"Teardown (dynamic|static) %{WORD:protocol} translation from %{DATA:src_interface}(\s)?(\(%{DATA:acl_name}\))?:%{IPORHOST:src_ip}(\s)?/(\s)?%{INT:src_port} (\((\s)?(''%{DATA:src_fwuser}''|%{DATA:src_fwuser})(\s)?\))?(\s)?to %{GREEDYDATA:dst_interface}:(\s)?%{IPORHOST:dst_ip}(\s)?/(\s)?%{INT:dst_port} duration %{GREEDYDATA:duration}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#.......................................................................#
	#FTD-322001
	if [messageid]=="322001" {
			grok {
				match => {
					"cisco_msg" => [
					"%{WORD:cisco_action} MAC address %{DATA:src_mac_address},(\s)?%{GREEDYDATA:event_description} on interface %{GREEDYDATA:src_interface}"
					]
				}
			}
	}
	#......................................................................#
	#FTD-322002
	if [messageid]=="322002" {
			grok {
				match => {
					"cisco_msg" => [
					"%{WORD:protocol} %{DATA:event_description} for arp %{WORD:http_message} received from host %{DATA:src_mac_address} on interface %{DATA:src_interface}(\s)?.(\s)?This host is advertising MAC Address %{DATA:src_fake_mac_address} for IP Address %{IPORHOST:src_ip}(\s)?,(\s)?which is (statically|dynamically) bound to MAC Address %{GREEDYDATA:src_real_mac_address}"
					]
				}
			}
	}
	#......................................................................#
	#FTD-322003
	if [messageid]=="322003" {
			grok {
				match => {
					"cisco_msg" => [
					"%{WORD:protocol} %{DATA:event_description} for arp %{WORD:http_message} received from host %{DATA:src_mac_address} on interface %{DATA:src_interface}(\s)?.(\s)?This host is advertising MAC Address %{DATA:src_fake_mac_address} for IP Address %{IPORHOST:src_ip}(\s)?,(\s)?which %{GREEDYDATA:irrelevant}"
					]
				}
			}
	}
	#......................................................................#
	#FTD-402114
	if [messageid]=="402114" {
			grok {
				match => {
					"cisco_msg" => [
					"IPSEC:(\s)?Received an %{WORD:protocol} packet(\s)?\(SPI=%{DATA:spi}(\s)?,(\s)?sequence number=%{DATA:seq_num}(\s)?\) from %{GREEDYDATA:src_ip} to %{GREEDYDATA:dst_ip} with an %{GREEDYDATA:event_description}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#FTD-402115
	if [messageid]=="402115" {
			grok {
				match => {
					"cisco_msg" => [
					"IPSEC: Received a packet from %{GREEDYDATA:src_ip} to %{GREEDYDATA:dst_ip} containing %{WORD:act_proto} data instead of %{WORD:protocol}%{GREEDYDATA:irrelevant}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#FTD-402116
	if [messageid]=="402116" {
			grok {
				match => {
					"cisco_msg" => [
					"IPSEC: Received an %{WORD:protocol} packet(\s)?\(SPI=%{DATA:spi}(\s)?,(\s)?sequence number=%{DATA:seq_num}(\s)?\) from %{GREEDYDATA:src_ip} \(%{DATA:username}(\s)?\) to %{IPORHOST:dst_ip}(\s)?.%{GREEDYDATA:event_description}.(\s)?The packet specifies its destination as %{GREEDYDATA:pkt_daddr}(\s)?,(\s)?its source as %{GREEDYDATA:pkt_saddr}(\s)?,(\s)?and its protocol as %{GREEDYDATA:pkt_prot}(\s)?.(\s)?The SA specifies its local proxy as %{DATA:id_daddr}(\s)?/%{DATA:id_dmask}(\s)?/%{DATA:id_dprot}(\s)?/%{DATA:dst_port} and its remote proxy as %{DATA:id_saddr}(\s)?/%{DATA:id_smask}(\s)?/%{DATA:id_sprot}(\s)?/%{GREEDYDATA:src_port}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#FTD-402117
	if [messageid]=="402117" {
			grok {
				match => {
					"cisco_msg" => [
					"IPSEC: Received a non-IPsec \(%{WORD:protocol}(\s)?\) packet from %{GREEDYDATA:src_ip} to %{IPORHOST:dst_ip}%{GREEDYDATA:irrelevant}?"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#.......................................................................#
	#FTD-402118
	if [messageid]=="402118" {
			grok {
				match => {
					"cisco_msg" => [
					"IPSEC: Received an %{WORD:protocol} packet \(SPI=%{DATA:spi}(\s)?,(\s)?sequence number(=)?(\s)?%{DATA:seq_num}(\s)?\) from %{GREEDYDATA:src_ip} \(%{DATA:username}(\s)?\) to %{GREEDYDATA:dst_ip} containing an %{GREEDYDATA:event_description} fragment of length %{GREEDYDATA:frag_len} with offset %{GREEDYDATA:frag_offset}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#FTD-402119,402120
	if [messageid]=="402119" or [messageid]=="402120" {
			grok {
				match => {
					"cisco_msg" => [
					"IPSEC: Received an %{WORD:protocol} packet \(SPI=%{DATA:spi}(\s)?,(\s)?sequence number=%{DATA:seq_num}(\s)?\) from %{GREEDYDATA:src_ip} \(%{DATA:username}(\s)?\) to %{GREEDYDATA:dst_ip} that %{GREEDYDATA:event_description}"
					]
				}
			}
			if [messageid]=="402119"{
				mutate {
					add_field => { "[logx][utm][action]" => "Success" }
				}
			}
	}
	#......................................................................#
	#FTD-402128
	if [messageid]=="402128" {
			grok {
				match => {
					"cisco_msg" => [
					"CRYPTO: An attempt to allocate a large memory block failed,(\s)?size:(\s)?%{GREEDYDATA:size}(\s)?,(\s)?limit:(\s)?%{GREEDYDATA:limit}"
					]
				}
	}
	}
	#......................................................................#
	#FTD-405001
	if [messageid]=="405001" {
			grok {
				match => {
					"cisco_msg" => [
					"Received %{WORD:protocol} %{WORD:http_message} %{WORD:event_description} from %{IPORHOST:src_ip}(\s)?/%{DATA:src_mac_address} on interface %{DATA:src_interface} with existing ARP entry %{IPORHOST:src_real_ip}(\s)?/%{GREEDYDATA:src_real_mac_address}"
					]
				}
	}
	}
	#......................................................................#
	#FTD-405002
	if [messageid]=="405002" {
			grok {
				match => {
					"cisco_msg" => [
					"Received %{GREEDYDATA:event_description} from %{IPORHOST:src_ip}(\s)?/%{DATA:src_mac_address} for %{GREEDYDATA:irrelevant}"
					]
				}
	}
	}
	#......................................................................#
	#FTD-406001
	if [messageid]=="406001" {
			grok {
				match => {
					"cisco_msg" => [
					"%{WORD:protocol} port command low port(\s)?:(\s)?%{IPORHOST:src_ip}(\s)?/(\s)?%{INT:src_port} to %{GREEDYDATA:dst_ip} on interface %{GREEDYDATA:dst_interface}"
					]
				}
	}
	}
	#......................................................................#
	#FTD-406002
	if [messageid]=="406002" {
			grok {
				match => {
					"cisco_msg" => [
					"%{WORD:protocol} port command %{DATA:event_description}:(\s)?IP_address(\s)?\(%{IPORHOST:src_ip}(\s)?\) to %{GREEDYDATA:dst_ip} on interface %{GREEDYDATA:dst_interface}"
					]
				}
	}
	}
	#......................................................................#
	#FTD-407002
	if [messageid]=="407002" {
			grok {
				match => {
					"cisco_msg" => [
					"Embryonic limit %{INT:num_conns}(\s)?/%{INT:limit} for through connections exceeded.%{IPORHOST:src_ip}(\s)?/%{INT:src_port} to %{GREEDYDATA:global_ip} \(%{IPORHOST:dst_ip}(\s)?\)(\s)?/%{INT:dst_port} on interface %{GREEDYDATA:dst_interface}"
					]
				}
	}
	}
	#......................................................................#
	#FTD-603109
	if [messageid]=="603109" {
			grok {
				match => {
					"cisco_msg" => [
					"Teardown %{WORD:protocol} Tunnel at %{GREEDYDATA:src_interface},(\s)?tunnel-id(\s)?=(\s)?%{INT:tunnel_id}(\s)?,(\s)?remote-peer(\s)?=(\s)?%{IPORHOST:src_ip}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#FTD-605004
	if [messageid]=="605004" {
			grok {
				match => {
					"cisco_msg" => [
					"%{GREEDYDATA:event_description} from %{GREEDYDATA:src_ip}/%{INT:src_port} to %{GREEDYDATA:dst_interface}:%{GREEDYDATA:dst_ip}/%{INT:dst_port} for user %{GREEDYDATA:username}"
					]
				}
			}
	}
	#......................................................................#
	#FTD-617100
	if [messageid]=="617100" {
			grok {
				match => {
					"cisco_msg" => [
					"Teardown %{INT:num_conns} connection(\s)?(\(s\))? for user %{GREEDYDATA:src_ip}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#FTD-106018
	if [messageid]=="106018" {
			grok {
				match => {
					"cisco_msg" => [
					"%{WORD:protocol} packet type %{INT:icmp_type} %{WORD:cisco_action} by %{WORD:direction} list %{GREEDYDATA:access_list} src %{GREEDYDATA:src_ip} dest %{GREEDYDATA:dst_ip}"
					]
				}
			}
	}
	#......................................................................#
	#FTD-106020
	if [messageid]=="106020" {
			grok {
				match => {
					"cisco_msg" => [
					"%{WORD:cisco_action} IP teardrop fragment \(size(\s)?=(\s)?%{INT:fragment_size},(\s)?offset(\s)?=(\s)?%{INT:fragment_offset}\) from %{GREEDYDATA:src_ip} to %{GREEDYDATA:dst_ip}"
					]
				}
			}
	}
	#......................................................................#
	#FTD-106021
	if [messageid]=="106021" {
			grok {
				match => {
					"cisco_msg" => [
					"%{WORD:cisco_action} protocol reverse path check from %{GREEDYDATA:src_ip} to %{GREEDYDATA:dst_ip} on interface %{GREEDYDATA:src_interface}"
					]
				}
			}
	}
	#......................................................................#
	#FTD-611301
	if [messageid]=="611301" {
			grok {
				match => {
					"cisco_msg" => [
					"VPNClient:(\s)?%{WORD:protocol} configured for Client Mode with no split tunneling:(\s)?NAT address:(\s)?%{GREEDYDATA:src_ip}"
					]
				}
			}
	}
	#......................................................................#
	#FTD-611303
	if [messageid]=="611303" {
			grok {
				match => {
					"cisco_msg" => [
					"VPNClient:(\s)?%{WORD:protocol} configured for Client Mode with split tunneling: NAT address:(\s)?%{GREEDYDATA:nat_address} Split Tunnel Networks: %{GREEDYDATA:src_ip}/%{GREEDYDATA:src_masc} %{GREEDYDATA:dst_ip}/%{GREEDYDATA:dst_masc}"
					]
				}
			}
	}
	#......................................................................#
	#FTD-611304
	if [messageid]=="611304" {
			grok {
				match => {
					"cisco_msg" => [
					"VPNClient:(\s)?%{WORD:protocol} exemption configured for Network Extension Mode with split tunneling: Split Tunnel Networks: %{GREEDYDATA:src_ip}/%{GREEDYDATA:src_masc} %{GREEDYDATA:dst_ip}/%{GREEDYDATA:dst_masc}"
					]
				}
			}
	}
	#......................................................................#
	#FTD-611307
	if [messageid]=="611307" {
			grok {
				match => {
					"cisco_msg" => [
					"VPNClient:(\s)?Head end:(\s)?%{GREEDYDATA:src_ip}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#FTD-611309
	if [messageid]=="611309" {
			grok {
				match => {
					"cisco_msg" => [
					"VPNClient:(\s)?%{WORD:cisco_action} from head end and uninstalling previously downloaded policy:(\s)?Head End:(\s)?%{GREEDYDATA:src_ip}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#FTD-611310,611311
	if [messageid]=="611310" or [messageid]=="611311" {
			grok {
				match => {
					"cisco_msg" => [
					"VNPClient:(\s)?XAUTH (Succeeded|Failed):(\s)?Peer:(\s)?%{GREEDYDATA:src_ip}"
					]
				}
			}
			if [messageid]=="611310" {
				mutate {
					add_field => { "[logx][utm][action]" => "Success" }
				}
			}
	}
	#......................................................................#
	#FTD-611314
	if [messageid]=="611314" {
			grok {
				match => {
					"cisco_msg" => [
					"VPNClient: Load Balancing Cluster with Virtual IP:(\s)?%{GREEDYDATA:src_ip} has redirected the to server %{GREEDYDATA:dst_ip}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#FTD-611315
	if [messageid]=="611315" {
			grok {
				match => {
					"cisco_msg" => [
					"VPNClient:(\s)?%{WORD:cisco_action} from Load Balancing Cluster member %{GREEDYDATA:src_ip}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#FTD-611318
	if [messageid]=="611318" {
			grok {
				match => {
					"cisco_msg" => [
					"VPNClient:(\s)?User %{GREEDYDATA:cisco_action}:(\s)?Auth Server IP:(\s)?%{GREEDYDATA:src_ip} Auth Server Port:(\s)?%{INT:dst_port} Idle Timeout: %{INT:timeout}"
					]
				}
			}
	}
	#......................................................................#
	#FTD-710003
	if [messageid]=="710003" {
			grok {
				match => {
					"cisco_msg" => [
					"%{WORD:protocol} %{GREEDYDATA:cisco_action} by ACL from %{IPORHOST:src_ip}(\s)?/%{INT:src_port} to %{WORD:dst_interface}(\s)?(\s)?:(\s)?%{IPORHOST:dst_ip}(\s)?/%{INT:dst_port}%{GREEDYDATA:irrelevant}?"
					]
				}
			}
	}
	#......................................................................#
	#FTD-713252,713253
	if [messageid]=="713252" or [messageid]=="713253" {
			grok {
				match => {
					"cisco_msg" => [
					"Group = %{GREEDYDATA:group},(\s)?Username(\s)?=(\s)?(''%{DATA:src_fwuser}''|%{DATA:src_fwuser})(\s)?,(\s)?IP(\s)?=(\s)?%{GREEDYDATA:src_ip},(\s)?Integrity Firewall Server is not available.%{GREEDYDATA:irrelevant}"
					]
				}
			}
			if [messageid]=="713253" {
				mutate {
					add_field => { "[logx][utm][action]" => "Success" }
				}
			}
	}
	#......................................................................#
	#FTD-716001,716002,716003
	if [messageid]=="716001" or [messageid]=="716002" or [messageid]=="716003" {
			grok {
				match => {
					"cisco_msg" => [
					"Group (<%{DATA:group}>|%{GREEDYDATA:group}) User (<%{DATA:src_fwuser}>|''%{DATA:src_fwuser}''|%{DATA:src_fwuser}) IP (<%{IPORHOST:src_ip}>|%{IPORHOST:src_ip}) WebVPN %{GREEDYDATA:cisco_action}"
					]
				}
			}
			mutate {
					add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#FTD-716004,716006,716007,716009
	if [messageid]=="716004" or [messageid]=="716006" or [messageid]=="716007" or [messageid]=="716009" {
			grok {
				match => {
					"cisco_msg" => [
					"Group (<%{DATA:group}>|%{GREEDYDATA:group}) User (<%{DATA:src_fwuser}>|''%{DATA:src_fwuser}''|%{DATA:src_fwuser}) WebVPN %{GREEDYDATA:cisco_action}"
					]
				}
			}
			if [messageid]=="716004" {
				mutate {
					add_field => { "[logx][utm][action]" => "Success" }
				}
			}
	}
	#......................................................................#
	#FTD-716005
	if [messageid]=="716005" {
			grok {
				match => {
					"cisco_msg" => [
					"Group (<%{DATA:group}>|%{GREEDYDATA:group}) User (<%{DATA:src_fwuser}>|''%{DATA:src_fwuser}''|%{DATA:src_fwuser}) WebVPN ACL Parse Error:(\s)?%{GREEDYDATA:reason}"
					]
				}
			}
	}
	#......................................................................#
	#FTD-716038
	if [messageid]=="716038" {
			grok {
				match => {
					"cisco_msg" => [
					"Group (<%{DATA:group}>|%{GREEDYDATA:group}) User (<%{DATA:src_fwuser}>|''%{DATA:src_fwuser}''|%{DATA:src_fwuser}) IP %{IPORHOST:src_ip} %{GREEDYDATA:cisco_action}, Session %{GREEDYDATA:irrelevant}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#FTD-716039
	if [messageid]=="716039" {
			grok {
				match => {
					"cisco_msg" => [
					"%{GREEDYDATA:cisco_action},(\s)?group(\s)?=(\s)?%{GREEDYDATA:group} user(\s)?=(\s)?(''%{DATA:src_fwuser}''|%{DATA:src_fwuser})(\s)?,(\s)?Session %{GREEDYDATA:irrelevant}"
					]
				}
			}
	}
	#......................................................................#
	#FTD-719017,719019,719020,719021,719022,719023
	if [messageid]=="719017" or [messageid]=="719019" or [messageid]=="719020"
	or [messageid]=="719021" or [messageid]=="719022" or [messageid]=="719023" {
			grok {
				match => {
					"cisco_msg" => [
					"WebVPN user(:)?(\s)?(''%{DATA:src_fwuser}''|%{DATA:src_fwuser}) %{GREEDYDATA:cisco_action}"
					]
				}
			}
			if [messageid]=="719020" or [messageid]=="719022" {
				mutate {
					add_field => { "[logx][utm][action]" => "Success" }
				}
			}
	}
	#......................................................................#
	#FTD-719018
	if [messageid]=="719018" {
			grok {
				match => {
					"cisco_msg" => [
					"WebVPN user:(\s)?(''%{DATA:src_fwuser}''|%{DATA:src_fwuser}) ACL ID %{GREEDYDATA:access_list} not %{GREEDYDATA:irrelevant}"
					]
				}
			}
			mutate {
				add_field => { "[logx][cisco_firepower][reason]" => "ACL not found"	}
			}
	}
	#......................................................................#
	#FTD-719024
	if [messageid]=="719024" {
			grok {
				match => {
					"cisco_msg" => [
					"Email Proxy %{GREEDYDATA:cisco_action}:(\s)?session(\s)?=(\s)?%{GREEDYDATA:session} user(\s)?=(\s)?(''%{DATA:src_fwuser}''|%{DATA:src_fwuser}) addr(\s)?=(\s)?%{GREEDYDATA:src_ip}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#FTD-609002
	if [messageid]=="609002" {
			grok {
				match => {
					"cisco_msg" => [
					"Teardown local-host %{GREEDYDATA:zone-name}/\*(\s)?:(\s)?%{GREEDYDATA:src_ip} duration %{GREEDYDATA:duration}"
					]
				}
			}
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
	#......................................................................#
	#FTD-611305
	if [messageid]=="611305" {
			grok {
				match => {
					"cisco_msg" => [
					"VPNClient(\s)?:(\s)?DHCP Policy installed(\s)?:(\s)?Primary DNS(\s)?:(\s)?%{GREEDYDATA:primary_dns_ip} Secondary DNS(\s)?:(\s)?%{GREEDYDATA:secondary_dns_ip} Primary WINS(\s)?:(\s)?%{GREEDYDATA:primary_wins_ip} Secondary WINS(\s)?:(\s)?%{GREEDYDATA:secondary_wins_ip}"
					]
				}
			}
	}
	#......................................................................#
	#FTD-733100
	if [messageid]=="733100" {
			grok {
				match => {
					"cisco_msg" => [
					"(\[)?%{DATA:object}(\])? drop rate(\s)?(-)?%{INT:rate_id} exceeded. Current burst rate is %{INT:current_rate_val} per second(,)?(\s)?(_)?max configured rate is %{INT:current_rate_val_max}(\s)?;(\s)?Current average rate is %{INT:average_rate_val} per second(,)?(\s)?(_)?max configured rate is %{INT:average_rate_val_max}(\s)?;(\s)?Cumulative total count is %{INT:total_cnt}%{GREEDYDATA:irrelevant}?"
					]
				}
			}
	}
	#......................................................................#
	#FTD-733101
	if [messageid]=="733101" {
			grok {
				match => {
					"cisco_msg" => [
					"%{WORD:object} %{GREEDYDATA:dst_ip} is targeted. Current burst rate is %{INT:current_rate_val} per second,(\s)?max configured rate is %{INT:current_rate_val_max}(\s)?;(\s)?Current average rate is %{INT:average_rate_val} per second,(\s)?max configured rate is %{INT:average_rate_val_max}(\s)?;(\s)?Cumulative total count is %{INT:total_cnt}%{GREEDYDATA:irrelevant}?",
					"%{WORD:object} %{GREEDYDATA:src_ip} is attacking. Current burst rate is %{INT:current_rate_val} per second,(\s)?max configured rate is %{INT:current_rate_val_max}(\s)?;(\s)?Current average rate is %{INT:average_rate_val} per second,(\s)?max configured rate is %{INT:average_rate_val_max}(\s)?;(\s)?Cumulative total count is %{INT:total_cnt}%{GREEDYDATA:irrelevant}?"

					]
				}
			}
	}
	#......................................................................#
	#FTD-733102
	if [messageid]=="733102" {
			grok {
				match => {
					"cisco_msg" => [
					"Threat-detection add(s)? host %{GREEDYDATA:src_ip} to %{GREEDYDATA:irrelevant}?"

					]
				}
			}
	}
	#......................................................................#
	#FTD-733103
	if [messageid]=="733103" {
			grok {
				match => {
					"cisco_msg" => [
					"Threat-detection removes host %{GREEDYDATA:src_ip} from %{GREEDYDATA:irrelevant}?"
					]
				}
			}
	}
	#......................................................................#
	#FTD-733104,733105
	if [messageid]=="733104" or [messageid]=="733105" {
			grok {
				match => {
					"cisco_msg" => [
					"TD_SYSLOG_%{DATA:protocol}_%{DATA:cisco_action}_AVERAGE_RATE_EXCEED%{GREEDYDATA:irrelevant}?",
					"TD_SYSLOG_%{DATA:protocol}_%{DATA:cisco_action}_BURST_RATE_EXCEED%{GREEDYDATA:irrelevant}?"
					]
				}
			}
	}
}
#......................................................................#
#Decoding severity
if [severity]{
	if [severity] == "1" {
		mutate {
			add_field => {
				"[logx][cisco_firepower][severityLabel]" => "Alert"
			}
		}
	}
	if [severity] == "2" {
		mutate {
			add_field => {
				"[logx][cisco_firepower][severityLabel]" => "Critical"
			}
		}
	}
	if [severity] == "3" {
		mutate {
			add_field => {
				"[logx][cisco_firepower][severityLabel]" => "Error"
			}
		}
	}
	if [severity] == "4" {
		mutate {
			add_field => {
				"[logx][cisco_firepower][severityLabel]" => "Warning"
			}
		}
	}
	if [severity] == "5" {
		mutate {
			add_field => {
				"[logx][cisco_firepower][severityLabel]" => "Notification"
			}
		}
	}
	if [severity] == "6" {
		mutate {
			add_field => {
				"[logx][cisco_firepower][severityLabel]" => "Informational"
			}
		}
	}
	if [severity] == "7" {
		mutate {
			add_field => {
				"[logx][cisco_firepower][severityLabel]" => "Debugging"
			}
		}
	}
}
#......................................................................#
#Formatting number values
if [severity]{
	mutate { convert => {"severity" => "integer"}}
}
if [messageid]{
	mutate { convert => {"messageid" => "integer"}}
}
if [src_port]{
	mutate { convert => {"src_port" => "integer"}}
}
if [dst_port]{
	mutate { convert => {"dst_port" => "integer"}}
}
if [hit_count]{
	mutate { convert => {"hit_count" => "integer"}}
}
if [bytes_xmt]{
	mutate { convert => {"bytes_xmt" => "integer"}}
}
if [bytes_rcv]{
	mutate { convert => {"bytes_rcv" => "integer"}}
}
if [in_if_num]{
	mutate { convert => {"in_if_num" => "integer"}}
}
if [out_if_num]{
	mutate { convert => {"out_if_num" => "integer"}}
}
if [mapped_src_port]{
	mutate { convert => {"mapped_src_port" => "integer"}}
}
if [mapped_dst_port]{
	mutate { convert => {"mapped_dst_port" => "integer"}}
}
if [icmp_type]{
	mutate { convert => {"icmp_type" => "integer"}}
}
if [code]{
	mutate { convert => {"code" => "integer"}}
}
if [tunnel_id]{
	mutate { convert => {"tunnel_id" => "integer"}}
}
if [num_conns]{
	mutate { convert => {"num_conns" => "integer"}}
}
if [fragment_size]{
	mutate { convert => {"fragment_size" => "integer"}}
}
if [fragment_offset]{
	mutate { convert => {"fragment_offset" => "integer"}}
}
if [timeout]{
	mutate { convert => {"timeout" => "integer"}}
}
if [global_port]{
	mutate { convert => {"global_port" => "integer"}}
}
if [global_port]{
	mutate { convert => {"src_port_local" => "integer"}}
}
#......................................................................#
#Then add all possible fields to the json tree structure

   mutate {
      rename => { "priority" => "[logx][cisco_firepower][priority]" }
      rename => { "severity" => "[logx][cisco_firepower][severity]" }
      rename => { "message" => "[logx][cisco_firepower][message]" }
      rename => { "messageid" => "[logx][cisco_firepower][messageid]" }
      rename => { "cisco_action" => "[logx][cisco_firepower][cisco_action]" }
      rename => { "protocol" => "[logx][cisco_firepower][proto]" }
      rename => { "src_ip" => "[logx][cisco_firepower][src_ip]" }
      rename => { "src_port" => "[logx][cisco_firepower][src_port]" }
      rename => { "dst_ip" => "[logx][cisco_firepower][dest_ip]" }
      rename => { "dst_port" => "[logx][cisco_firepower][dest_port]" }
      rename => { "direction" => "[logx][cisco_firepower][direction]" }
      rename => { "src_interface" => "[logx][cisco_firepower][src_interface]" }
      rename => { "tcp_flags" => "[logx][cisco_firepower][tcp_flags]" }
      rename => { "event_description" => "[logx][cisco_firepower][event_desc]" }
      rename => { "limit" => "[logx][cisco_firepower][limit]" }
      rename => { "num_conns" => "[logx][cisco_firepower][num_conns]" }
      rename => { "global_ip" => "[logx][cisco_firepower][global_ip]" }
      rename => { "spi" => "[logx][cisco_firepower][spi]" }
      rename => { "seq_num" => "[logx][cisco_firepower][seq_num]" }
      rename => { "username" => "[logx][cisco_firepower][src_user]" }
      rename => { "http_message" => "[logx][cisco_firepower][http_message]" }
      rename => { "src_real_mac_address" => "[logx][cisco_firepower][src_real_mac_address]" }
      rename => { "src_mac_address" => "[logx][cisco_firepower][src_mac_address]" }
      rename => { "dst_interface" => "[logx][cisco_firepower][dst_interface]" }
      rename => { "limit" => "[logx][cisco_firepower][limit]" }

      #New fields from FTD-1-106101
      rename => { "num_flows" => "[logx][cisco_firepower][num_flows]" }

      #New fields from FTD-6-106102
      rename => { "access_list" => "[logx][cisco_firepower][access_list_id]" }
      rename => { "src_fwuser" => "[logx][cisco_firepower][src_user]" }
      rename => { "hit_count" => "[logx][cisco_firepower][hit_count]" }

      #New fields from FTD-109101,109102,109103
      rename => { "audit_session_id" => "[logx][cisco_firepower][audit_session_id]" }

      #New fields from FTD-109201 to 109213
      rename => { "session" => "[logx][cisco_firepower][session]" }

      #New fields from FTD-113004
      rename => { "aaa_type" => "[logx][cisco_firepower][aaa_type]" }

      #New fields from FTD-113009
      rename => { "policy" => "[logx][cisco_firepower][policy]" }

      #New fields from FTD-113013
      rename => { "reason" => "[logx][cisco_firepower][reason]" }

      #New fields from FTD-113019
      rename => { "group" => "[logx][cisco_firepower][group]" }
      rename => { "session_type" => "[logx][cisco_firepower][session_type]" }
      rename => { "duration" => "[logx][cisco_firepower][duration]" }
      rename => { "bytes_xmt" => "[logx][cisco_firepower][bytes_xmt]" }
      rename => { "bytes_rcv" => "[logx][cisco_firepower][bytes_rcv]" }

      #New fields from FTD-113031
      rename => { "filter" => "[logx][cisco_firepower][filter]" }

      #New fields from FTD-113042
      rename => { "client_ip" => "[logx][cisco_firepower][client_ip]" }

      #New fields from FTD-4-209003
      rename => { "id" => "[logx][cisco_firepower][id]" }

      #New fields from FTD-316002
      rename => { "in_if_num" => "[logx][cisco_firepower][in_if_num]" }
      rename => { "out_if_num" => "[logx][cisco_firepower][out_if_num]" }

      #New fields from FTD-302002,322003
      rename => { "src_fake_mac_address" => "[logx][cisco_firepower][src_fake_mac_address]" }

      #New fields from FTD-302013
      rename => { "connection_id" => "[logx][cisco_firepower][connection_id]" }
      rename => { "mapped_src_ip" => "[logx][cisco_firepower][mapped_src_ip]" }
      rename => { "mapped_src_port" => "[logx][cisco_firepower][mapped_src_port]" }
      rename => { "mapped_dst_ip" => "[logx][cisco_firepower][mapped_dst_ip]" }
      rename => { "mapped_dst_port" => "[logx][cisco_firepower][mapped_dst_port]" }
      rename => { "dst_fwuser" => "[logx][cisco_firepower][dst_user]" }

      #New fields from FTD-302017
      rename => { "translated_src_ip" => "[logx][cisco_firepower][translated_src_ip]" }
      rename => { "translated_dst_ip" => "[logx][cisco_firepower][translated_dst_ip]" }
      rename => { "translated_cid" => "[logx][cisco_firepower][translated_cid]" }
      rename => { "real_cid" => "[logx][cisco_firepower][real_cid]" }

      #New fields from FTD-302021
      rename => { "icmp_type" => "[logx][cisco_firepower][icmp_type]" }
      rename => { "code" => "[logx][cisco_firepower][code]" }
      rename => { "src_ip_local" => "[logx][cisco_firepower][src_ip_local]" }
      rename => { "src_port_local" => "[logx][cisco_firepower][src_port_local]" }

      #New fields from FTD-302020
      rename => { "global_port" => "[logx][cisco_firepower][global_port]" }

      #New fields from FTD-302022
      rename => { "role" => "[logx][cisco_firepower][role]" }

      #New fields from FTD-305012
      rename => { "acl_name" => "[logx][cisco_firepower][access_list_name]" }

      #New fields from FTD-4-402115
      rename => { "act_proto" => "[logx][cisco_firepower][act_proto]" }

      #New fields from FTD-4-402116
      rename => { "pkt_daddr" => "[logx][cisco_firepower][pkt_daddr]" }
      rename => { "pkt_saddr" => "[logx][cisco_firepower][pkt_saddr]" }
      rename => { "pkt_prot" => "[logx][cisco_firepower][pkt_prot]" }
      rename => { "id_daddr" => "[logx][cisco_firepower][id_daddr]" }
      rename => { "id_dmask" => "[logx][cisco_firepower][id_dmask]" }
      rename => { "id_dprot" => "[logx][cisco_firepower][id_dprot]" }
      rename => { "id_saddr" => "[logx][cisco_firepower][id_saddr]" }
      rename => { "id_smask" => "[logx][cisco_firepower][id_smask]" }
      rename => { "id_sprot" => "[logx][cisco_firepower][id_sprot]" }

      #New fields from FTD-4-402118
      rename => { "frag_len" => "[logx][cisco_firepower][frag_len]" }
      rename => { "frag_offset" => "[logx][cisco_firepower][frag_offset]" }

      #New fields from FTD-5-402128
      rename => { "size" => "[logx][cisco_firepower][size]" }

      #New fields from FTD-4-405001
      rename => { "src_real_ip" => "[logx][cisco_firepower][src_real_ip]" }

      #New fields from FTD-603109
      rename => { "tunnel_id" => "[logx][cisco_firepower][tunnel_id]" }

      #New fields from FTD-106020
      rename => { "fragment_size" => "[logx][cisco_firepower][fragment_size]" }
      rename => { "fragment_offset" => "[logx][cisco_firepower][fragment_offset]" }

      #New fields from FTD-611303
      rename => { "nat_address" => "[logx][cisco_firepower][nat_address]" }
      rename => { "src_masc" => "[logx][cisco_firepower][src_masc]" }
      rename => { "dst_masc" => "[logx][cisco_firepower][dst_masc]" }

      #New fields from FTD-611305
      rename => { "primary_dns_ip" => "[logx][cisco_firepower][primary_dns_ip]" }
      rename => { "secondary_dns_ip" => "[logx][cisco_firepower][secondary_dns_ip]" }
      rename => { "primary_wins_ip" => "[logx][cisco_firepower][primary_wins_ip]" }
      rename => { "secondary_wins_ip" => "[logx][cisco_firepower][secondary_wins_ip]" }

      #New fields from FTD-611318
      rename => { "timeout" => "[logx][cisco_firepower][timeout]" }

      #New fields from FTD-609002
      rename => { "zone-name" => "[logx][cisco_firepower][zone-name]" }

      #New fields from FTD-733100,733101
      rename => { "object" => "[logx][cisco_firepower][object]" }
      rename => { "rate_id" => "[logx][cisco_firepower][rate_id]" }
      rename => { "current_rate_val" => "[logx][cisco_firepower][current_rate_val]" }
      rename => { "current_rate_val_max" => "[logx][cisco_firepower][current_rate_val_max]" }
      rename => { "average_rate_val" => "[logx][cisco_firepower][average_rate_val]" }
      rename => { "average_rate_val_max" => "[logx][cisco_firepower][average_rate_val_max]" }
      rename => { "total_cnt" => "[logx][cisco_firepower][total_cnt]" }
   }

   #Finally, remove unnecessary fields
   mutate {
      remove_field => ["@version","path","cisco_tag","cisco_msg_init","cisco_message","fecha",
      "irrelevant","cisco_msg","ciscoDataSource"]
   }
  }
   #Also, remove unwanted fields if the message not match with conditions
   mutate {
      remove_field => ["original_log_message","headers"]
   }
}
'
WHERE id=303;
----------------------------------------------------------------------------------------------------------------------------------------
-- CISCO MERAKI  --
----------------------------------------------------------------------------------------------------------------------------------------
UPDATE utm_logstash_filter
SET filter_version='2.0.1',logstash_filter='filter {

   split {
      field => "message"
      terminator => "<utm-log-separator>"
   }

   #Looking for datasource generated by an agent and parse original message
   if [message]=~/\[utm_stack_agent_ds=(.+)\]-(.+)/ {
    grok {
      match => {
        "message" => [ "\[utm_stack_agent_ds=%{DATA:dataSource}\]-%{GREEDYDATA:original_log_message}" ]
      }
    }
   }
   if [original_log_message] {
    mutate {
      update => { "message" => "%{[original_log_message]}" }
    }
   }

#......................................................................#
# Cisco Meraki bassed on https://documentation.meraki.com/General_Administration/Monitoring_and_Reporting/Syslog_Event_Types_and_Log_Samples (january 2022)
# https://documentation.cysiv.com/articles/#!data-source-onboarding-device-configuration-reference/cisco-meraki-reference-information-and-cim-mapping
# Filter version 2.0.1

#First identify meraki messages
   if [message] and ([message]=~/\b((ANB)_)?(MX|MR)(\d){2} (events|flows|urls|ids-alerts|security_event)\b/
   or [message]=~/\b(MS)(\d){3}_(\d){1,2}P (events|flows|urls|ids-alerts|security_event)\b/
   or ("signature" in [message] and "priority" in [message] and "timestamp" in [message]
   and "dhost" in [message] and "direction" in [message] and "protocol" in [message]
   and "src" in [message] and "dst" in [message])
   or ("url" in [message] and "src" in [message] and "dst" in [message]
   and "mac" in [message] and "name" in [message] and "disposition" in [message]
   and "action" in [message])
   or ([message]=~/\b(?:[+-]?(?:[0-9]+))\.(?:[+-]?(?:[0-9]+))\slabs_appliance events Site-to-site VPN\b/)
   or ([message]=~/\b(?:[+-]?(?:[0-9]+))\.(?:[+-]?(?:[0-9]+))\slabs_Z1 events Site-to-site VPN\b/)
   or ("airmarshal_events" in [message] and "type" in [message] and "ssid" in [message]
   and "bssid" in [message] and "src" in [message] and "dst" in [message]
   and (("wired_mac" in [message]) or ("vap" in [message] and "rssi" in [message])) )
   or [message]=~/\b(?:[+-]?(?:[0-9]+))\.(?:[+-]?(?:[0-9]+)) ((\w|-)+) (events|flows|urls|ids-alerts|security_event)\b/ ) {

#......................................................................#
#Using grok to parse priority if present
        grok {
          match => {
           "message" => [ "(<%{NUMBER:priority}>)?%{GREEDYDATA:meraki_msg_init}" ]
          }
        }
#......................................................................#
#Using grok to parse date and ip or host if present
      if [meraki_msg_init] {
        grok {
          match => {
           "meraki_msg_init" => [
           "(%{CISCOTIMESTAMP:fecha})?(\s)?(%{IPORHOST:ciscoDataSource})?(\s)?(:)?(\s)?%{GREEDYDATA:meraki_message}"
           ]
          }
        }
      }
#......................................................................#
#Generating dataSource field required by CurrelationRulesEngine
#Checks if ciscoDataSource exists, if true, the dataSource field take its "valid" value, if not, take the agent dataSource value

 if ([ciscoDataSource]){
      if !([ciscoDataSource]=~/^((\d)+)$/) {
	    #For cases when ciscoDataSource is a number only, and not IPORHOST
	    #because the log is like: <166>1 1380653443.857790533 FFF_MX events ...
	    #in the case above (1) match with IPORHOST pattern
        if [dataSource] {
          mutate {
            update => { "dataSource" => "%{[ciscoDataSource]}" }
          }
        } else {
          mutate {
            add_field => { "dataSource" => "%{ciscoDataSource}" }
          }
        }
      }
 }
#Finally evaluates to the host variable if can not be calculated
 if ![dataSource] {
    mutate {
       add_field => { "dataSource" => "%{host}" }
     }
 }

#......................................................................#
#Generating dataType field required by CurrelationRulesEngine
    mutate {
     add_field => { "dataType" => "firewall-meraki" }
    }
#......................................................................#
#Begin to parse messages
#......................................................................#
# generic event	parsing
	if [meraki_message] {
        grok {
 			match => {
 				"meraki_message" => [
				"(%{GREEDYDATA:irrelevant} %{IPORHOST:msg_src_ip} %{INT:msg_src_port}(\s))?%{DATA:msg_event_time} %{DATA:msg_mx_type} (?<msg_mx_group>((events|flows|urls|ids-alerts|security_event))) %{GREEDYDATA:generic_event}"
				]
 			}
 		}
	}
	if [generic_event] {
# event vpn connectivity change
        grok {
 			match => {
 				"generic_event" => [
				"type(\s)?=(\s)?%{DATA:event_type} vpn_type(\s)?=(\s)?''%{DATA:vpn_type}'' peer_contact(\s)?=(\s)?''%{IPORHOST:src_ip}(\s)?:(\s)?%{INT:src_port}'' peer_ident(\s)?=(\s)?''%{GREEDYDATA:peer_ident}'' connectivity(\s)?=(\s)?''%{WORD:connectivity}''"
 				]
 			}
 		}
		#Add action field when connection seems to be established
		if [connectivity] and [connectivity] == "true" {
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
		}
#......................................................................#
# event uplink connectivity change
    if "failover to" in [generic_event] {
		grok {
 			match => {
 				"generic_event" => [
				"%{GREEDYDATA:event_type}"
 				]
 			}
 		}
	}else if [generic_event]=~/\bCellular connection (up|Up|down|Down)(\s)?(?:[+-]?(?:[0-9]+))\.(?:[+-]?(?:[0-9]+))\b/ {
		# Event: urls, HTTP GET requests in MR Access Points
		grok {
 			match => {
 				"generic_event" => [
				"Cellular connection (?<mx_conn_state>(up|Up|down|Down))(\s)?%{DATA:event_time} %{WORD:mx_type} (?<mx_group>((events|flows|urls|ids-alerts|security_event))) src(\s)?=(\s)?%{IPORHOST:src_ip}(\s)?:(\s)?%{INT:src_port} dst(\s)?=(\s)?%{IPORHOST:dst_ip}(\s)?:(\s)?%{INT:dst_port} mac(\s)?=(\s)?%{GREEDYDATA:mac} request(\s)?:(\s)?%{WORD:method} %{GREEDYDATA:url}"
 				]
 			}
 		}
		#Add action field when connection seems to be established
		if [mx_conn_state] and [mx_conn_state] =~/\b(up|Up)\b/ {
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
		}
	}else if [generic_event]=~/\bCellular connection (up|Up|down|Down)\b/ {
		grok {
 			match => {
 				"generic_event" => [
				"%{GREEDYDATA:event_type}"
 				]
 			}
 		}
		#Add action field when connection seems to be established
		if [generic_event] =~/\b(up|Up)\b/ {
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
		}
	}
#......................................................................#
# Event: event, dhcp no offers
    if "dhcp no offers" in [generic_event] {
        grok {
 			match => {
 				"generic_event" => [
				"%{DATA:event_type} for mac %{GREEDYDATA:mac} host(\s)?=(\s)?%{IPORHOST:src_ip}%{GREEDYDATA:irrelevant}?"
 				]
 			}
 		}
	}
#......................................................................#
# Event: event, dhcp lease
    if "dhcp lease" in [generic_event] {
        grok {
 			match => {
 				"generic_event" => [
				"%{DATA:event_type} of ip %{IPORHOST:src_ip} from server mac %{GREEDYDATA:server_mac} for client mac %{GREEDYDATA:client_mac} from router %{IPORHOST:router_ip} on subnet %{IPORHOST:subnet} with dns %{IPORHOST:dns}(\s)?,(\s)?%{IPORHOST:dns}%{GREEDYDATA:irrelevant}?"
 				]
 			}
 		}
		#Add action field when connection seems to be established
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
#......................................................................#
# Event: event, HTTP GET requests in Meraki MX Security Appliance
    if [msg_mx_group] and ([msg_mx_group]=="urls" and [generic_event]=~/^(src)(.)+/ and "dst" in [generic_event]
	and "mac" in [generic_event] and "request" in [generic_event] ) {
        grok {
 			match => {
 				"generic_event" => [
				"src(\s)?=(\s)?%{IPORHOST:src_ip}(\s)?:(\s)?%{INT:src_port} dst(\s)?=(\s)?%{IPORHOST:dst_ip}(\s)?:(\s)?%{INT:dst_port} mac(\s)?=(\s)?%{GREEDYDATA:client_mac} request(\s)?:(\s)?%{WORD:method} %{GREEDYDATA:url}"
 				]
 			}
 		}
		#Add action field when connection seems to be established
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
	}
#......................................................................#
# Event: flows, IP session initiated in Meraki MX Security Appliance
    if [msg_mx_group] and ([msg_mx_group]=="flows" and [generic_event]=~/^(src)(.)+/ and "dport" in [generic_event]
	and "protocol" in [generic_event] and "sport" in [generic_event] ) {
        grok {
 			match => {
 				"generic_event" => [
				"src(\s)?=(\s)?%{IPORHOST:src_ip} dst(\s)?=(\s)?%{IPORHOST:dst_ip} mac(\s)?=(\s)?%{GREEDYDATA:mac} protocol(\s)?=(\s)?%{DATA:protocol} sport(\s)?=(\s)?%{INT:src_port} dport(\s)?=(\s)?%{INT:dst_port} pattern:%{GREEDYDATA:pattern}",
				"src(\s)?=(\s)?%{IPORHOST:src_ip} dst(\s)?=(\s)?%{IPORHOST:dst_ip} protocol(\s)?=(\s)?%{DATA:protocol} sport(\s)?=(\s)?%{INT:src_port} dport(\s)?=(\s)?%{INT:dst_port} pattern:%{GREEDYDATA:pattern}"
 				]
 			}
 		}
		#Add action field when connection seems to be established
		if [pattern] and ([pattern] =~/^((\s)?(0|allow|Allow))/ ) {
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
		}
	}
#......................................................................#
# Event: ids-alerts, ids signature matched in Meraki MX Security Appliance
    if [msg_mx_group] and ([msg_mx_group]=="ids-alerts" and [generic_event]=~/^(signature)(.)+/ and "priority" in [generic_event]
	and "timestamp" in [generic_event] and "direction" in [generic_event] and "protocol" in [generic_event] ) {
        grok {
 			match => {
 				"generic_event" => [
				"signature(\s)?=(\s)?%{GREEDYDATA:signature} priority(\s)?=(\s)?%{INT:evt_priority} timestamp(\s)?=(\s)?%{GREEDYDATA:irrelevant} direction(\s)?=(\s)?%{WORD:direction} protocol(\s)?=(\s)?%{DATA:protocol} src(\s)?=(\s)?%{IPORHOST:src_ip}(\s)?:(\s)?%{INT:src_port}(%{GREEDYDATA:irrelevant})?"
 				]
 			}
 		}
		#In this case even if the connection was established, the action wasnt created because this event is already detected by alerts
	}
#......................................................................#
# Event: event IPsec-SA request queued due to no phase 1 found, phase2 negotiation failed, initiate new phase 1 negotiation,
# ISAKMP-SA established, initiate new phase 2 negotiation, IPsec-SA established, ISAKMP-SA established, and ISAKMP-SA deleted
# in Meraki MX Security Appliance
# This type of message mx_type=labs_appliance mx_group=events
    if [msg_mx_group] and ([msg_mx_group]=="events" and [generic_event]=~/^(Site)(.)+/ ) {
        grok {
 			match => {
 				"generic_event" => [
				"Site-to-site VPN(\s)?:(\s)?%{GREEDYDATA:irrelevant} (deleted|established) %{IPORHOST:src_ip}(\s)?\[(\s)?%{INT:src_port}(\s)?\](\s)?-(\s)?%{IPORHOST:dst_ip}(\s)?\[(\s)?%{INT:dst_port}(\s)?\] spi(\s)?:(\s)?%{GREEDYDATA:spi}",
				"Site-to-site VPN(\s)?:(\s)?%{GREEDYDATA:irrelevant} request for %{IPORHOST:src_ip} queued due to no %{GREEDYDATA:irrelevant} found",
				"Site-to-site VPN(\s)?:(\s)?%{GREEDYDATA:irrelevant} negotiation failed due to time up waiting for %{GREEDYDATA:irrelevant}.(\s)?ESP %{IPORHOST:src_ip}(\s)?\[(\s)?%{INT:src_port}(\s)?\](\s)?->(\s)?%{IPORHOST:dst_ip}(\s)?\[(\s)?%{INT:dst_port}(\s)?\](%{GREEDYDATA:irrelevant})?",
				"Site-to-site VPN(\s)?:(\s)?%{GREEDYDATA:irrelevant} negotiation(\s)?:(\s)?%{IPORHOST:src_ip}(\s)?\[(\s)?%{INT:src_port}(\s)?\](\s)?<=>(\s)?%{IPORHOST:dst_ip}(\s)?\[(\s)?%{INT:dst_port}(\s)?\](%{GREEDYDATA:irrelevant})?",
				"Site-to-site VPN(\s)?:(\s)?%{GREEDYDATA:irrelevant} established:(\s)?ESP/Tunnel %{IPORHOST:src_ip}(\s)?\[(\s)?%{INT:src_port}(\s)?\](\s)?->(\s)?%{IPORHOST:dst_ip}(\s)?\[(\s)?%{INT:dst_port}(\s)?\] spi(\s)?=(\s)?%{GREEDYDATA:spi}"
 				]
 			}
 		}
		#Add action field when connection seems to be established
		if "queued due to no phase 1" in [generic_event] or "queued due to no phase1" in [generic_event] or "Site-to-site VPN: failed" in [generic_event] {
			#No action
		} else {
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
		}
	}
#......................................................................#
# Event: event spanning-tree guard state change in Meraki MS Switches
    if [msg_mx_group] and ([msg_mx_group]=="events" and [generic_event]=~/^(Port)(.)+/ ) {
        grok {
 			match => {
 				"generic_event" => [
				"Port %{INT:src_port} received an %{DATA:protocol} BPDU from %{GREEDYDATA:mac} so the port was %{GREEDYDATA:mx_action}"
 				]
 			}
 		}
	}
#......................................................................#
# Event: event blocked DHCP server response in Meraki MS Switches
    if [msg_mx_group] and ([msg_mx_group]=="events" and [generic_event]=~/^(Blocked)(.)+/ ) {
        grok {
 			match => {
 				"generic_event" => [
				"Blocked %{DATA:protocol} server response from %{GREEDYDATA:mac} on VLAN %{GREEDYDATA:vlan}"
 				]
 			}
 		}
	}
#......................................................................#
# Event: event 802.1X (all events) in Meraki MS Switches
    if [msg_mx_group] and ([msg_mx_group]=="events" and [generic_event]=~/^(type)(.)+/ and "port" in [generic_event] and "identity" in [generic_event] ){
        grok {
 			match => {
 				"generic_event" => [
				"type(\s)?=(\s)?%{DATA:event_type} port(\s)?=(\s)?(''''|''%{INT:src_port}'') identity(\s)?=(\s)?''%{GREEDYDATA:identity}''(%{GREEDYDATA:irrelevant})?"
 				]
 			}
 		}
		#In this case even if the connection was established, the action wasnt created because dont have any ip address
	}
#......................................................................#
# Event: event 802.11 disassociation in Meraki MR Access Points
    if [msg_mx_group] and ( [msg_mx_group]=="events" and [generic_event]=~/^(type)(.)+/ and "radio" in [generic_event] and "channel" in [generic_event]
	and "auth_neg_dur" in [generic_event] and "last_auth_ago" in [generic_event] ) {
        grok {
 			match => {
 				"generic_event" => [
				"type(\s)?=(\s)?%{DATA:event_type} radio(\s)?=(\s)?''%{INT:radio}'' vap(\s)?=(\s)?''%{INT:vap}'' channel(\s)?=(\s)?''%{INT:channel}'' reason(\s)?=(\s)?''%{GREEDYDATA:reason}'' instigator(\s)?=(\s)?''%{GREEDYDATA:instigator}'' duration(\s)?=(\s)?''%{GREEDYDATA:duration}'' auth_neg_dur(\s)?=(\s)?''%{GREEDYDATA:auth_neg_dur}'' last_auth_ago(\s)?=(\s)?''%{GREEDYDATA:last_auth_ago}'' is_wpa(\s)?=(\s)?''%{GREEDYDATA:is_wpa}'' full_conn(\s)?=(\s)?''%{GREEDYDATA:full_conn}'' ip_resp(\s)?=(\s)?''%{GREEDYDATA:ip_resp}'' ip_src(\s)?=(\s)?''%{GREEDYDATA:src_ip}'' arp_resp(\s)?=(\s)?''%{GREEDYDATA:arp_resp}'' arp_src(\s)?=(\s)?''%{GREEDYDATA:arp_src}'' dns_server(\s)?=(\s)?''%{GREEDYDATA:dns}'' dns_req_rtt(\s)?=(\s)?''%{GREEDYDATA:dns_req_rtt}'' dns_resp(\s)?=(\s)?''%{GREEDYDATA:dns_resp}'' aid(\s)?=(\s)?''%{GREEDYDATA:aid}''"
 				]
 			}
 		}
		#Add action field when connection seems to be established
		mutate {
			add_field => { "[logx][utm][action]" => "Success" }
		}
	}
#......................................................................#
# Event: event 802.1X (all events) in Meraki MR Access Points
    if [msg_mx_group] and ( [msg_mx_group]=="events" and [generic_event]=~/^(type)(.)+/ and "radio" in [generic_event] and "vap" in [generic_event]
	and "identity" in [generic_event] and "aid" in [generic_event] ) {
        grok {
 			match => {
 				"generic_event" => [
				"type(\s)?=(\s)?%{DATA:event_type} radio(\s)?=(\s)?''%{INT:radio}'' vap(\s)?=(\s)?''%{INT:vap}'' identity(\s)?=(\s)?''%{GREEDYDATA:identity}'' aid(\s)?=(\s)?''%{GREEDYDATA:aid}''"
 				]
 			}
 		}
		#In this case even if the connection was established, the action wasnt created because dont have any ip address
	}
#......................................................................#
# Event: event splash authentication in Meraki MR Access Points
    if [msg_mx_group] and ([msg_mx_group]=="events" and [generic_event]=~/^(type)(.)+/ and "ip" in [generic_event] and "vap" in [generic_event]
	and "duration" in [generic_event] and "download" in [generic_event] and "upload" in [generic_event] ) {
        grok {
 			match => {
 				"generic_event" => [
				"type(\s)?=(\s)?%{DATA:event_type} ip(\s)?=(\s)?''%{GREEDYDATA:src_ip}'' duration(\s)?=(\s)?''%{GREEDYDATA:duration}'' vap(\s)?=(\s)?''%{GREEDYDATA:vap}'' download(\s)?=(\s)?''%{GREEDYDATA:download}'' upload(\s)?=(\s)?''%{GREEDYDATA:upload}''"
 				]
 			}
 		}
		#Add action field when connection seems to be established
		mutate {
			add_field => { "[logx][utm][action]" => "Success" }
		}
	}
#......................................................................#
# Event: event wireless packet flood detected in Meraki MR Access Points
    if [msg_mx_group] and ([msg_mx_group]=="events" and [generic_event]=~/^(type)(.)+/ and "packet" in [generic_event] and "device" in [generic_event]
	and "state" in [generic_event] and "alarm_id" in [generic_event] and "dos_count" in [generic_event] ) {
        grok {
 			match => {
 				"generic_event" => [
				"type(\s)?=(\s)?%{DATA:event_type} packet(\s)?=(\s)?''%{GREEDYDATA:packet}'' device(\s)?=(\s)?''%{GREEDYDATA:device}'' radio(\s)?=(\s)?''%{INT:radio}'' state(\s)?=(\s)?''%{GREEDYDATA:state}'' alarm_id(\s)?=(\s)?''%{GREEDYDATA:alarm_id}'' dos_count(\s)?=(\s)?''%{GREEDYDATA:dos_count}'' inter_arrival(\s)?=(\s)?''%{GREEDYDATA:inter_arrival}''"
 				]
 			}
 		}
	}
#......................................................................#
# Event: flows, flow allowed by Layer 3 firewall in Meraki MR Access Points
    if [msg_mx_group] and ([msg_mx_group]=="flows" and [generic_event]=~/^(deny|allow)(.)+/ and "src" in [generic_event] and "dst" in [generic_event]
	and "mac" in [generic_event] and "sport" in [generic_event] and "dport" in [generic_event] ) {
        grok {
 			match => {
 				"generic_event" => [
				"%{WORD:mx_action} src(\s)?=(\s)?%{IPORHOST:src_ip} dst(\s)?=(\s)?%{IPORHOST:dst_ip} mac(\s)?=(\s)?%{GREEDYDATA:mac} protocol(\s)?=(\s)?%{DATA:protocol} sport(\s)?=(\s)?%{INT:src_port} dport(\s)?=(\s)?%{INT:dst_port}"
 				]
 			}
 		}
		#Add action field when connection seems to be established
		if [mx_action] and [mx_action] =~/\b(allow)\b/ {
			mutate {
				add_field => { "[logx][utm][action]" => "Success" }
			}
		}
	}
  }
#......................................................................#
# Event: event rogue SSID detected and SSID spoofing detected in Meraki MR Access Points
# This type of message dont have the header INT.INT mx_type mx_group, so we search for fields
    if (![generic_event] and [meraki_message]) and [meraki_message]=~/^(airmarshal_events)(.)+/ and ("type" in [meraki_message] and "ssid" in [meraki_message]
	and "bssid" in [meraki_message] and "src" in [meraki_message] and "dst" in [meraki_message]
	and (("wired_mac" in [meraki_message]) or ("vap" in [meraki_message] and "rssi" in [meraki_message])) ) {
        grok {
 			match => {
 				"meraki_message" => [
				"airmarshal_events type(\s)?=(\s)?%{DATA:event_type} ssid(\s)?=(\s)?''(%{DATA:ssid})?'' bssid(\s)?=(\s)?''(%{GREEDYDATA:bssid})?'' src(\s)?=(\s)?''(%{GREEDYDATA:src_mac})?'' dst(\s)?=(\s)?''(%{GREEDYDATA:dst_mac})?'' wired_mac(\s)?=(\s)?''(%{GREEDYDATA:wired_mac})?'' vlan_id(\s)?=(\s)?''(%{INT:vlan_id})?'' channel(\s)?=(\s)?''(%{INT:channel})?'' rssi(\s)?=(\s)?''(%{INT:rssi})?'' fc_type(\s)?=(\s)?''(%{INT:fc_type})?'' fc_subtype(\s)?=(\s)?''(%{INT:fc_subtype})?''",
				"airmarshal_events type(\s)?=(\s)?%{DATA:event_type} ssid(\s)?=(\s)?''(%{DATA:ssid})?'' vap(\s)?=(\s)?''(%{INT:vap})?'' bssid(\s)?=(\s)?''(%{GREEDYDATA:bssid})?'' src(\s)?=(\s)?''(%{GREEDYDATA:src_mac})?'' dst(\s)?=(\s)?''(%{GREEDYDATA:dst_mac})?'' channel(\s)?=(\s)?''(%{INT:channel})?'' rssi(\s)?=(\s)?''(%{INT:rssi})?'' fc_type(\s)?=(\s)?''(%{INT:fc_type})?'' fc_subtype(\s)?=(\s)?''(%{INT:fc_subtype})?''"
 				]
 			}
 		}
		#In this case even if the connection was established, the action wasnt created because this event is already detected by alerts
	}
#......................................................................#
# Event: security_event ids_alerted, ids signature matched in Meraki MX Security Appliance
# This type of message dont have the header INT.INT mx_type mx_group, so we search for fields
    if (![generic_event] and [meraki_message]) and ("signature" in [meraki_message] and "priority" in [meraki_message] and "timestamp" in [meraki_message]
    and "dhost" in [meraki_message] and "direction" in [meraki_message] and "protocol" in [meraki_message]
    and "src" in [meraki_message] and "dst" in [meraki_message]) {
        grok {
 			match => {
 				"meraki_message" => [
				"signature(\s)?=(\s)?%{GREEDYDATA:signature} priority(\s)?=(\s)?%{INT:evt_priority} timestamp(\s)?=(\s)?%{DATA:event_time} dhost(\s)?=(\s)?%{GREEDYDATA:mac} direction(\s)?=(\s)?%{WORD:direction} protocol(\s)?=(\s)?%{DATA:protocol} src(\s)?=(\s)?%{IPORHOST:src_ip}(\s)?:(\s)?%{INT:src_port} dst(\s)?=(\s)?%{IPORHOST:dst_ip}(\s)?:(\s)?%{INT:dst_port} message:%{GREEDYDATA:irrelevant}"
 				]
 			}
 		}
		#In this case even if the connection was established, the action wasnt created because this event is already detected by alerts
	}

#Formatting number values
   mutate {
      convert => {
            "src_port" => "integer"
            "dst_port" => "integer"
            "evt_priority" => "integer"
            "priority" => "integer"
            "radio" => "integer"
            "vap" => "integer"
            "channel" => "integer"
			"rssi" => "integer"
			"vlan_id" => "integer"
			"fc_type" => "integer"
			"fc_subtype" => "integer"
        }
   }
#......................................................................#
#First search if some fields are already in the generic message, if not we try to capture from the header of the entire message
#Remember, the header is (something like part of a date) msg_src_ip msg_src_port event_time mx_type mx_group in meraki_message field
#Then add all possible fields to the json tree structure
   if ![src_ip] and [msg_src_ip] {
        mutate { add_field => { "src_ip" => "%{[msg_src_ip]}" }}
		if ![src_port] and [msg_src_port] {
            mutate { add_field => { "src_port" => "%{[msg_src_port]}" }}
        }
   }
   if ![event_time] and [msg_event_time] {
        mutate { add_field => { "event_time" => "%{[msg_event_time]}" }}
   }
   if ![mx_type] and [msg_mx_type] {
        mutate { add_field => { "mx_type" => "%{[msg_mx_type]}" }}
   }
   if ![mx_group] and [msg_mx_group] {
        mutate { add_field => { "mx_group" => "%{[msg_mx_group]}" }}
   }

   mutate {
      rename => { "message" => "[logx][meraki][message]" }
      rename => { "event_time" => "[logx][meraki][event_time]" }
      rename => { "priority" => "[logx][meraki][priority]" }
      rename => { "event_parse_id" => "[logx][meraki][event_parse_id]" }
      rename => { "mx_group" => "[logx][meraki][mx_group]" }
      rename => { "mx_type" => "[logx][meraki][mx_type]" }

      #New fields from event vpn connectivity change
      rename => { "event_type" => "[logx][meraki][event_type]" }
      rename => { "vpn_type" => "[logx][meraki][vpn_type]" }
      rename => { "src_ip" => "[logx][meraki][src_ip]" }
      rename => { "src_port" => "[logx][meraki][src_port]" }
      rename => { "peer_ident" => "[logx][meraki][peer_ident]" }
      rename => { "connectivity" => "[logx][meraki][connectivity]" }
	  rename => { "mx_conn_state" => "[logx][meraki][mx_conn_state]" }

      #New fields from dhcp events
      rename => { "mac" => "[logx][meraki][mac]" }
      rename => { "server_mac" => "[logx][meraki][server_mac]" }
      rename => { "client_mac" => "[logx][meraki][client_mac]" }
      rename => { "router_ip" => "[logx][meraki][router_ip]" }
      rename => { "subnet" => "[logx][meraki][subnet]" }
      rename => { "dns" => "[logx][meraki][dns]" }

      #New fields from event HTTP GET requests in Meraki MX Security Appliance
      rename => { "dst_ip" => "[logx][meraki][dest_ip]" }
      rename => { "dst_port" => "[logx][meraki][dest_port]" }
      rename => { "method" => "[logx][meraki][method]" }
      rename => { "url" => "[logx][meraki][url]" }

      #New fields from flows, IP session initiated
      rename => { "protocol" => "[logx][meraki][proto]" }
	  rename => { "pattern" => "[logx][meraki][pattern]" }

      #New fields from ids-alerts, ids signature matched
      rename => { "signature" => "[logx][meraki][signature]" }
      rename => { "evt_priority" => "[logx][meraki][evt_priority]" }
      rename => { "direction" => "[logx][meraki][direction]" }

      #New fields from events, IPsec-SA and ISAKMP-SA
      rename => { "spi" => "[logx][meraki][spi]" }

      #New fields from events spanning-tree guard state change in Meraki MS Switches
      rename => { "mx_action" => "[logx][meraki][mx_action]" }

      #New fields from events blocked DHCP server response in Meraki MS Switches
      rename => { "vlan" => "[logx][meraki][vlan]" }

      #New fields from events 802.1X (all events) in Meraki MS Switches
      rename => { "identity" => "[logx][meraki][identity]" }

      #New fields from events 802.11 disassociation in Meraki MR Access Points
      rename => { "radio" => "[logx][meraki][radio]" }
      rename => { "vap" => "[logx][meraki][vap]" }
      rename => { "channel" => "[logx][meraki][channel]" }
      rename => { "instigator" => "[logx][meraki][instigator]" }
      rename => { "auth_neg_dur" => "[logx][meraki][auth_neg_dur]" }
      rename => { "last_auth_ago" => "[logx][meraki][last_auth_ago]" }
      rename => { "is_wpa" => "[logx][meraki][is_wpa]" }
      rename => { "full_conn" => "[logx][meraki][full_conn]" }
      rename => { "ip_resp" => "[logx][meraki][ip_resp]" }
      rename => { "arp_resp" => "[logx][meraki][arp_resp]" }
      rename => { "arp_src" => "[logx][meraki][arp_src]" }
      rename => { "dns_req_rtt" => "[logx][meraki][dns_req_rtt]" }
      rename => { "dns_resp" => "[logx][meraki][dns_resp]" }
      rename => { "aid" => "[logx][meraki][aid]" }
      rename => { "reason" => "[logx][meraki][reason]" }
      rename => { "duration" => "[logx][meraki][duration]" }

      #New fields from events splash authentication in Meraki MR Access Points
      rename => { "download" => "[logx][meraki][download]" }
      rename => { "upload" => "[logx][meraki][upload]" }

      #New fields from event wireless packet flood detected in Meraki MR Access Points
      rename => { "packet" => "[logx][meraki][packet]" }
      rename => { "device" => "[logx][meraki][device]" }
      rename => { "state" => "[logx][meraki][state]" }
      rename => { "alarm_id" => "[logx][meraki][alarm_id]" }
      rename => { "dos_count" => "[logx][meraki][dos_count]" }
      rename => { "inter_arrival" => "[logx][meraki][inter_arrival]" }

      #New fields from event rogue SSID detected and SSID spoofing detected in Meraki MR Access Points
      rename => { "ssid" => "[logx][meraki][ssid]" }
      rename => { "bssid" => "[logx][meraki][bssid]" }
      rename => { "src_mac" => "[logx][meraki][src_mac]" }
      rename => { "dst_mac" => "[logx][meraki][dst_mac]" }
      rename => { "rssi" => "[logx][meraki][rssi]" }
      rename => { "fc_type" => "[logx][meraki][fc_type]" }
      rename => { "fc_subtype" => "[logx][meraki][fc_subtype]" }
      rename => { "vlan_id" => "[logx][meraki][vlan_id]" }
      rename => { "wired_mac" => "[logx][meraki][wired_mac]" }
   }

   #Finally, remove unnecessary fields
   mutate {
      remove_field => ["@version","fecha","path","meraki_msg_init","irrelevant","tags","msg_src_ip","msg_src_port",
	  "msg_event_time","msg_mx_type","msg_mx_group","generic_event","meraki_message","ciscoDataSource"]
   }
   }
   #Also, remove unwanted fields if the message not match with conditions
   mutate {
      remove_field => ["original_log_message","headers"]
   }
}
'
WHERE id=302;
----------------------------------------------------------------------------------------------------------------------------------------
-- DECEPTIVE_BYTES  --
----------------------------------------------------------------------------------------------------------------------------------------
UPDATE utm_logstash_filter
SET filter_version='2.0.1',logstash_filter='filter {

    split {
      field => "message"
      terminator => "<utm-log-separator>"
    }

    #Looking for datasource generated by an agent and parse original message
    if [message]=~/\[utm_stack_agent_ds=(.+)\]-(.+)/ {
      grok {
        match => {
          "message" => [ "\[utm_stack_agent_ds=%{DATA:dataSource}\]-%{GREEDYDATA:original_log_message}" ]
        }
      }
    }
    if [original_log_message] {
      mutate {
        update => { "message" => "%{[original_log_message]}" }
      }
    }


    # Filter version 2.0.1
    # If syslog format parse the structure

      if [message] {
        grok {
            match => {
                "message" => [

                    "%{GREEDYDATA:tsp} %{IPORHOST:h_h} %{USERNAME:l_u}: %{USERNAME:user}user%{LOGLEVEL:severity}CEF:%{WORD:cef}\W%{WORD:d} %{WORD:b}\W%{GREEDYDATA:message_text}filePath=%{GREEDYDATA:filePath} fileHash=%{GREEDYDATA:fileHash} cs1=%{DATA:cs1} cs2=%{GREEDYDATA:cs2}",
                    "%{GREEDYDATA:tsp} %{IPORHOST:h_h} %{USERNAME:l_u}: user%{WORD:severity}%{SPACE}CEF:%{WORD:cef}\W%{WORD:d} %{WORD:b}\W%{GREEDYDATA:message_text}cat=%{DATA:cat} src=%{IP:src_ip} requestMethod=%{DATA:requestMethod} requestClientApplication=%{DATA:requestClientApplication} act=%{DATA:act} proto=%{DATA:protocol} app=%{DATA:app} reason=%{GREEDYDATA:reason} spt=%{NUMBER:spt} request=%{GREEDYDATA:request}"
                ]
            }
        }
      }


     # Check if tecnology is Deceptive Bytes

     if ([d] and [b]) and ([d] == "Deceptive" and [b] == "Bytes"){
        mutate {
            add_field => {
            "dataType" => "deceptive-bytes"
            }
        }
        #Evaluates to the host variable if can not be calculated
        if ![dataSource] {
         mutate {
            rename => {
            "host" => "dataSource"
            }
         }
        }
        if [request] {
            mutate {
                rename => {
                    "request" => "[logx][deceptive_bytes][request]"
                }
            }
        }
        if [spt] {
            mutate {
                rename => {
                    "spt" => "[logx][deceptive_bytes][spt]"
                }
            }
        }
        if [reason] {
            mutate {
                rename => {
                    "reason" => "[logx][deceptive_bytes][reason]"
                }
            }
        }
        if [app] {
            mutate {
                rename => {
                    "app" => "[logx][deceptive_bytes][app]"
                }
            }
        }
        if [protocol] {
            mutate {
                rename => {
                    "protocol" => "[logx][deceptive_bytes][protocol]"
                }
            }
        }
        if [act] {
            mutate {
                rename => {
                    "act" => "[logx][deceptive_bytes][act]"
                }
            }
        }
        if [requestClientApplication] {
            mutate {
                rename => {
                    "requestClientApplication" => "[logx][deceptive_bytes][requestClientApplication]"
                }
            }
        }
        if [requestMethod] {
            mutate {
                rename => {
                    "requestMethod" => "[logx][deceptive_bytes][requestMethod]"
                }
            }
        }
        if [src_ip] {
            mutate {
                rename => {
                    "src_ip" => "[logx][deceptive_bytes][src_ip]"
                }
            }
        }
        if [cat] {
            mutate {
                rename => {
                    "cat" => "[logx][deceptive_bytes][cat]"
                }
            }
        }
        if [tegnology] {
            mutate {
                rename => {
                    "tegnology" => "[logx][deceptive_bytes][cs2]"
                }
            }
        }
        if [cs2]{
            mutate {
                rename => {
                    "cs2" => "[logx][deceptive_bytes][cs2]"
                }
            }
        }
        if [cs1]{
            mutate {
                rename => {
                    "cs1" => "[logx][deceptive_bytes][cs1]"
                }
            }
        }
        if [fileHash]{
            mutate {
                rename => {
                    "fileHash" => "[logx][deceptive_bytes][fileHash]"
                }
            }
        }
        if [filePath]{
            mutate {
                rename => {
                    "filePath" => "[logx][deceptive_bytes][filePath]"
                }
            }
        }
        if [message_text]{
            mutate {
                rename => {
                    "message_text" => "[logx][deceptive_bytes][message_text]"
                }
            }
        }
        if [cef]{
            mutate {
                rename => {
                    "cef" => "[logx][deceptive_bytes][cef]"
                }
            }
        }
        if [severity]{
            mutate {
                rename => {
                    "severity" => "[logx][deceptive_bytes][severityLabel]"
                }
            }
        }
        if [user]{
            mutate {
                rename => {
                    "user" => "[logx][deceptive_bytes][user]"
                }
            }
        }
        if [server]{
            mutate {
                rename => {
                    "server" => "[logx][deceptive_bytes][server]"
                }
            }
        }


        mutate {
            remove_field => ["@version","path","d","b","timestamp","tags","h_i","i_u","tsp","type"]
        }
    }
   #Also, remove unwanted fields if the message not match with conditions
   mutate {
      remove_field => ["original_log_message","headers"]
   }
}
'
WHERE id=1512;
----------------------------------------------------------------------------------------------------------------------------------------
-- APACHE  --
----------------------------------------------------------------------------------------------------------------------------------------
UPDATE utm_logstash_filter
SET filter_version='2.0.1',logstash_filter='filter {
  #Fields based on https://github.com/logstash-plugins/logstash-patterns-core/blob/main/patterns/legacy/httpd (february 2022)
  #and https://docs.trafficserver.apache.org/en/9.0.x/admin-guide/logging/examples.en.html#admin-logging-examples-netscape
  #and https://www.elastic.co/guide/en/beats/filebeat/7.13/filebeat-module-apache.html
  #and https://httpd.apache.org/docs/2.2/logs.html
  #and filebeat fields.yml version 7.13.4 oss

  #Filebeat apache, apache2 module, version 2.0.1
  #Filter Input requirements -> fileset: datatype
  #                access: plain text
  #                error: plain text

  split {
    field => "message"
    terminator => "<utm-log-separator>"
  }
  json {
    source => "message"
  }

  if ([event][module] and [event][module] == "apache")
  or ([service][type] and [service][type] == "apache")
  or ([event][module] and [event][module] == "apache2")
  or ([service][type] and [service][type] == "apache2") {
    #Generating dataType and dataSource fields
        mutate {
            add_field => { "dataSource" => "%{[host][hostname]}" }
        }
    if [event][module] {
        mutate {
            add_field => { "dataType" => "%{[event][module]}" }
        }
    } else if [service][type] {
        mutate {
            add_field => { "dataType" => "%{[service][type]}" }
        }
    }

    #......................................................................#
    #Parse message field, the first two regexp for acces and the last for error
    if [message] {
        grok {
          match => {
              "message" => [
              "%{COMMONAPACHELOG}","%{COMBINEDAPACHELOG}","%{COMMONAPACHELOG} %{GREEDYDATA:irrelevant}","%{COMBINEDAPACHELOG}  %{GREEDYDATA:irrelevant}",
              "%{IPORHOST:clientip} %{HTTPDUSER:ident} %{HTTPDUSER:auth} \[%{HTTPDATE:timestamp}\] \"(?:%{WORD:verb} %{NOTSPACE:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})\"(\s)?(%{NUMBER:response})?(\s)?(?:%{NUMBER:bytes}|-)?",
              "\[%{GREEDYDATA:timestamp}\]%{SPACE}\[%{WORD:severity}\]%{SPACE}\[(client%{SPACE})?%{IPORHOST:clientip}\] %{GREEDYDATA:msg}"
              ]
          }
        }
    }
    #......................................................................#
    #Formatting number values
    if [bytes] {
        mutate { convert => { "bytes" => "integer" } }
    }
    if [response] {
        mutate { convert => { "response" => "integer" } }
    }
    #......................................................................#
    #Then add all possible fields to the json tree structure

        mutate {
            #General fields from ECS
            rename => { "host" => "[logx][apache][host]" }
            rename => { "service" => "[logx][apache][service]" }
            rename => { "ecs" => "[logx][apache][ecs]" }
            rename => { "agent" => "[logx][apache][agent]" }
            rename => { "fileset" => "[logx][apache][fileset]" }
            rename => { "event" => "[logx][apache][event]" }
            rename => { "input" => "[logx][apache][input]" }
            rename => { "labels" => "[logx][apache][labels]" }
            rename => { "as" => "[logx][apache][as]" }
            rename => { "client" => "[logx][apache][client]" }
            rename => { "cloud" => "[logx][apache][cloud]" }
            rename => { "code_signature" => "[logx][apache][code_signature]" }
            rename => { "container" => "[logx][apache][container]" }
            rename => { "destination" => "[logx][apache][destination]" }
            rename => { "dll" => "[logx][apache][dll]" }
            rename => { "dns" => "[logx][apache][dns]" }
            rename => { "error" => "[logx][apache][error]" }
            rename => { "file" => "[logx][apache][file]" }
            rename => { "geo" => "[logx][apache][geo]" }
            rename => { "hash" => "[logx][apache][hash]" }
            rename => { "http" => "[logx][apache][http]" }
            rename => { "interface" => "[logx][apache][interface]" }
            rename => { "network" => "[logx][apache][network]" }
            rename => { "observer" => "[logx][apache][observer]" }
            rename => { "organization" => "[logx][apache][organization]" }
            rename => { "package" => "[logx][apache][package]" }
            rename => { "pe" => "[logx][apache][pe]" }
            rename => { "process" => "[logx][apache][process]" }
            rename => { "registry" => "[logx][apache][registry]" }
            rename => { "related" => "[logx][apache][related]" }
            rename => { "rule" => "[logx][apache][rule]" }
            rename => { "server" => "[logx][apache][server]" }
            rename => { "source" => "[logx][apache][source]" }
            rename => { "threat" => "[logx][apache][threat]" }
            rename => { "tls" => "[logx][apache][tls]" }
            rename => { "span.id" => "[logx][apache][span.id]" }
            rename => { "trace.id" => "[logx][apache][trace.id]" }
            rename => { "transaction.id" => "[logx][apache][transaction.id]" }
            rename => { "url" => "[logx][apache][url]" }
            rename => { "user" => "[logx][apache][user]" }
            rename => { "vlan" => "[logx][apache][vlan]" }
            rename => { "vulnerability" => "[logx][apache][vulnerability]" }
            rename => { "x509" => "[logx][apache][x509]" }

            #Fields from apache module
            rename => { "[apache][access]" => "[logx][apache][access]" }
            rename => { "[apache][error]" => "[logx][apache][error]" }
            rename => { "[apache2][access]" => "[logx][apache2][access]" }
            rename => { "[apache2][error]" => "[logx][apache2][error]" }


            #Fields from apache message
            rename => { "httpversion" => "[logx][apache][httpversion]" }
            rename => { "verb" => "[logx][apache][method]" }
            rename => { "response" => "[logx][apache][response]" }
            rename => { "bytes" => "[logx][apache][bytes]" }
            rename => { "clientip" => "[logx][apache][src_ip]" }
            rename => { "timestamp" => "[logx][apache][client_request_timestamp]" }
            rename => { "auth" => "[logx][apache][auth]" }
            rename => { "ident" => "[logx][apache][ident]" }
            rename => { "request" => "[logx][apache][request]" }
            rename => { "rawrequest" => "[logx][apache][rawrequest]" }
            rename => { "referrer" => "[logx][apache][referrer]" }
            rename => { "message" => "[logx][apache][message]" }
            rename => { "msg" => "[logx][apache][msg]" }
            rename => { "severity" => "[logx][apache][severity]" }

        }

    #Finally, remove unnecessary fields
        mutate {
            remove_field => ["@version","path","tags","log","irrelevant"]
        }

  }
   #Also, remove unwanted fields if the message not match with conditions
   mutate {
      remove_field => ["headers"]
   }
}
'
WHERE id=1412;
----------------------------------------------------------------------------------------------------------------------------------------
-- AUDITD  --
----------------------------------------------------------------------------------------------------------------------------------------
UPDATE utm_logstash_filter
SET filter_version='2.0.1',logstash_filter='filter {
  #Fields based on https://www.elastic.co/guide/en/beats/filebeat/7.13/filebeat-module-auditd.html (february 2022)
  #https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/security_guide/sec-understanding_audit_log_files (february 2022)
  #https://linux.die.net/man/5/auditd.conf (february 2022)
  #and filebeat fields.yml version 7.13.4 oss
  #As the docs says this module work with one event per line, filebeat must ensure to send one event per line.

  #Filebeat auditd module, version 2.0.1
  #Filter Input requirements -> fileset: datatype
  #                             log: plain text

  split {
    field => "message"
    terminator => "<utm-log-separator>"
  }
  json {
    source => "message"
  }

  if ([event][module] and [event][module] == "auditd") or ([service][type] and [service][type] == "auditd") {
    #Generating dataType and dataSource fields
        mutate {
            add_field => { "dataSource" => "%{[host][hostname]}" }
        }
    if [event][module] {
        mutate {
            add_field => { "dataType" => "%{[event][module]}" }
        }
    } else if [service][type] {
        mutate {
            add_field => { "dataType" => "%{[service][type]}" }
        }
    }
    #......................................................................#
    #Then add all possible fields to the json tree structure

        #Fields from module
        mutate {
            rename => { "auditd" => "[logx][auditd]" }
        }
        mutate {
        #General fields from ECS
            rename => { "host" => "[logx][auditd][host]" }
            rename => { "service" => "[logx][auditd][service]" }
            rename => { "ecs" => "[logx][auditd][ecs]" }
            rename => { "agent" => "[logx][auditd][agent]" }
            rename => { "fileset" => "[logx][auditd][fileset]" }
            rename => { "event" => "[logx][auditd][event]" }
            rename => { "input" => "[logx][auditd][input]" }
            rename => { "labels" => "[logx][auditd][labels]" }
            rename => { "as" => "[logx][auditd][as]" }
            rename => { "client" => "[logx][auditd][client]" }
            rename => { "cloud" => "[logx][auditd][cloud]" }
            rename => { "code_signature" => "[logx][auditd][code_signature]" }
            rename => { "container" => "[logx][auditd][container]" }
            rename => { "destination" => "[logx][auditd][destination]" }
            rename => { "dll" => "[logx][auditd][dll]" }
            rename => { "dns" => "[logx][auditd][dns]" }
            rename => { "error" => "[logx][auditd][error]" }
            rename => { "file" => "[logx][auditd][file]" }
            rename => { "geo" => "[logx][auditd][geo]" }
            rename => { "hash" => "[logx][auditd][hash]" }
            rename => { "http" => "[logx][auditd][http]" }
            rename => { "interface" => "[logx][auditd][interface]" }
            rename => { "network" => "[logx][auditd][network]" }
            rename => { "observer" => "[logx][auditd][observer]" }
            rename => { "organization" => "[logx][auditd][organization]" }
            rename => { "package" => "[logx][auditd][package]" }
            rename => { "pe" => "[logx][auditd][pe]" }
            rename => { "process" => "[logx][auditd][process]" }
            rename => { "registry" => "[logx][auditd][registry]" }
            rename => { "related" => "[logx][auditd][related]" }
            rename => { "rule" => "[logx][auditd][rule]" }
            rename => { "server" => "[logx][auditd][server]" }
            rename => { "source" => "[logx][auditd][source]" }
            rename => { "threat" => "[logx][auditd][threat]" }
            rename => { "tls" => "[logx][auditd][tls]" }
            rename => { "span.id" => "[logx][auditd][span.id]" }
            rename => { "trace.id" => "[logx][auditd][trace.id]" }
            rename => { "transaction.id" => "[logx][auditd][transaction.id]" }
            rename => { "url" => "[logx][auditd][url]" }
            rename => { "user" => "[logx][auditd][user]" }
            rename => { "vlan" => "[logx][auditd][vlan]" }
            rename => { "vulnerability" => "[logx][auditd][vulnerability]" }
            rename => { "x509" => "[logx][auditd][x509]" }

            #Rename message field to add it to the structure
            rename => { "message" => "[logx][auditd][message]" }

        }
        #......................................................................#
        #Finally, remove unnecessary fields
        mutate {
            remove_field => ["@version","tags","log","irrelevant"]
        }
  }
   #Also, remove unwanted fields if the message not match with conditions
   mutate {
      remove_field => ["headers"]
   }
}
'
WHERE id=1411;
----------------------------------------------------------------------------------------------------------------------------------------
-- ELASTICSEARCH  --
----------------------------------------------------------------------------------------------------------------------------------------
UPDATE utm_logstash_filter
SET filter_version='2.0.1',logstash_filter='filter {
  #Fields based on https://www.elastic.co/guide/en/beats/filebeat/7.13/filebeat-module-elasticsearch.html (february 2022)
  #and filebeat fields.yml version 7.13.4 oss

  #Filebeat elasticsearch module, version 2.0.1
  #Support logs from elasticsearch 7++
  #Filter Input requirements -> fileset: datatype
  #                             server: json
  #                             audit: json
  #                             deprecation: json
  #                             slowlog: json
  #                             gc: plain text
  #Logs comming from (server, audit, deprecation and slowlog) must be in json format, docummented in url above

  split {
    field => "message"
    terminator => "<utm-log-separator>"
  }
  json {
    source => "message"
  }

  if ([event][module] and [event][module] == "elasticsearch")
  or ([service][type] and [service][type] == "elasticsearch") {
    #Generating dataType and dataSource fields
        mutate {
            add_field => { "dataSource" => "%{[host][hostname]}" }
        }
    if [event][module] {
        mutate {
            add_field => { "dataType" => "%{[event][module]}" }
        }
    } else if [service][type] {
        mutate {
            add_field => { "dataType" => "%{[service][type]}" }
        }
    }


    #......................................................................#
    #Adding JSON files support, except for gc because is plain log format
    if [event][dataset] and [event][dataset] == "elasticsearch.gc" {
    #......................................................................#
    #Parse message field, for elasticsearch gc
      if [message] {
        grok {
          match => {
              "message" => [
              "\[%{TIMESTAMP_ISO8601:timestamp}\]\[%{DATA:level}%{SPACE}\]\[%{DATA:component}%{SPACE}\]%{SPACE}(?<general_message>(.|\r|\n)*)"
              ]
          }
        }
      }
      if [level] {
        mutate {
            #Change meaning of the second field
            rename => { "level" => "pid" }
        }
      }
    }else {
      if [message] {
         json {
           source => "message"
           target => "elasticsearch"
         }
      }
    }
    #......................................................................#
    #Formatting number values for gc
      if [pid] {
        mutate {
          convert => {
            "pid" => "integer"
          }
        }
      }
    #......................................................................#
    #Then add all possible fields to the json tree structure

        mutate {
            #General fields from ECS
            rename => { "host" => "[logx][elasticsearch][host]" }
            rename => { "service" => "[logx][elasticsearch][service]" }
            rename => { "ecs" => "[logx][elasticsearch][ecs]" }
            rename => { "agent" => "[logx][elasticsearch][agent]" }
            rename => { "fileset" => "[logx][elasticsearch][fileset]" }
            rename => { "event" => "[logx][elasticsearch][event]" }
            rename => { "input" => "[logx][elasticsearch][input]" }
            rename => { "labels" => "[logx][elasticsearch][labels]" }
            rename => { "as" => "[logx][elasticsearch][as]" }
            rename => { "client" => "[logx][elasticsearch][client]" }
            rename => { "cloud" => "[logx][elasticsearch][cloud]" }
            rename => { "code_signature" => "[logx][elasticsearch][code_signature]" }
            rename => { "container" => "[logx][elasticsearch][container]" }
            rename => { "destination" => "[logx][elasticsearch][destination]" }
            rename => { "dll" => "[logx][elasticsearch][dll]" }
            rename => { "dns" => "[logx][elasticsearch][dns]" }
            rename => { "error" => "[logx][elasticsearch][error]" }
            rename => { "file" => "[logx][elasticsearch][file]" }
            rename => { "geo" => "[logx][elasticsearch][geo]" }
            rename => { "hash" => "[logx][elasticsearch][hash]" }
            rename => { "http" => "[logx][elasticsearch][http]" }
            rename => { "interface" => "[logx][elasticsearch][interface]" }
            rename => { "network" => "[logx][elasticsearch][network]" }
            rename => { "observer" => "[logx][elasticsearch][observer]" }
            rename => { "organization" => "[logx][elasticsearch][organization]" }
            rename => { "package" => "[logx][elasticsearch][package]" }
            rename => { "pe" => "[logx][elasticsearch][pe]" }
            rename => { "process" => "[logx][elasticsearch][process]" }
            rename => { "registry" => "[logx][elasticsearch][registry]" }
            rename => { "related" => "[logx][elasticsearch][related]" }
            rename => { "rule" => "[logx][elasticsearch][rule]" }
            rename => { "server" => "[logx][elasticsearch][server]" }
            rename => { "source" => "[logx][elasticsearch][source]" }
            rename => { "threat" => "[logx][elasticsearch][threat]" }
            rename => { "tls" => "[logx][elasticsearch][tls]" }
            rename => { "span.id" => "[logx][elasticsearch][span.id]" }
            rename => { "trace.id" => "[logx][elasticsearch][trace.id]" }
            rename => { "transaction.id" => "[logx][elasticsearch][transaction.id]" }
            rename => { "url" => "[logx][elasticsearch][url]" }
            rename => { "user" => "[logx][elasticsearch][user]" }
            rename => { "vlan" => "[logx][elasticsearch][vlan]" }
            rename => { "vulnerability" => "[logx][elasticsearch][vulnerability]" }
            rename => { "x509" => "[logx][elasticsearch][x509]" }

            #Fields from elasticsearch module
            rename => { "elasticsearch" => "[logx][elasticsearch]" }
            rename => { "message" => "[logx][elasticsearch][message]" }

            #Fields from elasticsearch logs
            rename => { "timestamp" => "[logx][elasticsearch][timestamp]" }
            rename => { "level" => "[logx][elasticsearch][level]" }
            rename => { "component" => "[logx][elasticsearch][component]" }
            rename => { "node.name" => "[logx][elasticsearch][node.name]" }
            rename => { "index.name" => "[logx][elasticsearch][index.name]" }

            #Fields from elasticsearch gc logs
            rename => { "pid" => "[logx][elasticsearch][pid]" }
        }

    #Finally, remove unnecessary fields
        mutate {
            remove_field => ["@version","path","tags","log","irrelevant","general_message"]
        }

  }
   #Also, remove unwanted fields if the message not match with conditions
   mutate {
      remove_field => ["headers"]
   }
}
'
WHERE id=1410;
----------------------------------------------------------------------------------------------------------------------------------------
-- KAFKA  --
----------------------------------------------------------------------------------------------------------------------------------------
UPDATE utm_logstash_filter
SET filter_version='2.0.1',logstash_filter='filter {
  #Fields based on https://www.elastic.co/guide/en/beats/filebeat/7.13/filebeat-module-kafka.html (february 2022)
  #https://www.elastic.co/guide/en/beats/filebeat/7.13/exported-fields-kafka.html (february 2022)
  #https://kafka.apache.org/documentation/ version kafka_2.13-3.1.0 (february 2022)
  #and filebeat fields.yml version 7.13.4 oss
  #As the docs says this module work with one event per line, filebeat must ensure to send one event per line.

  #Filebeat kafka module, version 2.0.1
  #Filter Input requirements -> fileset: datatype
  #                             log: plain text
  #log: any kind of kafka logs, like: server, controller, log-cleaner and so on

  split {
    field => "message"
    terminator => "<utm-log-separator>"
  }
  json {
    source => "message"
  }

  if ([event][module] and [event][module] == "kafka")
  or ([service][type] and [service][type] == "kafka") {
    #Generating dataType and dataSource fields
        mutate {
            add_field => { "dataSource" => "%{[host][hostname]}" }
        }
    if [event][module] {
        mutate {
            add_field => { "dataType" => "%{[event][module]}" }
        }
    } else if [service][type] {
        mutate {
            add_field => { "dataType" => "%{[service][type]}" }
        }
    }
    #......................................................................#
    #Parse message field in plain text format
      if [message] {
        grok {
          match => {
              "message" => [
              "\[%{DATA:timestamp}\]%{SPACE}%{WORD:level}%{SPACE}(\[%{DATA:component}\])?(:|,)?%{SPACE}%{GREEDYDATA:msg}%{SPACE}\(%{DATA:class}\)$"
              ]
          }
        }
      }
    #......................................................................#
    #Then add all possible fields to the json tree structure

        #Fields from kafka plain logs
        mutate {
            #Fields from logs
            rename => { "timestamp" => "[logx][kafka][timestamp]" }
            rename => { "level" => "[logx][kafka][level]" }
            rename => { "component" => "[logx][kafka][component]" }
            rename => { "msg" => "[logx][kafka][msg]" }
            rename => { "class" => "[logx][kafka][class]" }

            #Adding message field
            rename => { "message" => "[logx][kafka][message]" }

            #Adding fields from module
            rename => { "kafka" => "[logx][kafka]" }

        }
        mutate {
        #General fields from ECS
            rename => { "host" => "[logx][kafka][host]" }
            rename => { "service" => "[logx][kafka][service]" }
            rename => { "ecs" => "[logx][kafka][ecs]" }
            rename => { "agent" => "[logx][kafka][agent]" }
            rename => { "fileset" => "[logx][kafka][fileset]" }
            rename => { "event" => "[logx][kafka][event]" }
            rename => { "input" => "[logx][kafka][input]" }
            rename => { "labels" => "[logx][kafka][labels]" }
            rename => { "as" => "[logx][kafka][as]" }
            rename => { "client" => "[logx][kafka][client]" }
            rename => { "cloud" => "[logx][kafka][cloud]" }
            rename => { "code_signature" => "[logx][kafka][code_signature]" }
            rename => { "container" => "[logx][kafka][container]" }
            rename => { "destination" => "[logx][kafka][destination]" }
            rename => { "dll" => "[logx][kafka][dll]" }
            rename => { "dns" => "[logx][kafka][dns]" }
            rename => { "error" => "[logx][kafka][error]" }
            rename => { "file" => "[logx][kafka][file]" }
            rename => { "geo" => "[logx][kafka][geo]" }
            rename => { "hash" => "[logx][kafka][hash]" }
            rename => { "http" => "[logx][kafka][http]" }
            rename => { "interface" => "[logx][kafka][interface]" }
            rename => { "network" => "[logx][kafka][network]" }
            rename => { "observer" => "[logx][kafka][observer]" }
            rename => { "organization" => "[logx][kafka][organization]" }
            rename => { "package" => "[logx][kafka][package]" }
            rename => { "pe" => "[logx][kafka][pe]" }
            rename => { "process" => "[logx][kafka][process]" }
            rename => { "registry" => "[logx][kafka][registry]" }
            rename => { "related" => "[logx][kafka][related]" }
            rename => { "rule" => "[logx][kafka][rule]" }
            rename => { "server" => "[logx][kafka][server]" }
            rename => { "source" => "[logx][kafka][source]" }
            rename => { "threat" => "[logx][kafka][threat]" }
            rename => { "tls" => "[logx][kafka][tls]" }
            rename => { "span.id" => "[logx][kafka][span.id]" }
            rename => { "trace.id" => "[logx][kafka][trace.id]" }
            rename => { "transaction.id" => "[logx][kafka][transaction.id]" }
            rename => { "url" => "[logx][kafka][url]" }
            rename => { "user" => "[logx][kafka][user]" }
            rename => { "vlan" => "[logx][kafka][vlan]" }
            rename => { "vulnerability" => "[logx][kafka][vulnerability]" }
            rename => { "x509" => "[logx][kafka][x509]" }

        }
        #......................................................................#
        #Finally, remove unnecessary fields
        mutate {
            remove_field => ["@version","tags","log","irrelevant"]
        }
  }
   #Also, remove unwanted fields if the message not match with conditions
   mutate {
      remove_field => ["headers"]
   }
}
'
WHERE id=1409;
----------------------------------------------------------------------------------------------------------------------------------------
-- KIBANA  --
----------------------------------------------------------------------------------------------------------------------------------------
UPDATE utm_logstash_filter
SET filter_version='2.0.1',logstash_filter='filter {
  #Fields based on https://www.elastic.co/guide/en/beats/filebeat/7.13/filebeat-module-kibana.html (february 2022)
  #and filebeat fields.yml version 7.13.4 oss
  #As the docs says this module work with one event per line, filebeat must ensure to send one event per line.

  #Filebeat kibana module, version 2.0.1
  #This version support only json input files
  #Filter Input requirements -> fileset: datatype
  #                             log: json
  #                             audit: json
  #Kibana by default logs to elastic index, so to log to file, must configure logging appenders and xpack.security.audit.appender in kibana.yml

  split {
    field => "message"
    terminator => "<utm-log-separator>"
  }
  json {
    source => "message"
  }

  if ([event][module] and [event][module] == "kibana") or ([service][type] and [service][type] == "kibana") {
    #Generating dataType and dataSource fields
        mutate {
            add_field => { "dataSource" => "%{[host][hostname]}" }
        }
    if [event][module] {
        mutate {
            add_field => { "dataType" => "%{[event][module]}" }
        }
    } else if [service][type] {
        mutate {
            add_field => { "dataType" => "%{[service][type]}" }
        }
    }
    #......................................................................#
    #Adding only JSON files support, plain logs are not supported
    if [message] {
      json {
        source => "message"
        target => "msg_fields"
      }
    }
    #......................................................................#
    #Change kibana fields generated, are already in target field and duplicated in kibana field by default
    #Then delete from the output
      mutate {
            rename => { "kibana" => "kibana_audit_temps" }
      }
    #......................................................................#
    #Then add all possible fields to the json tree structure

        mutate {
            #General fields from ECS
            rename => { "host" => "[logx][kibana][host]" }
            rename => { "service" => "[logx][kibana][service]" }
            rename => { "ecs" => "[logx][kibana][ecs]" }
            rename => { "agent" => "[logx][kibana][agent]" }
            rename => { "fileset" => "[logx][kibana][fileset]" }
            rename => { "event" => "[logx][kibana][event]" }
            rename => { "input" => "[logx][kibana][input]" }
            rename => { "labels" => "[logx][kibana][labels]" }
            rename => { "as" => "[logx][kibana][as]" }
            rename => { "client" => "[logx][kibana][client]" }
            rename => { "cloud" => "[logx][kibana][cloud]" }
            rename => { "code_signature" => "[logx][kibana][code_signature]" }
            rename => { "container" => "[logx][kibana][container]" }
            rename => { "destination" => "[logx][kibana][destination]" }
            rename => { "dll" => "[logx][kibana][dll]" }
            rename => { "dns" => "[logx][kibana][dns]" }
            rename => { "error" => "[logx][kibana][error]" }
            rename => { "file" => "[logx][kibana][file]" }
            rename => { "geo" => "[logx][kibana][geo]" }
            rename => { "hash" => "[logx][kibana][hash]" }
            rename => { "http" => "[logx][kibana][http]" }
            rename => { "interface" => "[logx][kibana][interface]" }
            rename => { "network" => "[logx][kibana][network]" }
            rename => { "observer" => "[logx][kibana][observer]" }
            rename => { "organization" => "[logx][kibana][organization]" }
            rename => { "package" => "[logx][kibana][package]" }
            rename => { "pe" => "[logx][kibana][pe]" }
            rename => { "process" => "[logx][kibana][process]" }
            rename => { "registry" => "[logx][kibana][registry]" }
            rename => { "related" => "[logx][kibana][related]" }
            rename => { "rule" => "[logx][kibana][rule]" }
            rename => { "server" => "[logx][kibana][server]" }
            rename => { "source" => "[logx][kibana][source]" }
            rename => { "threat" => "[logx][kibana][threat]" }
            rename => { "tls" => "[logx][kibana][tls]" }
            rename => { "span.id" => "[logx][kibana][span.id]" }
            rename => { "trace.id" => "[logx][kibana][trace.id]" }
            rename => { "transaction.id" => "[logx][kibana][transaction.id]" }
            rename => { "url" => "[logx][kibana][url]" }
            rename => { "user" => "[logx][kibana][user]" }
            rename => { "vlan" => "[logx][kibana][vlan]" }
            rename => { "vulnerability" => "[logx][kibana][vulnerability]" }
            rename => { "x509" => "[logx][kibana][x509]" }

        }
        mutate{
            #Fields from kibana module
            rename => { "message" => "[logx][kibana][message]" }

            #This fields comming from json logs
            rename => { "[json]" => "[logx][kibana]" }

            #Then rename fields from audit json fields
            rename => { "msg_fields" => "[logx][kibana]" }
        }
        #Make a new rename to avoid parallel excecution problems with rename fields in cascade
        mutate {
            rename => { "[logx][kibana][log]" => "[logx][kibana][change]" }
            rename => { "[logx][kibana][@timestamp]" => "[logx][kibana][timestamp]" }
        }
        #Make a new rename to avoid parallel excecution problems with rename fields in cascade
        mutate {
            rename => { "[logx][kibana][change][logger]" => "[logx][kibana][logger]" }
            rename => { "[logx][kibana][change][level]" => "[logx][kibana][level]" }
        }

    #Finally, remove unnecessary fields
        mutate {
            remove_field => ["@version","tags","log","[logx][kibana][change]","irrelevant","kibana_audit_temps","msg_fields"]
        }

  }
   #Also, remove unwanted fields if the message not match with conditions
   mutate {
      remove_field => ["headers"]
   }
}
'
WHERE id=1408;
----------------------------------------------------------------------------------------------------------------------------------------
-- LOGSTASH  --
----------------------------------------------------------------------------------------------------------------------------------------
UPDATE utm_logstash_filter
SET filter_version='3.0.1',logstash_filter='filter {
  #Fields based on https://www.elastic.co/guide/en/beats/filebeat/7.13/filebeat-module-logstash.html (february 2022)
  #and filebeat fields.yml version 7.13.4 oss

  #Filebeat logstash module, version 3.0.1
  #Suport input files with json format only to avoid parsing json in plain text inputs
  #Logstash have plain logs and json logs if (--log.format=json) option set when executing client´s logstash,
  #see: https://www.elastic.co/guide/en/logstash/current/logstash-settings-file.html, current is 8.0

  #Filter Input requirements -> fileset: datatype
  #                             log: json
  #                             slowlog: json

  split {
    field => "message"
    terminator => "<utm-log-separator>"
  }
  json {
    source => "message"
  }

  if ([event][module] and [event][module] == "logstash")
  or ([service][type] and [service][type] == "logstash") {
    #Generating dataType and dataSource fields
        mutate {
            add_field => { "dataSource" => "%{[host][hostname]}" }
        }
    if [event][module] {
        mutate {
            add_field => { "dataType" => "%{[event][module]}" }
        }
    } else if [service][type] {
        mutate {
            add_field => { "dataType" => "%{[service][type]}" }
        }
    }
    #......................................................................#
    #Adding only JSON files support, assuming that log4j2.properties is set with default appender logs patterns
    if [message] {
      json {
        source => "message"
        target => "logstash"
      }
    }
    #......................................................................#
    #Then add all possible fields to the json tree structure

        mutate {
            #General fields from ECS
            rename => { "host" => "[logx][logstash][host]" }
            rename => { "service" => "[logx][logstash][service]" }
            rename => { "ecs" => "[logx][logstash][ecs]" }
            rename => { "agent" => "[logx][logstash][agent]" }
            rename => { "fileset" => "[logx][logstash][fileset]" }
            rename => { "event" => "[logx][logstash][event]" }
            rename => { "input" => "[logx][logstash][input]" }
            rename => { "labels" => "[logx][logstash][labels]" }
            rename => { "as" => "[logx][logstash][as]" }
            rename => { "client" => "[logx][logstash][client]" }
            rename => { "cloud" => "[logx][logstash][cloud]" }
            rename => { "code_signature" => "[logx][logstash][code_signature]" }
            rename => { "container" => "[logx][logstash][container]" }
            rename => { "destination" => "[logx][logstash][destination]" }
            rename => { "dll" => "[logx][logstash][dll]" }
            rename => { "dns" => "[logx][logstash][dns]" }
            rename => { "error" => "[logx][logstash][error]" }
            rename => { "file" => "[logx][logstash][file]" }
            rename => { "geo" => "[logx][logstash][geo]" }
            rename => { "hash" => "[logx][logstash][hash]" }
            rename => { "http" => "[logx][logstash][http]" }
            rename => { "interface" => "[logx][logstash][interface]" }
            rename => { "network" => "[logx][logstash][network]" }
            rename => { "observer" => "[logx][logstash][observer]" }
            rename => { "organization" => "[logx][logstash][organization]" }
            rename => { "package" => "[logx][logstash][package]" }
            rename => { "pe" => "[logx][logstash][pe]" }
            rename => { "process" => "[logx][logstash][process]" }
            rename => { "registry" => "[logx][logstash][registry]" }
            rename => { "related" => "[logx][logstash][related]" }
            rename => { "rule" => "[logx][logstash][rule]" }
            rename => { "server" => "[logx][logstash][server]" }
            rename => { "source" => "[logx][logstash][source]" }
            rename => { "threat" => "[logx][logstash][threat]" }
            rename => { "tls" => "[logx][logstash][tls]" }
            rename => { "span.id" => "[logx][logstash][span.id]" }
            rename => { "trace.id" => "[logx][logstash][trace.id]" }
            rename => { "transaction.id" => "[logx][logstash][transaction.id]" }
            rename => { "url" => "[logx][logstash][url]" }
            rename => { "user" => "[logx][logstash][user]" }
            rename => { "vlan" => "[logx][logstash][vlan]" }
            rename => { "vulnerability" => "[logx][logstash][vulnerability]" }
            rename => { "x509" => "[logx][logstash][x509]" }

            #Fields from logstash module
            rename => { "logstash" => "[logx][logstash]" }
            rename => { "message" => "[logx][logstash][message]" }

            #Fields from logstash logs
            rename => { "timestamp" => "[logx][logstash][timestamp]" }
            rename => { "level" => "[logx][logstash][level]" }
            rename => { "loggerName" => "[logx][logstash][loggerName]" }

        }

    #Finally, remove unnecessary fields
        mutate {
            remove_field => ["@version","path","tags","log"]
        }

  }
   #Also, remove unwanted fields if the message not match with conditions
   mutate {
      remove_field => ["headers"]
   }
}
'
WHERE id=1407;
----------------------------------------------------------------------------------------------------------------------------------------
-- MONGODB  --
----------------------------------------------------------------------------------------------------------------------------------------
UPDATE utm_logstash_filter
SET filter_version='2.0.1',logstash_filter='filter {
  #Fields based on https://www.elastic.co/guide/en/beats/filebeat/7.13/filebeat-module-mongodb.html (february 2022)
  #https://docs.mongodb.com/manual/reference/log-messages/ current version 5.0 (february 2022)
  #and filebeat fields.yml version 7.13.4 oss
  #As the docs says this module work with one event per line, filebeat must ensure to send one event per line.

  #Filebeat mongodb module, version 2.0.1
  #Supports json input format only, starting in MongoDB 4.4 logs are in json format

  #Filter Input requirements -> fileset: datatype
  #                             log: json

  split {
    field => "message"
    terminator => "<utm-log-separator>"
  }
  json {
    source => "message"
  }

  if ([event][module] and [event][module] == "mongodb")
  or ([service][type] and [service][type] == "mongodb") {
    #Generating dataType and dataSource fields
        mutate {
            add_field => { "dataSource" => "%{[host][hostname]}" }
        }
    if [event][module] {
        mutate {
            add_field => { "dataType" => "%{[event][module]}" }
        }
    } else if [service][type] {
        mutate {
            add_field => { "dataType" => "%{[service][type]}" }
        }
    }
    #......................................................................#
    #Adding only JSON files support, plain logs are not supported
    if [message]{
      json {
        source => "message"
        target => "mongodb"
      }
    }
    #......................................................................#
    #Then add all possible fields to the json tree structure
        mutate {
            #General fields from ECS
            rename => { "host" => "[logx][mongodb][host]" }
            rename => { "service" => "[logx][mongodb][service]" }
            rename => { "ecs" => "[logx][mongodb][ecs]" }
            rename => { "agent" => "[logx][mongodb][agent]" }
            rename => { "fileset" => "[logx][mongodb][fileset]" }
            rename => { "event" => "[logx][mongodb][event]" }
            rename => { "input" => "[logx][mongodb][input]" }
            rename => { "labels" => "[logx][mongodb][labels]" }
            rename => { "as" => "[logx][mongodb][as]" }
            rename => { "client" => "[logx][mongodb][client]" }
            rename => { "cloud" => "[logx][mongodb][cloud]" }
            rename => { "code_signature" => "[logx][mongodb][code_signature]" }
            rename => { "container" => "[logx][mongodb][container]" }
            rename => { "destination" => "[logx][mongodb][destination]" }
            rename => { "dll" => "[logx][mongodb][dll]" }
            rename => { "dns" => "[logx][mongodb][dns]" }
            rename => { "error" => "[logx][mongodb][error]" }
            rename => { "file" => "[logx][mongodb][file]" }
            rename => { "geo" => "[logx][mongodb][geo]" }
            rename => { "hash" => "[logx][mongodb][hash]" }
            rename => { "http" => "[logx][mongodb][http]" }
            rename => { "interface" => "[logx][mongodb][interface]" }
            rename => { "network" => "[logx][mongodb][network]" }
            rename => { "observer" => "[logx][mongodb][observer]" }
            rename => { "organization" => "[logx][mongodb][organization]" }
            rename => { "package" => "[logx][mongodb][package]" }
            rename => { "pe" => "[logx][mongodb][pe]" }
            rename => { "process" => "[logx][mongodb][process]" }
            rename => { "registry" => "[logx][mongodb][registry]" }
            rename => { "related" => "[logx][mongodb][related]" }
            rename => { "rule" => "[logx][mongodb][rule]" }
            rename => { "server" => "[logx][mongodb][server]" }
            rename => { "source" => "[logx][mongodb][source]" }
            rename => { "threat" => "[logx][mongodb][threat]" }
            rename => { "tls" => "[logx][mongodb][tls]" }
            rename => { "span.id" => "[logx][mongodb][span.id]" }
            rename => { "trace.id" => "[logx][mongodb][trace.id]" }
            rename => { "transaction.id" => "[logx][mongodb][transaction.id]" }
            rename => { "url" => "[logx][mongodb][url]" }
            rename => { "user" => "[logx][mongodb][user]" }
            rename => { "vlan" => "[logx][mongodb][vlan]" }
            rename => { "vulnerability" => "[logx][mongodb][vulnerability]" }
            rename => { "x509" => "[logx][mongodb][x509]" }

        }
        #Fields from mongodb json logs
        mutate {
            rename => { "mongodb" => "[logx][mongodb]" }
        }
        #Rename to more readable mongodb fields
        mutate {
            rename => { "[logx][mongodb][t]" => "[logx][mongodb][timestamp]" }
            rename => { "[logx][mongodb][c]" => "[logx][mongodb][component]" }
            rename => { "[logx][mongodb][ctx]" => "[logx][mongodb][context]" }
            rename => { "message" => "[logx][mongodb][message]" }
        }
        #......................................................................#
        #Decoding severity
        if [logx][mongodb][s] {
          if [logx][mongodb][s] == "F" {
        	  mutate {
              add_field => {
                "[logx][mongodb][severity]" => "Fatal"
              }
            }
          }
          else if [logx][mongodb][s] == "E" {
        	  mutate {
              add_field => {
                "[logx][mongodb][severity]" => "Error"
              }
            }
          }
          else if [logx][mongodb][s] == "W" {
        	  mutate {
              add_field => {
                "[logx][mongodb][severity]" => "Warning"
              }
            }
          }
          else if [logx][mongodb][s] == "I" {
        	  mutate {
              add_field => {
                "[logx][mongodb][severity]" => "Informational"
              }
            }
          }
          else {
        	  mutate {
              add_field => {
                "[logx][mongodb][severity]" => "Debug"
              }
            }
          }
        }
        #......................................................................#
        #Finally, remove unnecessary fields
        mutate {
            remove_field => ["@version","tags","log","[logx][mongodb][s]"]
        }

  }
   #Also, remove unwanted fields if the message not match with conditions
   mutate {
      remove_field => ["headers"]
   }
}
'
WHERE id=1406;
----------------------------------------------------------------------------------------------------------------------------------------
-- MYSQL  --
----------------------------------------------------------------------------------------------------------------------------------------
UPDATE utm_logstash_filter
SET filter_version='2.0.1',logstash_filter='filter {
  #Fields based on https://www.elastic.co/guide/en/beats/filebeat/7.13/filebeat-module-mysql.html (february 2022)
  #https://dev.mysql.com/doc/refman/8.0/en/error-log-format.html (february 2022)
  #https://docs.oracle.com/en-us/iaas/Content/Logging/Reference/top_level_logging_format.htm (february 2022)
  #and filebeat fields.yml version 7.13.4 oss
  #As the docs says this module work with one event per line, filebeat must ensure to send one event per line.

  #Filebeat mysql module, version 2.0.1
  #Filter Input requirements -> fileset: datatype
  #                             error: json (version 8.0+). For this input filename must end with .json, contain -json or _json, and each log line must begin with { and end with }
  #                             error: plain text (older versions)
  #                             slowlog: plain text

  split {
    field => "message"
    terminator => "<utm-log-separator>"
  }
  json {
    source => "message"
  }

  if ([event][module] and [event][module] == "mysql")
  or ([service][type] and [service][type] == "mysql") {
    #Generating dataType and dataSource fields
        mutate {
            add_field => { "dataSource" => "%{[host][hostname]}" }
        }
    if [event][module] {
        mutate {
            add_field => { "dataType" => "%{[event][module]}" }
        }
    } else if [service][type] {
        mutate {
            add_field => { "dataType" => "%{[service][type]}" }
        }
    }
    #......................................................................#
    #Adding JSON files support for newer versions (8.0+)
    if [log][file][path] and ([log][file][path]=~/(.json)$/ or "-json" in [log][file][path] or "_json" in [log][file][path] or [message] =~ "\A\{.+\}\z" ){
      if [message]{
        json {
          source => "message"
          target => "mysql_tmp"
        }
      }
    }else {
    #......................................................................#
    #Parse message field in plain text format, begining from current versions to latter ones
      if [message]{
        grok {
          match => {
              "message" => [
              "%{GREEDYDATA:timestamp} %{INT:thread} \[%{DATA:label}%{SPACE}\] \[%{DATA:err_code}%{SPACE}\] \[%{DATA:subsystem}%{SPACE}\] %{GREEDYDATA:msg}",
              "%{GREEDYDATA:timestamp} %{INT:pid} \[%{DATA:label}%{SPACE}\] %{GREEDYDATA:msg}"
              ]
          }
        }
      }
    }
    #......................................................................#
    #Then add all possible fields to the json tree structure

        #Fields from mysql json logs
        mutate {
            rename => { "mysql_tmp" => "[logx][mysql]" }
            rename => { "message" => "[logx][mysql][message]" }
        }
        #Fields from mysql plain logs
        mutate {
            rename => { "timestamp" => "[logx][mysql][timestamp]" }
            rename => { "thread" => "[logx][mysql][thread]" }
            rename => { "pid" => "[logx][mysql][pid]" }
            rename => { "label" => "[logx][mysql][label]" }
            rename => { "err_code" => "[logx][mysql][err_code]" }
            rename => { "subsystem" => "[logx][mysql][subsystem]" }
            rename => { "msg" => "[logx][mysql][msg]" }
        }
        mutate {
        #General fields from ECS
            rename => { "host" => "[logx][mysql][host]" }
            rename => { "service" => "[logx][mysql][service]" }
            rename => { "ecs" => "[logx][mysql][ecs]" }
            rename => { "agent" => "[logx][mysql][agent]" }
            rename => { "fileset" => "[logx][mysql][fileset]" }
            rename => { "event" => "[logx][mysql][event]" }
            rename => { "input" => "[logx][mysql][input]" }
            rename => { "labels" => "[logx][mysql][labels]" }
            rename => { "as" => "[logx][mysql][as]" }
            rename => { "client" => "[logx][mysql][client]" }
            rename => { "cloud" => "[logx][mysql][cloud]" }
            rename => { "code_signature" => "[logx][mysql][code_signature]" }
            rename => { "container" => "[logx][mysql][container]" }
            rename => { "destination" => "[logx][mysql][destination]" }
            rename => { "dll" => "[logx][mysql][dll]" }
            rename => { "dns" => "[logx][mysql][dns]" }
            rename => { "error" => "[logx][mysql][error]" }
            rename => { "file" => "[logx][mysql][file]" }
            rename => { "geo" => "[logx][mysql][geo]" }
            rename => { "hash" => "[logx][mysql][hash]" }
            rename => { "http" => "[logx][mysql][http]" }
            rename => { "interface" => "[logx][mysql][interface]" }
            rename => { "network" => "[logx][mysql][network]" }
            rename => { "observer" => "[logx][mysql][observer]" }
            rename => { "organization" => "[logx][mysql][organization]" }
            rename => { "package" => "[logx][mysql][package]" }
            rename => { "pe" => "[logx][mysql][pe]" }
            rename => { "process" => "[logx][mysql][process]" }
            rename => { "registry" => "[logx][mysql][registry]" }
            rename => { "related" => "[logx][mysql][related]" }
            rename => { "rule" => "[logx][mysql][rule]" }
            rename => { "server" => "[logx][mysql][server]" }
            rename => { "source" => "[logx][mysql][source]" }
            rename => { "threat" => "[logx][mysql][threat]" }
            rename => { "tls" => "[logx][mysql][tls]" }
            rename => { "span.id" => "[logx][mysql][span.id]" }
            rename => { "trace.id" => "[logx][mysql][trace.id]" }
            rename => { "transaction.id" => "[logx][mysql][transaction.id]" }
            rename => { "url" => "[logx][mysql][url]" }
            rename => { "user" => "[logx][mysql][user]" }
            rename => { "vlan" => "[logx][mysql][vlan]" }
            rename => { "vulnerability" => "[logx][mysql][vulnerability]" }
            rename => { "x509" => "[logx][mysql][x509]" }

        }
        #......................................................................#
        #Decoding priority
        if ![logx][mysql][label] and [logx][mysql][prio]{
          if [logx][mysql][prio] == 0 {
        	  mutate {
              add_field => {
                "[logx][mysql][label]" => "System"
              }
            }
          }else if [logx][mysql][prio] == 1 {
        	  mutate {
              add_field => {
                "[logx][mysql][label]" => "Error"
              }
            }
          }else if [logx][mysql][prio] == 2 {
        	  mutate {
              add_field => {
                "[logx][mysql][label]" => "Warning"
              }
            }
          } else {
            mutate {
              add_field => {
                "[logx][mysql][label]" => "Note"
              }
            }
          }
        }
        #......................................................................#
        #Formatting number values
        if [logx][mysql][pid] {
          mutate { convert => { "[logx][mysql][pid]" => "integer" } }
        }
        if [logx][mysql][thread] {
          mutate { convert => { "[logx][mysql][thread]" => "integer" } }
        }
        #......................................................................#
        #Finally, remove unnecessary fields
        mutate {
            remove_field => ["@version","tags","log"]
        }
  }
   #Also, remove unwanted fields if the message not match with conditions
   mutate {
      remove_field => ["headers"]
   }
}
'
WHERE id=1405;
----------------------------------------------------------------------------------------------------------------------------------------
-- NGINX  --
----------------------------------------------------------------------------------------------------------------------------------------
UPDATE utm_logstash_filter
SET filter_version='2.0.1',logstash_filter='filter {
  #Fields based on https://www.elastic.co/guide/en/beats/filebeat/7.13/filebeat-module-nginx.html (february 2022)
  #http://nginx.org/en/docs/http/ngx_http_core_module.html version 1.21.6 (february 2022)
  #http://nginx.org/en/docs/varindex.html version 1.21.6 (february 2022)
  #and filebeat fields.yml version 7.13.4 oss
  #As the docs says this module work with one event per line, filebeat must ensure to send one event per line.

  #Filebeat nginx module, version 2.0.1
  #Filter Input requirements -> fileset: datatype
  #                             access: plain text
  #                             error: plain text
  #                             ingress-controller: plain text

  split {
    field => "message"
    terminator => "<utm-log-separator>"
  }
  json {
    source => "message"
  }

  if ([event][module] and [event][module] == "nginx") or ([service][type] and [service][type] == "nginx") {
    #Generating dataType and dataSource fields
        mutate {
            add_field => { "dataSource" => "%{[host][hostname]}" }
        }
    if [event][module] {
        mutate {
            add_field => { "dataType" => "%{[event][module]}" }
        }
    } else if [service][type] {
        mutate {
            add_field => { "dataType" => "%{[service][type]}" }
        }
    }
    #......................................................................#
    #Parse message field in plain text format, access_log
    if [event][dataset] and [message]{
      if [event][dataset] == "nginx.access" {
          grok {
            match => {
                "message" => [
                "%{IPORHOST:remote_addr} - (-|%{DATA:remote_user}) \[%{GREEDYDATA:time}\] \"%{DATA:request}\" %{INT:status}%{SPACE}(%{INT:bytes_sent})? \"%{DATA:irrelevant}\" \"%{GREEDYDATA:http_user_agent}\"(%{GREEDYDATA:irrelevant})?"
                ]
            }
          }
        #Decoding request to get method and protocol, according to field names and structure used in access_log
        if [request] {
          grok {
          match => {
              "request" => [
              "%{WORD:request_method} %{DATA:irrelevant} %{WORD:server_protocol}/%{DATA:irrelevant}"
              ]
          }
        }
        }
      } else if [event][dataset] == "nginx.error" {
        #Parse message field in plain text format, error_log
        grok {
          match => {
              "message" => [
              "%{GREEDYDATA:time} \[%{WORD:level}\] %{INT:pid}#%{INT:tid}: %{GREEDYDATA:error_msg}"
              ]
          }
        }
      } else {
        #Return the message as is
      }
    }
    #......................................................................#
    #Then add all possible fields to the json tree structure

        #Fields from nginx plain logs
        mutate {
            #Fields from access_log
            rename => { "time" => "[logx][nginx][time]" }
            rename => { "status" => "[logx][nginx][status]" }
            rename => { "bytes_sent" => "[logx][nginx][bytes_sent]" }
            rename => { "http_user_agent" => "[logx][nginx][http_user_agent]" }
            rename => { "request_method" => "[logx][nginx][request_method]" }
            rename => { "server_protocol" => "[logx][nginx][server_protocol]" }
            rename => { "request" => "[logx][nginx][request]" }
            rename => { "remote_addr" => "[logx][nginx][remote_addr]" }
            rename => { "remote_user" => "[logx][nginx][remote_user]" }
            #Fields from error_log
            rename => { "pid" => "[logx][nginx][pid]" }
            rename => { "tid" => "[logx][nginx][tid]" }
            rename => { "error_msg" => "[logx][nginx][error_msg]" }
            rename => { "level" => "[logx][nginx][level]" }
            #Adding message field
            rename => { "message" => "[logx][nginx][message]" }

        }
        mutate {
        #General fields from ECS
            rename => { "host" => "[logx][nginx][host]" }
            rename => { "service" => "[logx][nginx][service]" }
            rename => { "ecs" => "[logx][nginx][ecs]" }
            rename => { "agent" => "[logx][nginx][agent]" }
            rename => { "fileset" => "[logx][nginx][fileset]" }
            rename => { "event" => "[logx][nginx][event]" }
            rename => { "input" => "[logx][nginx][input]" }
            rename => { "labels" => "[logx][nginx][labels]" }
            rename => { "as" => "[logx][nginx][as]" }
            rename => { "client" => "[logx][nginx][client]" }
            rename => { "cloud" => "[logx][nginx][cloud]" }
            rename => { "code_signature" => "[logx][nginx][code_signature]" }
            rename => { "container" => "[logx][nginx][container]" }
            rename => { "destination" => "[logx][nginx][destination]" }
            rename => { "dll" => "[logx][nginx][dll]" }
            rename => { "dns" => "[logx][nginx][dns]" }
            rename => { "error" => "[logx][nginx][error]" }
            rename => { "file" => "[logx][nginx][file]" }
            rename => { "geo" => "[logx][nginx][geo]" }
            rename => { "hash" => "[logx][nginx][hash]" }
            rename => { "http" => "[logx][nginx][http]" }
            rename => { "interface" => "[logx][nginx][interface]" }
            rename => { "network" => "[logx][nginx][network]" }
            rename => { "observer" => "[logx][nginx][observer]" }
            rename => { "organization" => "[logx][nginx][organization]" }
            rename => { "package" => "[logx][nginx][package]" }
            rename => { "pe" => "[logx][nginx][pe]" }
            rename => { "process" => "[logx][nginx][process]" }
            rename => { "registry" => "[logx][nginx][registry]" }
            rename => { "related" => "[logx][nginx][related]" }
            rename => { "rule" => "[logx][nginx][rule]" }
            rename => { "server" => "[logx][nginx][server]" }
            rename => { "source" => "[logx][nginx][source]" }
            rename => { "threat" => "[logx][nginx][threat]" }
            rename => { "tls" => "[logx][nginx][tls]" }
            rename => { "span.id" => "[logx][nginx][span.id]" }
            rename => { "trace.id" => "[logx][nginx][trace.id]" }
            rename => { "transaction.id" => "[logx][nginx][transaction.id]" }
            rename => { "url" => "[logx][nginx][url]" }
            rename => { "user" => "[logx][nginx][user]" }
            rename => { "vlan" => "[logx][nginx][vlan]" }
            rename => { "vulnerability" => "[logx][nginx][vulnerability]" }
            rename => { "x509" => "[logx][nginx][x509]" }

        }
        #......................................................................#
        #Formatting number values
        if [logx][nginx][bytes_sent] {
          mutate { convert => { "[logx][nginx][bytes_sent]" => "integer" } }
        }
        if [logx][nginx][status] {
          mutate { convert => { "[logx][nginx][status]" => "integer" } }
        }
        if [logx][nginx][pid] {
          mutate { convert => { "[logx][nginx][pid]" => "integer" } }
        }
        if [logx][nginx][tid] {
          mutate { convert => { "[logx][nginx][tid]" => "integer" } }
        }
        #......................................................................#
        #Finally, remove unnecessary fields
        mutate {
            remove_field => ["@version","tags","log","irrelevant"]
        }
  }
   #Also, remove unwanted fields if the message not match with conditions
   mutate {
      remove_field => ["headers"]
   }
}
'
WHERE id=1404;
----------------------------------------------------------------------------------------------------------------------------------------
-- OSQUERY  --
----------------------------------------------------------------------------------------------------------------------------------------
UPDATE utm_logstash_filter
SET filter_version='2.0.1',logstash_filter='filter {
  #Fields based on https://www.elastic.co/guide/en/beats/filebeat/7.13/filebeat-module-osquery.html (march 2022)
  #https://www.elastic.co/guide/en/beats/filebeat/7.13/exported-fields-osquery.html (march 2022)
  #https://osquery.readthedocs.io/en/stable/deployment/logging/ (march 2022)
  #https://osquery.readthedocs.io/en/stable/ (march 2022)
  #and filebeat fields.yml version 7.13.4 oss
  #As the docs says this module work with one event per line, filebeat must ensure to send one event per line.

  #Filebeat osquery module, version 2.0.1
  #Filter Input requirements -> fileset: datatype
  #                             result: json

  split {
    field => "message"
    terminator => "<utm-log-separator>"
  }
  json {
    source => "message"
  }

  if ([event][module] and [event][module] == "osquery")
  or ([service][type] and [service][type] == "osquery") {
    #Generating dataType and dataSource fields
        mutate {
            add_field => { "dataSource" => "%{[host][hostname]}" }
        }
    if [event][module] {
        mutate {
            add_field => { "dataType" => "%{[event][module]}" }
        }
    } else if [service][type] {
        mutate {
            add_field => { "dataType" => "%{[service][type]}" }
        }
    }
    #......................................................................#
    #Adding only JSON files support, plain logs are not supported
    if [message] {
      json {
        source => "message"
        target => "osquery"
      }
    }
    #......................................................................#
    #Then add all possible fields to the json tree structure

        #Fields variants from module
        mutate {
            rename => { "osquery" => "[logx][osquery]" }
            rename => { "osquery.results" => "[logx][osquery]" }
        }

        #Fields from json
        mutate {
            rename => { "[logx][osquery][json]" => "[logx][osquery]" }
        }
        #Fields from json, in case that have a root field called json
        mutate {
            rename => { "json" => "[logx][osquery]" }
        }
        mutate {
        #General fields from ECS
            rename => { "host" => "[logx][osquery][host]" }
            rename => { "service" => "[logx][osquery][service]" }
            rename => { "ecs" => "[logx][osquery][ecs]" }
            rename => { "agent" => "[logx][osquery][agent]" }
            rename => { "fileset" => "[logx][osquery][fileset]" }
            rename => { "event" => "[logx][osquery][event]" }
            rename => { "input" => "[logx][osquery][input]" }
            rename => { "labels" => "[logx][osquery][labels]" }
            rename => { "as" => "[logx][osquery][as]" }
            rename => { "client" => "[logx][osquery][client]" }
            rename => { "cloud" => "[logx][osquery][cloud]" }
            rename => { "code_signature" => "[logx][osquery][code_signature]" }
            rename => { "container" => "[logx][osquery][container]" }
            rename => { "destination" => "[logx][osquery][destination]" }
            rename => { "dll" => "[logx][osquery][dll]" }
            rename => { "dns" => "[logx][osquery][dns]" }
            rename => { "error" => "[logx][osquery][error]" }
            rename => { "file" => "[logx][osquery][file]" }
            rename => { "geo" => "[logx][osquery][geo]" }
            rename => { "hash" => "[logx][osquery][hash]" }
            rename => { "http" => "[logx][osquery][http]" }
            rename => { "interface" => "[logx][osquery][interface]" }
            rename => { "network" => "[logx][osquery][network]" }
            rename => { "observer" => "[logx][osquery][observer]" }
            rename => { "organization" => "[logx][osquery][organization]" }
            rename => { "package" => "[logx][osquery][package]" }
            rename => { "pe" => "[logx][osquery][pe]" }
            rename => { "process" => "[logx][osquery][process]" }
            rename => { "registry" => "[logx][osquery][registry]" }
            rename => { "related" => "[logx][osquery][related]" }
            rename => { "rule" => "[logx][osquery][rule]" }
            rename => { "server" => "[logx][osquery][server]" }
            rename => { "source" => "[logx][osquery][source]" }
            rename => { "threat" => "[logx][osquery][threat]" }
            rename => { "tls" => "[logx][osquery][tls]" }
            rename => { "span.id" => "[logx][osquery][span.id]" }
            rename => { "trace.id" => "[logx][osquery][trace.id]" }
            rename => { "transaction.id" => "[logx][osquery][transaction.id]" }
            rename => { "url" => "[logx][osquery][url]" }
            rename => { "user" => "[logx][osquery][user]" }
            rename => { "vlan" => "[logx][osquery][vlan]" }
            rename => { "vulnerability" => "[logx][osquery][vulnerability]" }
            rename => { "x509" => "[logx][osquery][x509]" }

            #Rename message field to add it to the structure
            rename => { "message" => "[logx][osquery][message]" }

        }
        #......................................................................#
        #Finally, remove unnecessary fields
        mutate {
            remove_field => ["@version","tags","log","irrelevant"]
        }
  }
   #Also, remove unwanted fields if the message not match with conditions
   mutate {
      remove_field => ["headers"]
   }
}
'
WHERE id=1403;
----------------------------------------------------------------------------------------------------------------------------------------
-- POSTGRESQL  --
----------------------------------------------------------------------------------------------------------------------------------------
UPDATE utm_logstash_filter
SET filter_version='2.0.1',logstash_filter='filter {
  #Fields based on https://www.juniper.net/documentation/en_US/webapp5.5/topics/reference/w-a-s-postgres-log.html (february 2022)
  #and https://www.postgresql.org/docs/current/runtime-config-logging.html (current 14.2)
  #and https://www.elastic.co/guide/en/beats/filebeat/7.13/filebeat-module-postgresql.html
  #and filebeat fields.yml version 7.13.4 oss

  #Filebeat postgresql module, version 2.0.1
  #Filter Input requirements -> fileset: datatype
  #                             log: plain text

  split {
    field => "message"
    terminator => "<utm-log-separator>"
  }
  json {
    source => "message"
  }

  if ([event][module] and [event][module] == "postgresql")
  or ([service][type] and [service][type] == "postgresql") {
    #Generating dataType and dataSource fields
        mutate {
            add_field => { "dataSource" => "%{[host][hostname]}" }
        }
    if [event][module] {
        mutate {
            add_field => { "dataType" => "%{[event][module]}" }
        }
    } else if [service][type] {
        mutate {
            add_field => { "dataType" => "%{[service][type]}" }
        }
    }

    #......................................................................#
    #Parse message field
    if [message] {
        grok {
          match => {
              "message" => [
              "%{GREEDYDATA:pg_time} %{IPORHOST:pg_host} %{WORD:irrelevant}\[%{INT:pg_pid}\]:(\s)?\[%{DATA:pg_group_id}\] %{INT:pg_error_code} %{GREEDYDATA:pg_session_id} %{WORD:pg_message_type}:(\s)?%{GREEDYDATA:pg_message}",
              "%{GREEDYDATA:pg_time} \[%{DATA:pg_group_id}\] %{WORD:pg_message_type}:(\s)*%{GREEDYDATA:pg_message}"
              ]
          }

        }
    #......................................................................#
    #Formatting number values
      if [postgresql][log][client_port] {
        mutate { convert => { "[postgresql][log][client_port]" => "integer" } }
      }
      if [pg_pid] {
        mutate { convert => { "pg_pid" => "integer" } }
      }
    #......................................................................#
    #Then add all possible fields to the json tree structure

        mutate {
            #General fields from ECS
            rename => { "host" => "[logx][postgresql][host]" }
            rename => { "service" => "[logx][postgresql][service]" }
            rename => { "ecs" => "[logx][postgresql][ecs]" }
            rename => { "agent" => "[logx][postgresql][agent]" }
            rename => { "fileset" => "[logx][postgresql][fileset]" }
            rename => { "event" => "[logx][postgresql][event]" }
            rename => { "input" => "[logx][postgresql][input]" }
            rename => { "labels" => "[logx][postgresql][labels]" }
            rename => { "as" => "[logx][postgresql][as]" }
            rename => { "client" => "[logx][postgresql][client]" }
            rename => { "cloud" => "[logx][postgresql][cloud]" }
            rename => { "code_signature" => "[logx][postgresql][code_signature]" }
            rename => { "container" => "[logx][postgresql][container]" }
            rename => { "destination" => "[logx][postgresql][destination]" }
            rename => { "dll" => "[logx][postgresql][dll]" }
            rename => { "dns" => "[logx][postgresql][dns]" }
            rename => { "error" => "[logx][postgresql][error]" }
            rename => { "file" => "[logx][postgresql][file]" }
            rename => { "geo" => "[logx][postgresql][geo]" }
            rename => { "hash" => "[logx][postgresql][hash]" }
            rename => { "http" => "[logx][postgresql][http]" }
            rename => { "interface" => "[logx][postgresql][interface]" }
            rename => { "network" => "[logx][postgresql][network]" }
            rename => { "observer" => "[logx][postgresql][observer]" }
            rename => { "organization" => "[logx][postgresql][organization]" }
            rename => { "package" => "[logx][postgresql][package]" }
            rename => { "pe" => "[logx][postgresql][pe]" }
            rename => { "process" => "[logx][postgresql][process]" }
            rename => { "registry" => "[logx][postgresql][registry]" }
            rename => { "related" => "[logx][postgresql][related]" }
            rename => { "rule" => "[logx][postgresql][rule]" }
            rename => { "server" => "[logx][postgresql][server]" }
            rename => { "source" => "[logx][postgresql][source]" }
            rename => { "threat" => "[logx][postgresql][threat]" }
            rename => { "tls" => "[logx][postgresql][tls]" }
            rename => { "span.id" => "[logx][postgresql][span.id]" }
            rename => { "trace.id" => "[logx][postgresql][trace.id]" }
            rename => { "transaction.id" => "[logx][postgresql][transaction.id]" }
            rename => { "url" => "[logx][postgresql][url]" }
            rename => { "user" => "[logx][postgresql][user]" }
            rename => { "vlan" => "[logx][postgresql][vlan]" }
            rename => { "vulnerability" => "[logx][postgresql][vulnerability]" }
            rename => { "x509" => "[logx][postgresql][x509]" }

            #Fields from postgresql module
            rename => { "[postgresql][log][client_addr]" => "[logx][postgresql][src_ip]" }
            rename => { "[postgresql][log][client_port]" => "[logx][postgresql][src_port]" }
            rename => { "postgresql" => "[logx][postgresql]" }

            #Fields from postgresql logs
            rename => { "pg_time" => "[logx][postgresql][pg_time]" }
            rename => { "pg_host" => "[logx][postgresql][pg_host]" }
            rename => { "pg_pid" => "[logx][postgresql][pg_pid]" }
            rename => { "pg_group_id" => "[logx][postgresql][pg_group_id]" }
            rename => { "pg_error_code" => "[logx][postgresql][pg_error_code]" }
            rename => { "pg_session_id" => "[logx][postgresql][pg_session_id]" }
            rename => { "pg_message_type" => "[logx][postgresql][pg_message_type]" }
            rename => { "message" => "[logx][postgresql][message]" }

        }

    #Finally, remove unnecessary fields
        mutate {
            remove_field => ["@version","path","tags","log","irrelevant","pg_message"]
        }
    }
  }
   #Also, remove unwanted fields if the message not match with conditions
   mutate {
      remove_field => ["headers"]
   }
}
'
WHERE id=1402;
----------------------------------------------------------------------------------------------------------------------------------------
-- REDIS  --
----------------------------------------------------------------------------------------------------------------------------------------
UPDATE utm_logstash_filter
SET filter_version='2.0.1',logstash_filter='filter {
  #Fields based on https://www.elastic.co/guide/en/beats/filebeat/7.13/filebeat-module-redis.html (march 2022)
  #https://www.elastic.co/guide/en/beats/filebeat/7.13/exported-fields-redis.html (march 2022)
  #https://redis.io/ version 6.2.6 stable (march 2022)
  #https://build47.com/redis-log-format-levels/ (march 2022)
  #and filebeat fields.yml version 7.13.4 oss
  #As the docs says this module work with one event per line, filebeat must ensure to send one event per line.

  #Filebeat redis module, version 2.0.1. Supports older 2.x log versions to latter (6.2.6)
  #Filter Input requirements -> fileset: datatype
  #                             log: plain text
  #                             slowlog: plain text

  split {
    field => "message"
    terminator => "<utm-log-separator>"
  }
  json {
    source => "message"
  }

  if ([event][module] and [event][module] == "redis")
  or ([service][type] and [service][type] == "redis") {
    #Generating dataType and dataSource fields
        mutate {
            add_field => { "dataSource" => "%{[host][hostname]}" }
        }
    if [event][module] {
        mutate {
            add_field => { "dataType" => "%{[event][module]}" }
        }
    } else if [service][type] {
        mutate {
            add_field => { "dataType" => "%{[service][type]}" }
        }
    }
    #......................................................................#
    #Parse message field, first newer versions (3.x+ to current stable 6.2.6), second 2.x versions
      if [message] {
        grok {
          match => {
              "message" => [
              "%{INT:pid}:%{WORD:role_enc} (?<timestamp>(%{MONTHDAY} %{MONTH} %{YEAR} %{TIME})) %{DATA:level_enc} %{GREEDYDATA:msg}",
              "\[%{INT:pid}\] (?<timestamp>(%{MONTHDAY} %{MONTH} %{TIME})) %{DATA:level_enc} %{GREEDYDATA:msg}"
              ]
          }
        }
      }
    #......................................................................#
    #Decoding role...
    if [role_enc] {
    if [role_enc] == "x" or [role_enc] == "X" {
       mutate {
        add_field => {
         "[logx][redis][role]" => "sentinel"
        }
      }
    } else if [role_enc] == "c" or [role_enc] == "C" {
       mutate {
        add_field => {
         "[logx][redis][role]" => "child"
        }
      }
    } else if [role_enc] == "s" or [role_enc] == "S" {
       mutate {
        add_field => {
         "[logx][redis][role]" => "slave"
        }
      }
    } else if [role_enc] == "m" or [role_enc] == "M" {
       mutate {
        add_field => {
         "[logx][redis][role]" => "master"
        }
      }
    } else {
       mutate {
        add_field => {
         "[logx][redis][role]" => "unknown"
        }
      }
    }
    }
    #......................................................................#
    #Decoding level...
    if [level_enc] {
    if [level_enc] == "." {
       mutate {
        add_field => {
         "[logx][redis][level]" => "debug"
        }
      }
    } else if [level_enc] == "-" {
       mutate {
        add_field => {
         "[logx][redis][level]" => "verbose"
        }
      }
    } else if [level_enc] == "*" {
       mutate {
        add_field => {
         "[logx][redis][level]" => "notice"
        }
      }
    } else if [level_enc] == "#" {
       mutate {
        add_field => {
         "[logx][redis][level]" => "warning"
        }
      }
    } else {
       mutate {
        add_field => {
         "[logx][redis][level]" => "unknown"
        }
      }
    }
    }
    #......................................................................#
    #Then add all possible fields to the json tree structure

        #Fields variants from module
        mutate {
            rename => { "redis" => "[logx][redis]" }
        }
        #Fields from logs
        mutate {
            rename => { "role_enc" => "[logx][redis][role_enc]" }
            rename => { "level_enc" => "[logx][redis][level_enc]" }
            rename => { "pid" => "[logx][redis][pid]" }
            rename => { "msg" => "[logx][redis][msg]" }
            rename => { "timestamp" => "[logx][redis][timestamp]" }
        }
        mutate {
        #General fields from ECS
            rename => { "host" => "[logx][redis][host]" }
            rename => { "service" => "[logx][redis][service]" }
            rename => { "ecs" => "[logx][redis][ecs]" }
            rename => { "agent" => "[logx][redis][agent]" }
            rename => { "fileset" => "[logx][redis][fileset]" }
            rename => { "event" => "[logx][redis][event]" }
            rename => { "input" => "[logx][redis][input]" }
            rename => { "labels" => "[logx][redis][labels]" }
            rename => { "as" => "[logx][redis][as]" }
            rename => { "client" => "[logx][redis][client]" }
            rename => { "cloud" => "[logx][redis][cloud]" }
            rename => { "code_signature" => "[logx][redis][code_signature]" }
            rename => { "container" => "[logx][redis][container]" }
            rename => { "destination" => "[logx][redis][destination]" }
            rename => { "dll" => "[logx][redis][dll]" }
            rename => { "dns" => "[logx][redis][dns]" }
            rename => { "error" => "[logx][redis][error]" }
            rename => { "file" => "[logx][redis][file]" }
            rename => { "geo" => "[logx][redis][geo]" }
            rename => { "hash" => "[logx][redis][hash]" }
            rename => { "http" => "[logx][redis][http]" }
            rename => { "interface" => "[logx][redis][interface]" }
            rename => { "network" => "[logx][redis][network]" }
            rename => { "observer" => "[logx][redis][observer]" }
            rename => { "organization" => "[logx][redis][organization]" }
            rename => { "package" => "[logx][redis][package]" }
            rename => { "pe" => "[logx][redis][pe]" }
            rename => { "process" => "[logx][redis][process]" }
            rename => { "registry" => "[logx][redis][registry]" }
            rename => { "related" => "[logx][redis][related]" }
            rename => { "rule" => "[logx][redis][rule]" }
            rename => { "server" => "[logx][redis][server]" }
            rename => { "source" => "[logx][redis][source]" }
            rename => { "threat" => "[logx][redis][threat]" }
            rename => { "tls" => "[logx][redis][tls]" }
            rename => { "span.id" => "[logx][redis][span.id]" }
            rename => { "trace.id" => "[logx][redis][trace.id]" }
            rename => { "transaction.id" => "[logx][redis][transaction.id]" }
            rename => { "url" => "[logx][redis][url]" }
            rename => { "user" => "[logx][redis][user]" }
            rename => { "vlan" => "[logx][redis][vlan]" }
            rename => { "vulnerability" => "[logx][redis][vulnerability]" }
            rename => { "x509" => "[logx][redis][x509]" }

            #Rename message field to add it to the structure
            rename => { "message" => "[logx][redis][message]" }

        }

        #......................................................................#
        #Formatting number values
        if [logx][redis][pid] {
          mutate {
            convert => {
              "[logx][redis][pid]" => "integer"
            }
          }
        }
        #......................................................................#
        #Finally, remove unnecessary fields
        mutate {
            remove_field => ["@version","tags","log","irrelevant"]
        }
  }
   #Also, remove unwanted fields if the message not match with conditions
   mutate {
      remove_field => ["headers"]
   }
}
'
WHERE id=1401;
----------------------------------------------------------------------------------------------------------------------------------------
-- SYSTEM LINUX (AGENT)  --
----------------------------------------------------------------------------------------------------------------------------------------
UPDATE utm_logstash_filter
SET filter_version='2.0.1',logstash_filter='filter {
  #Fields based on https://www.elastic.co/guide/en/beats/filebeat/7.13/filebeat-module-system.html (april 2022)
  #https://www.elastic.co/guide/en/beats/filebeat/7.13/exported-fields-system.html (april 2022)
  #and filebeat fields.yml version 7.13.4 oss
  #As the docs says this module work with one event per line, filebeat must ensure to send one event per line.

  #Filebeat system module, version 2.0.1
  #Filter Input requirements -> fileset: datatype
  #                             syslog: plain text
  #                             auth: plain text

  split {
    field => "message"
    terminator => "<utm-log-separator>"
  }
  json {
    source => "message"
  }

  if (([event][module] and [event][module] == "system") or ([service][type] and [service][type] == "system"))
  and ([host][os][type] and [host][os][type] == "linux") {
    #Generating dataType and dataSource fields
        mutate {
            add_field => { "dataSource" => "%{[host][hostname]}" }
            add_field => { "dataType" => "linux" }
        }
    #......................................................................#
    #Then add all possible fields to the json tree structure

        #Fields variants from module
        mutate {
            rename => { "system" => "[logx][linux]" }
        }
        mutate {
        #General fields from ECS
            rename => { "host" => "[logx][linux][host]" }
            rename => { "service" => "[logx][linux][service]" }
            rename => { "ecs" => "[logx][linux][ecs]" }
            rename => { "agent" => "[logx][linux][agent]" }
            rename => { "fileset" => "[logx][linux][fileset]" }
            rename => { "event" => "[logx][linux][event]" }
            rename => { "input" => "[logx][linux][input]" }
            rename => { "labels" => "[logx][linux][labels]" }
            rename => { "as" => "[logx][linux][as]" }
            rename => { "client" => "[logx][linux][client]" }
            rename => { "cloud" => "[logx][linux][cloud]" }
            rename => { "code_signature" => "[logx][linux][code_signature]" }
            rename => { "container" => "[logx][linux][container]" }
            rename => { "destination" => "[logx][linux][destination]" }
            rename => { "dll" => "[logx][linux][dll]" }
            rename => { "dns" => "[logx][linux][dns]" }
            rename => { "error" => "[logx][linux][error]" }
            rename => { "file" => "[logx][linux][file]" }
            rename => { "geo" => "[logx][linux][geo]" }
            rename => { "hash" => "[logx][linux][hash]" }
            rename => { "http" => "[logx][linux][http]" }
            rename => { "interface" => "[logx][linux][interface]" }
            rename => { "network" => "[logx][linux][network]" }
            rename => { "observer" => "[logx][linux][observer]" }
            rename => { "organization" => "[logx][linux][organization]" }
            rename => { "package" => "[logx][linux][package]" }
            rename => { "pe" => "[logx][linux][pe]" }
            rename => { "process" => "[logx][linux][process]" }
            rename => { "registry" => "[logx][linux][registry]" }
            rename => { "related" => "[logx][linux][related]" }
            rename => { "rule" => "[logx][linux][rule]" }
            rename => { "server" => "[logx][linux][server]" }
            rename => { "source" => "[logx][linux][source]" }
            rename => { "threat" => "[logx][linux][threat]" }
            rename => { "tls" => "[logx][linux][tls]" }
            rename => { "span.id" => "[logx][linux][span.id]" }
            rename => { "trace.id" => "[logx][linux][trace.id]" }
            rename => { "transaction.id" => "[logx][linux][transaction.id]" }
            rename => { "url" => "[logx][linux][url]" }
            rename => { "user" => "[logx][linux][user]" }
            rename => { "vlan" => "[logx][linux][vlan]" }
            rename => { "vulnerability" => "[logx][linux][vulnerability]" }
            rename => { "x509" => "[logx][linux][x509]" }

            #Rename message field to add it to the structure
            rename => { "message" => "[logx][linux][message]" }

        }
        #......................................................................#
        #Finally, remove unnecessary fields
        mutate {
            remove_field => ["@version","tags","log"]
        }
  }
   #Also, remove unwanted fields if the message not match with conditions
   mutate {
      remove_field => ["headers"]
   }
}
'
WHERE id=1413;
----------------------------------------------------------------------------------------------------------------------------------------
-- FORTINET  --
----------------------------------------------------------------------------------------------------------------------------------------
UPDATE utm_logstash_filter
SET filter_version='2.0.1',logstash_filter='filter {
 #Check the minimum fields present in fortinet log, based in docs and samples provided
 #Were 100 different fields identified in official docs, plus the identified in real logs, below 6 are used to identify fortinet log
 #https://docs.fortinet.com/document/fortigate/7.0.4/fortios-log-message-reference/357866/log-message-fields
 #https://docs.fortinet.com/document/fortigate/7.0.4/fortios-log-message-reference/656858/log-id-definitions
 #https://docs.fortinet.com/document/fortigate/7.2.2/fortios-log-message-reference/357866/log-message-fields (Update November 2022)
 #Filter version 2.0.1

 split {
   field => "message"
   terminator => "<utm-log-separator>"
 }

  #Looking for datasource generated by an agent and parse original message
  if [message]=~/\[utm_stack_agent_ds=(.+)\]-(.+)/ {
    grok {
      match => {
        "message" => [ "\[utm_stack_agent_ds=%{DATA:dataSource}\]-%{GREEDYDATA:original_log_message}" ]
      }
    }
  }
  if [original_log_message] {
    mutate {
      update => { "message" => "%{[original_log_message]}" }
    }
  }

if [message] and ( "date=" in [message] and "time=" in [message] and "logid=" in [message]
 and "type=" in [message] and "subtype=" in [message] and "level=" in [message]) {

#......................................................................#
 #First, replace whitespaces with default string after = to avoid kv issues, example:
 #device_id= date=2021-08-18, generates -> device_id="date=2021-08-18"
 #and should generate two fields: device_id and date
      mutate {
        gsub => [
          "message", "= ", "=X0X "
        ]
      }

#......................................................................#
#Using grok to parse priority if present
        grok {
          match => {
            "message" => [
              "(<%{NUMBER:priority}>)?%{GREEDYDATA:message_rest}"
            ]
          }
        }

#......................................................................#
#Using the kv filter with default config, usefull in key-value logs
    if [message_rest] {
      kv {
        source => "message_rest"
        allow_duplicate_values => false
        target => "kv_field"
      }
    }
#......................................................................#
#Remove fields that have issues with kv filter
   mutate {
      remove_field => ["[kv_field][msg]"]
   }
#......................................................................#
#Using grok to parse kv issued fields
    if [message_rest] {
          grok {
            match => {
              "message_rest" => [
                 "%{GREEDYDATA} msg=%{QUOTEDSTRING:msg}%{GREEDYDATA}"
              ]
            }
          }
#......................................................................#
#Remove double quotation and add to kv_field
          mutate {
            gsub => ["[msg]", ''"'', ""]
          }
    }
          mutate {
            rename => { "msg" => "[kv_field][msg]" }
            rename => { "message" => "[kv_field][message]" }
          }
#......................................................................#
#Generating dataSource field required by CurrelationRulesEngine
#Checks if devname field is present or if it has no value, in those
#cases datasource points to host field
 if ([kv_field][devname]){
      if !([kv_field][devname]=="X0X") {
        if [dataSource] {
          mutate {
            update => { "dataSource" => "%{[kv_field][devname]}" }
          }
        } else {
          mutate {
            add_field => { "dataSource" => "%{[kv_field][devname]}" }
          }
        }
      }
 }
#Finally evaluates to the host variable if can not be calculated
 if ![dataSource] {
    mutate {
       add_field => { "dataSource" => "%{host}" }
     }
 }

#......................................................................#
#Generating dataType field required by CurrelationRulesEngine
   mutate {
		  add_field => {
			"dataType" => "firewall-fortigate-traffic"
		  }
	   }
#......................................................................#
#Cleaning message field
   mutate {
      gsub => ["[kv_field][message]", "X0X", ""]
   }

#......................................................................#
#Set null the fields with de X0X value (default string for null), and replace simple and double quotation
#also generate logx tree structure dynamically
          if [kv_field] {
            ruby {
                code => ''
                    event.get("[kv_field]").each do |k, v|
                          if (v == "X0X")
                            event.set("[logx][fortigate][#{k}]",nil)
                          elsif !(v.kind_of?(Array))
                              new_v = v.to_s.gsub(/\"/, "")
                              new_v = new_v.gsub(/\''/, "")
                              event.set("[logx][fortigate][#{k}]",new_v)
                          else
                              event.set("[logx][fortigate][#{k}]",v)
                          end
                       end
                    ''
            }
          }
#......................................................................#
#Rename standard fields and fields out of kv result
      mutate {
        rename => { "priority" => "[logx][fortigate][priority]" }
        rename => { "[logx][fortigate][srcip]" => "[logx][fortigate][src_ip]" }
        rename => { "[logx][fortigate][srcport]" => "[logx][fortigate][src_port]" }
        rename => { "[logx][fortigate][dstip]" => "[logx][fortigate][dest_ip]" }
        rename => { "[logx][fortigate][dstport]" => "[logx][fortigate][dest_port]" }
      }
#......................................................................#
#Formatting number values
   mutate {
      convert => {
        "[logx][fortigate][priority]" => "integer"
        "[logx][fortigate][duration]" => "integer"
        "[logx][fortigate][sessionid]" => "integer"
        "[logx][fortigate][transport]" => "integer"
        "[logx][fortigate][src_port]" => "integer"
        "[logx][fortigate][srcserver]" => "integer"
        "[logx][fortigate][dest_port]" => "integer"
        "[logx][fortigate][appid]" => "integer"
        "[logx][fortigate][countapp]" => "integer"
        "[logx][fortigate][rcvdbyte]" => "integer"
        "[logx][fortigate][rcvdpkt]" => "integer"
        "[logx][fortigate][rcvddelta]" => "integer"
        "[logx][fortigate][sentbyte]" => "integer"
        "[logx][fortigate][sentdelta]" => "integer"
        "[logx][fortigate][sentpkt]" => "integer"
        "[logx][fortigate][policyid]" => "integer"
        "[logx][fortigate][eventtime]" => "integer"
        "[logx][fortigate][proto]" => "integer"
        "[logx][fortigate][countdns]" => "integer"
        "[logx][fortigate][remport]" => "integer"
        "[logx][fortigate][locport]" => "integer"
        }
   }


   #Generating action field for established connections
   #First for type traffic
   if ([logx][fortigate][type] and [logx][fortigate][action]) and ([logx][fortigate][type] == "traffic" and [logx][fortigate][action] != "deny") {
      mutate {
        add_field => { "[logx][utm][action]" => "Success" }
      }
   }
   #Then for type event
   else if ([logx][fortigate][type] and [logx][fortigate][type] == "event" ) {
       #Subtype system
       if ([logx][fortigate][subtype] and [logx][fortigate][action] and [logx][fortigate][status])
       and ([logx][fortigate][subtype] == "system" )
       and ( ([logx][fortigate][action] == "login" and [logx][fortigate][status] == "success")
       or [logx][fortigate][action] == "logout" ) {
          mutate {
            add_field => { "[logx][utm][action]" => "Success" }
          }
       }
       #Subtype vpn
       else if ([logx][fortigate][subtype] and [logx][fortigate][action]) and [logx][fortigate][subtype] == "vpn"
       and ([logx][fortigate][action] == "negotiate" or [logx][fortigate][action] == "ssl-new-con"
       or [logx][fortigate][action] == "install_sa" or [logx][fortigate][action] == "tunnel-stats"
       or [logx][fortigate][action] == "tunnel-up" or [logx][fortigate][action] == "tunnel-down"
       or [logx][fortigate][action] == "phase2-up" or [logx][fortigate][action] == "phase2-down") {
          mutate {
            add_field => { "[logx][utm][action]" => "Success" }
          }
       }
       #Subtype user
       else if ([logx][fortigate][subtype] and [logx][fortigate][action]) and [logx][fortigate][subtype] == "user"
       and (("-logon" in [logx][fortigate][action] or "-logoff" in [logx][fortigate][action] or "-logout" in [logx][fortigate][action] )
       or ("authentication" in [logx][fortigate][action] and ([logx][fortigate][status] and [logx][fortigate][status] == "success") ) ) {
          mutate {
            add_field => { "[logx][utm][action]" => "Success" }
          }
       }
       #Subtype endpoint
       else if ([logx][fortigate][subtype] and [logx][fortigate][action]) and [logx][fortigate][subtype] == "endpoint"
       and ( [logx][fortigate][action] == "add" or [logx][fortigate][action] == "close" ) {
          mutate {
            add_field => { "[logx][utm][action]" => "Success" }
          }
       }
   }
   #Then for types or subtypes related to utm
   else if [logx][fortigate][type] and [logx][fortigate][type] == "utm" {
       #Subtype webfilter
       if ([logx][fortigate][subtype] and [logx][fortigate][action])
       and ([logx][fortigate][subtype] == "webfilter" or [logx][fortigate][subtype] == "waf")
       and ( [logx][fortigate][action] == "passthrough" or [logx][fortigate][action] == "allow" or [logx][fortigate][action] == "allowed" ) {
          mutate {
            add_field => { "[logx][utm][action]" => "Success" }
          }
       }
       #Subtype dlp
       else if ([logx][fortigate][subtype] and [logx][fortigate][action]) and [logx][fortigate][subtype] == "dlp"
       and [logx][fortigate][action] != "block" and [logx][fortigate][action] != "drop" and [logx][fortigate][action] != "dropped" {
          mutate {
            add_field => { "[logx][utm][action]" => "Success" }
          }
       }
       #Subtype VoIP
       else if ([logx][fortigate][subtype] and [logx][fortigate][action]) and [logx][fortigate][subtype] == "voip"
       and [logx][fortigate][action] == "permit" {
          mutate {
            add_field => { "[logx][utm][action]" => "Success" }
          }
       }
       #Subtype Application
       else if ([logx][fortigate][subtype] and [logx][fortigate][action]) and [logx][fortigate][subtype] == "app-ctrl"
       and [logx][fortigate][action] == "pass" {
          mutate {
            add_field => { "[logx][utm][action]" => "Success" }
          }
       }
       #Subtype ssh
       else if ([logx][fortigate][subtype] and [logx][fortigate][action]) and [logx][fortigate][subtype] == "ssh"
       and [logx][fortigate][action] == "passthrough" {
          mutate {
            add_field => { "[logx][utm][action]" => "Success" }
          }
       }
   }
   #Then for type dns
   else if ([logx][fortigate][type] and [logx][fortigate][type] == "dns" ) {
       #Subtype dns-response
       if ([logx][fortigate][subtype] and [logx][fortigate][action]) and [logx][fortigate][subtype] == "dns-response"
       and [logx][fortigate][action] == "pass" {
          mutate {
            add_field => { "[logx][utm][action]" => "Success" }
          }
       }
    }

   #Finally, remove unnecessary fields
   mutate {
      remove_field => ["@version","path","message_rest","tags","kv_field"]
   }
 }
   #Also, remove unwanted fields if the message not match with conditions
   mutate {
      remove_field => ["original_log_message","headers"]
   }
}
'
WHERE id=901;
----------------------------------------------------------------------------------------------------------------------------------------
-- GITHUB  --
----------------------------------------------------------------------------------------------------------------------------------------
UPDATE utm_logstash_filter
SET filter_version='2.0.1',logstash_filter='filter {

# Github filter version 2.0.1
# Based on https://docs.github.com/es/developers/webhooks-and-events/webhooks/webhook-events-and-payloads (april 2022)
# and real logs comming from github integration
# Support json format

  split {
    field => "message"
    terminator => "<utm-log-separator>"
  }
  json {
    source => "message"
  }

    if (([organization][events_url] and [organization][events_url] =~/^(https:\/\/api.github.com\/)(.)+/ )
    or ([organization][url] and [organization][url] =~/^(https:\/\/api.github.com\/)(.)+/ )
    or ([organization][repos_url] and [organization][repos_url] =~/^(https:\/\/api.github.com\/)(.)+/ )
    or ([repository][url] and [repository][url] =~/^(https:\/\/api.github.com\/)(.)+/)
    or ([sender][url] and [sender][url] =~/^(https:\/\/api.github.com\/)(.)+/)
    or ([sender][repos_url] and [sender][repos_url] =~/^(https:\/\/api.github.com\/)(.)+/)
    or ([installation][account][repos_url] and [installation][account][repos_url] =~/^(https:\/\/api.github.com\/)(.)+/)
    or ([installation][account][url] and [installation][account][url] =~/^(https:\/\/api.github.com\/)(.)+/) ) {

#......................................................................#
#Generating dataSource field required by CurrelationRulesEngine
#Checks if exists, if not evaluate to github
        if (![dataSource]){
           mutate {
              add_field => { "dataSource" => "github" }
           }
        }
#......................................................................#
#Generating dataType field required by CurrelationRulesEngine
           mutate {
              add_field => { "dataType" => "github" }
           }
#......................................................................#
# Adding fields to logx structure
           mutate {
              rename => { "action" => "[logx][github][action]" }
              rename => { "after" => "[logx][github][after]" }
              rename => { "assignee" => "[logx][github][assignee]" }
              rename => { "base_ref" => "[logx][github][base_ref]" }
              rename => { "before" => "[logx][github][before]" }
              rename => { "check_run" => "[logx][github][check_run]" }
              rename => { "check_suite" => "[logx][github][check_suite]" }
              rename => { "commits" => "[logx][github][commits]" }
              rename => { "compare" => "[logx][github][compare]" }
              rename => { "created" => "[logx][github][created]" }
              rename => { "deleted" => "[logx][github][deleted]" }
              rename => { "description" => "[logx][github][description]" }
              rename => { "forced" => "[logx][github][forced]" }
              rename => { "head_commit" => "[logx][github][head_commit]" }
              rename => { "headers" => "[logx][github][headers]" }
              rename => { "issue" => "[logx][github][issue]" }
              rename => { "label" => "[logx][github][label]" }
              rename => { "master_branch" => "[logx][github][master_branch]" }
              rename => { "number" => "[logx][github][number]" }
              rename => { "organization" => "[logx][github][organization]" }
              rename => { "pull_request" => "[logx][github][pull_request]" }
              rename => { "pusher" => "[logx][github][pusher]" }
              rename => { "pusher_type" => "[logx][github][pusher_type]" }
              rename => { "ref" => "[logx][github][ref]" }
              rename => { "ref_type" => "[logx][github][ref_type]" }
              rename => { "release" => "[logx][github][release]" }
              rename => { "repository" => "[logx][github][repository]" }
              rename => { "sender" => "[logx][github][sender]" }
              rename => { "starred_at" => "[logx][github][starred_at]" }
              rename => { "workflow" => "[logx][github][workflow]" }
              rename => { "workflow_job" => "[logx][github][workflow_job]" }
              rename => { "workflow_run" => "[logx][github][workflow_run]" }

              # New fields from version 1.0.2
              rename => { "invitation" => "[logx][github][invitation]" }
              rename => { "membership" => "[logx][github][membership]" }
              rename => { "alert" => "[logx][github][alert]" }

              # New fields from version 1.0.3
              rename => { "installation" => "[logx][github][installation]" }
              rename => { "rule" => "[logx][github][rule]" }
              rename => { "changes" => "[logx][github][changes]" }
              rename => { "requested_action" => "[logx][github][requested_action]" }
              rename => { "commit_oid" => "[logx][github][commit_oid]" }
              rename => { "comment" => "[logx][github][comment]" }
              rename => { "key" => "[logx][github][key]" }
              rename => { "deployment" => "[logx][github][deployment]" }
              rename => { "deployment_status" => "[logx][github][deployment_status]" }
              rename => { "discussion" => "[logx][github][discussion]" }
              rename => { "forkee" => "[logx][github][forkee]" }
              rename => { "pages" => "[logx][github][pages]" }
              rename => { "repository_selection" => "[logx][github][repository_selection]" }
              rename => { "repositories_added" => "[logx][github][repositories_added]" }
              rename => { "repositories_removed" => "[logx][github][repositories_removed]" }
              rename => { "effective_date" => "[logx][github][effective_date]" }
              rename => { "marketplace_purchase" => "[logx][github][marketplace_purchase]" }
              rename => { "member" => "[logx][github][member]" }
              rename => { "scope" => "[logx][github][scope]" }
              rename => { "team" => "[logx][github][team]" }
              rename => { "hook_id" => "[logx][github][hook_id]" }
              rename => { "hook" => "[logx][github][hook]" }
              rename => { "milestone" => "[logx][github][milestone]" }
              rename => { "blocked_user" => "[logx][github][blocked_user]" }
              rename => { "package" => "[logx][github][package]" }
              rename => { "build" => "[logx][github][build]" }
              rename => { "zen" => "[logx][github][zen]" }
              rename => { "project" => "[logx][github][project]" }
              rename => { "after_id" => "[logx][github][after_id]" }
              rename => { "project_card" => "[logx][github][project_card]" }
              rename => { "project_column" => "[logx][github][project_column]" }
              rename => { "number" => "[logx][github][number]" }
              rename => { "review" => "[logx][github][review]" }
              rename => { "thread" => "[logx][github][thread]" }
              rename => { "client_payload" => "[logx][github][client_payload]" }
              rename => { "branch" => "[logx][github][branch]" }
              rename => { "status" => "[logx][github][status]" }
              rename => { "security_advisory" => "[logx][github][security_advisory]" }
              rename => { "sponsorship" => "[logx][github][sponsorship]" }
              rename => { "sha" => "[logx][github][sha]" }
              rename => { "state" => "[logx][github][state]" }
              rename => { "target_url" => "[logx][github][target_url]" }
              rename => { "branches" => "[logx][github][branches]" }
              rename => { "name" => "[logx][github][name]" }
              rename => { "context" => "[logx][github][context]" }
              rename => { "inputs" => "[logx][github][inputs]" }
              rename => { "id" => "[logx][github][id]" }
              rename => { "message" => "[logx][github][message]" }
           }
       #Finally, remove unnecessary fields
       mutate {
          remove_field => ["@version","path"]
       }
    }
   #Also, remove unwanted fields if the message not match with conditions
   mutate {
      remove_field => ["[logx][github][headers]","headers"]
   }
}
'
WHERE id=1505;
----------------------------------------------------------------------------------------------------------------------------------------
-- UFW  --
----------------------------------------------------------------------------------------------------------------------------------------
UPDATE utm_logstash_filter
SET filter_version='2.0.1',logstash_filter='filter {
    # Linux UFW filter version 2.0.1
    split {
      field => "message"
      terminator => "<utm-log-separator>"
    }

    #Looking for datasource generated by an agent and parse original message
    if [message]=~/\[utm_stack_agent_ds=(.+)\]-(.+)/ {
      grok {
        match => {
          "message" => [ "\[utm_stack_agent_ds=%{DATA:dataSource}\]-%{GREEDYDATA:original_log_message}" ]
        }
      }
    }
    if [original_log_message] {
      mutate {
        update => { "message" => "%{[original_log_message]}" }
      }
    }

    if ![dataType]{
      if [message] {
        grok {
            match => {
                "message" => [
                    "%{SYSLOGTIMESTAMP:timestamp} %{SYSLOGHOST:ufwDataSource} %{DATA:process}(?:\[%{POSINT:pid}\])?:( \[%{NUMBER}\])? \[UFW %{WORD:ufw_action}\] IN=%{DATA:ufw_interface} OUT= MAC=%{DATA:ufw_mac} SRC=%{IP:ufw_src_ip} DST=%{IP:ufw_dest_ip} %{GREEDYDATA} PROTO=%{WORD:ufw_proto} SPT=%{INT:ufw_src_port} DPT=%{INT:ufw_dst_port} %{GREEDYDATA}",
                    "%{GREEDYDATA}%{SYSLOGTIMESTAMP:timestamp} %{SYSLOGHOST:ufwDataSource} %{DATA:process}(?:\[%{POSINT:pid}\])?:( \[%{NUMBER}\])? \[UFW %{WORD:ufw_action}\] IN=%{DATA:ufw_interface} OUT= MAC=%{DATA:ufw_mac} SRC=%{IP:ufw_src_ip} DST=%{IP:ufw_dest_ip} %{GREEDYDATA} PROTO=%{WORD:ufw_proto} SPT=%{INT:ufw_src_port} DPT=%{INT:ufw_dst_port} %{GREEDYDATA}"
                ]
            }
        }
      }
    }

#......................................................................#
#Generating dataSource field required by CurrelationRulesEngine
#Checks if ufwDataSource exists, if true, the dataSource field take its value, if not, take the agent dataSource value
    if ([ufwDataSource]){
        if [dataSource] {
          mutate {
            update => { "dataSource" => "%{[ufwDataSource]}" }
          }
        } else {
          mutate {
            add_field => { "dataSource" => "%{ufwDataSource}" }
          }
        }
    }
#Finally evaluates to the host variable if can not be calculated
    if ![dataSource] {
       mutate {
          add_field => { "dataSource" => "%{host}" }
       }
    }

    if [ufw_action] and ([ufw_action] == "BLOCK" or [ufw_action] == "ALLOW") {
        mutate {
            remove_field => [ "message" ]
            add_field => {"[dataType]" => "firewall-ufw"}
            rename => {
                "[process]" => "[logx][ufw][process]"
            }
            rename => {
                "[pid]" => "[logx][ufw][pid]"
            }
            rename => {
                "[ufw_action]" => "[logx][ufw][action]"
            }
            rename => {
                "[ufw_interface]" => "[logx][ufw][interface]"
            }
            rename => {
                "[ufw_mac]" => "[logx][ufw][mac]"
            }
            rename => {
                "[ufw_src_ip]" => "[logx][ufw][src_ip]"
            }
            rename => {
                "[ufw_dest_ip]" => "[logx][ufw][dest_ip]"
            }
            rename => {
                "[ufw_proto]" => "[logx][ufw][proto]"
            }
            rename => {
                "[ufw_src_port]" => "[logx][ufw][src_port]"
            }
            rename => {
                "[ufw_dst_port]" => "[logx][ufw][dest_port]"
            }
            rename => {
                "[timestamp]" => "[logx][ufw][timestamp]"
            }
        }
    }
   #Also, remove unwanted fields if the message not match with conditions
   mutate {
      remove_field => ["@version","ufwDataSource","original_log_message","headers"]
   }
}
'
WHERE id=1506;
----------------------------------------------------------------------------------------------------------------------------------------
-- LINUX LOGS  --
----------------------------------------------------------------------------------------------------------------------------------------
UPDATE utm_logstash_filter
SET filter_version='2.0.2',logstash_filter='filter {
    # Linux filter version 2.0.2
    split {
      field => "message"
      terminator => "<utm-log-separator>"
    }

    #Looking for datasource generated by an agent and parse original message
    if [message]=~/\[utm_stack_agent_ds=(.+)\]-(.+)/ {
      grok {
        match => {
          "message" => [ "\[utm_stack_agent_ds=%{DATA:dataSource}\]-%{GREEDYDATA:original_log_message}" ]
        }
      }
    }
    if [original_log_message] {
      mutate {
        update => { "message" => "%{[original_log_message]}" }
      }
    }

    if ![dataType]{
      if [message] and !([message]=~/\[UFW \w+\]/){
        grok {
            match => {
                "message" => [
                    "%{SYSLOGTIMESTAMP:timestamp} %{SYSLOGHOST:rsyslogDataSource} %{DATA:process}(\[%{POSINT:pid}\])?: %{GREEDYDATA:msg}",
                    "%{GREEDYDATA}%{SYSLOGTIMESTAMP:timestamp} %{SYSLOGHOST:rsyslogDataSource} %{DATA:process}(\[%{POSINT:pid}\])?: %{GREEDYDATA:msg}"
                ]
            }
        }

        #......................................................................#
        #Generating dataSource field required by CurrelationRulesEngine
        #Checks if rsyslogDataSource exists, if true, the dataSource field take its value, if not, take the agent dataSource value
        if ([rsyslogDataSource]){
            if [dataSource] {
              mutate {
                update => { "dataSource" => "%{[rsyslogDataSource]}" }
              }
            } else {
              mutate {
                add_field => { "dataSource" => "%{rsyslogDataSource}" }
              }
            }
        }
        #Finally evaluates to the host variable if can not be calculated
        if ![dataSource] {
           mutate {
              add_field => { "dataSource" => "%{host}" }
           }
        }

        if [timestamp] and [dataSource] and [process]{
            mutate {
              remove_field => [ "message" ]
              #Generating dataType field required by CurrelationRulesEngine
              add_field => {"[dataType]" => "rsyslog-linux"}

              # Rename fields
              rename => { "[process]" => "[logx][rsyslog_linux][process]" }
              rename => { "[pid]" => "[logx][rsyslog_linux][pid]" }
              rename => { "[msg]" => "[logx][rsyslog_linux][msg]" }

              #Finally, remove unnecessary fields
              remove_field => ["timestamp", "@version","path","type"]
           }
        }
      }
    }
   #Also, remove unwanted fields if the message not match with conditions
   mutate {
      remove_field => ["@version","rsyslogDataSource","original_log_message","headers"]
   }
}
'
WHERE id=1516;
----------------------------------------------------------------------------------------------------------------------------------------
-- MACOS  --
----------------------------------------------------------------------------------------------------------------------------------------
UPDATE utm_logstash_filter
SET filter_version='3.0.0',logstash_filter='filter {
# MacOS filter, version 3.0.0

split {
 field => "message"
 terminator => "<utm-log-separator>"
}

#Looking for datasource generated by an agent and parse original message
if [message]=~/\[utm_stack_agent_ds=(.+)\]-(.+)/ {
  grok {
    match => {
     "message" => [ "\[utm_stack_agent_ds=%{DATA:dataSource}\]-%{GREEDYDATA:original_log_message}" ]
    }
  }
}
if [original_log_message] {
  mutate {
    update => { "message" => "%{[original_log_message]}" }
  }
}
#......................................................................#
#Generating dataSource field required by CurrelationRulesEngine
if ![dataSource] {
  mutate {
    add_field => { "dataSource" => "%{host}" }
  }
}
#......................................................................#
#Generating logx structure
  mutate {
    add_field => {"dataType" => "macos"}
    rename => ["message", "[logx][macos][message]"]
  }

#Remove unwanted fields if the message not match with conditions
  mutate {
    remove_field => ["@version","original_log_message","headers"]
  }
}
'
WHERE id=1507;
----------------------------------------------------------------------------------------------------------------------------------------
-- MIKROTIK  --
----------------------------------------------------------------------------------------------------------------------------------------
UPDATE utm_logstash_filter
SET filter_version='2.0.1',logstash_filter='filter {

# Mikrotik firewall filter version 2.0.1
# Based on https://wiki.mikrotik.com/wiki/Manual:System/Log (june, 2022)
# and https://wiki.mikrotik.com/wiki/Manual:Routing_Table_Matcher (june, 2022)
# and https://datatracker.ietf.org/doc/html/rfc3164 (june, 2022)
# and example logs provided

    split {
      field => "message"
      terminator => "<utm-log-separator>"
    }

    #Looking for datasource generated by an agent and parse original message
    if [message]=~/\[utm_stack_agent_ds=(.+)\]-(.+)/ {
      grok {
       match => {
          "message" => [ "\[utm_stack_agent_ds=%{DATA:dataSource}\]-%{GREEDYDATA:original_log_message}" ]
        }
      }
    }
    if [original_log_message] {
      mutate {
        update => { "message" => "%{[original_log_message]}" }
      }
    }

    if ![dataType] {
        #First, search for common fields to define the entry point
        if [message] and ([message]=~/firewall,(.+):(\s)in:/) and ("out:" in [message] and "src-mac" in [message] and "proto" in [message] and "len" in [message]) {
#......................................................................#
#Generating dataSource field required by CurrelationRulesEngine
#Checks if exists, if not evaluate to the host variable
           if (![dataSource]){
              mutate {
               add_field => { "dataSource" => "%{host}" }
              }
           }
#......................................................................#
#Generating dataType field required by CurrelationRulesEngine
              mutate {
               add_field => { "dataType" => "firewall-mikrotik" }
              }
#......................................................................#
#Using grok to parse header of the message
#First if message begins with time format
        if [message]=~/^\d/ {
          grok {
            match => {
              "message" => [
                 "(?<syslog_time>((2[0123])|([0-1][0-9])\:([0-5][0-9])\:([0-5][0-9]|60)))(\s)%{GREEDYDATA:mikrotik_msg}"
              ]
            }
          }
#else normal syslog RFC 3164
        }else {
          grok {
            match => {
              "message" => [
                 "(<%{NUMBER:priority}>)?(%{INT:syslog_version})?(\s)?(%{SYSLOGTIMESTAMP:syslog_time})?(\s)?%{GREEDYDATA:mikrotik_msg}"
              ]
            }
          }
        }
#......................................................................#
#If begins with, something like syslog with only time like: <181>1 11:06:31, needs to be parsed again
        if ![syslog_time] {
          if [mikrotik_msg] {
             grok {
               match => {
                 "mikrotik_msg" => [
                    "(?<syslog_time>((2[0123])|([0-1][0-9])\:([0-5][0-9])\:([0-5][0-9]|60)))(\s)%{GREEDYDATA:mikrotik_msg_tmp}"
                 ]
               }
             }
          #Set mikrotik_msg_tmp fieldname and value to mikrotik_msg (This one is used to parse the rest of the message field)
             mutate {
              rename => { "mikrotik_msg_tmp" => "mikrotik_msg" }
             }
          }
        }
#......................................................................#
#Using grok to parse rest of the message
        if [mikrotik_msg] {
          grok {
            match => {
              "mikrotik_msg" => [
                 "%{GREEDYDATA:topics}(\s)%{WORD:chain}:(\s)in:%{GREEDYDATA:in_iface}(\s)out:%{GREEDYDATA:out_iface}, src-mac %{DATA:src_mac}, proto %{GREEDYDATA:proto}, %{IP:src_ip}(\:%{INT:src_port})?->%{IP:dest_ip}(\:%{INT:dest_port})?, len %{INT:len}(%{GREEDYDATA:irrelevant})?"
              ]
            }
          }
        }
#......................................................................#
#Formatting number values
   mutate {
      convert => {
            "priority" => "integer"
            "len" => "integer"
            "src_port" => "integer"
            "dest_port" => "integer"
        }
   }
#......................................................................#
#Add the rest of fields to the tree structure
        mutate {
          rename => { "syslog_time" => "[logx][mikrotik_fw][syslog_time]" }
          rename => { "priority" => "[logx][mikrotik_fw][priority]" }
          rename => { "topics" => "[logx][mikrotik_fw][topics]" }
          rename => { "chain" => "[logx][mikrotik_fw][chain]" }
          rename => { "len" => "[logx][mikrotik_fw][len]" }
          rename => { "in_iface" => "[logx][mikrotik_fw][in_iface]" }
          rename => { "out_iface" => "[logx][mikrotik_fw][out_iface]" }
          rename => { "src_mac" => "[logx][mikrotik_fw][src_mac]" }
          rename => { "syslog_version" => "[logx][mikrotik_fw][syslog_version]" }
          rename => { "message" => "[logx][mikrotik_fw][message]" }

          #Rename fields used by correlation engine
          rename => { "src_ip" => "[logx][mikrotik_fw][src_ip]" }
          rename => { "src_port" => "[logx][mikrotik_fw][src_port]" }
          rename => { "dest_ip" => "[logx][mikrotik_fw][dest_ip]" }
          rename => { "dest_port" => "[logx][mikrotik_fw][dest_port]" }
          rename => { "proto" => "[logx][mikrotik_fw][proto]" }
        }


   #Finally, remove unnecessary fields
   mutate {
      remove_field => ["@version","path","tags","type","irrelevant","mikrotik_msg"]
   }
   #Generate action field
   if [logx][mikrotik_fw][src_ip] and [logx][mikrotik_fw][dest_ip] {
      if [logx][mikrotik_fw][proto] and ("TCP" in [logx][mikrotik_fw][proto]) {
        if ("FIN" in [logx][mikrotik_fw][proto] or "RST" in [logx][mikrotik_fw][proto] or "ACK" in [logx][mikrotik_fw][proto]){
          mutate { add_field => { "[logx][utm][action]" => "Success" } }
        }
      } else if [logx][mikrotik_fw][proto] and ([logx][mikrotik_fw][len] and [logx][mikrotik_fw][len]>0) {
          mutate { add_field => { "[logx][utm][action]" => "Success" } }
      }
   }
  }
 }
   #Also, remove unwanted fields if the message not match with conditions
   mutate {
      remove_field => ["@version","path","original_log_message","headers"]
   }
}
'
WHERE id=1508;
----------------------------------------------------------------------------------------------------------------------------------------
-- NETFLOW  --
----------------------------------------------------------------------------------------------------------------------------------------
UPDATE utm_logstash_filter
SET filter_version='2.0.1',logstash_filter='filter {

#Netflow filter bassed on https://www.cisco.com/en/US/technologies/tk648/tk362/technologies_white_paper09186a00800a3db9.html (february 2022)
#and http://www.iana.org/assignments/ipfix/ipfix.xhtml (february 2022)

#Filter version 2.0.1
   split {
     field => "message"
     terminator => "<utm-log-separator>"
   }

   #Looking for datasource generated by an agent and parse original message
   if [message]=~/\[utm_stack_agent_ds=(.+)\]-(.+)/ {
     grok {
       match => {
         "message" => [ "\[utm_stack_agent_ds=%{DATA:dataSource}\]-%{GREEDYDATA:original_log_message}" ]
       }
     }
   }
   if [original_log_message] {
     mutate {
       update => { "message" => "%{[original_log_message]}" }
     }
   }

   json {
     source => "message"
   }

   if [netflow]{
#......................................................................#
#Generating dataSource field required by CurrelationRulesEngine
#Checks if exists, if not evaluate to the host variable
   if (![dataSource]){
      mutate {
        add_field => { "dataSource" => "%{host}" }
      }
   }
#......................................................................#
#Generating dataType field required by CurrelationRulesEngine
      mutate {
        add_field => { "dataType" => "netflow" }
      }
#......................................................................#
#Generating fields required by correlation rules
      mutate {
        #Netflows v9 fields
        rename => {"[netflow][l4_src_port]" => "[logx][netflow][src_port]"}
        rename => {"[netflow][ipv4_src_addr]" => "[logx][netflow][src_ip]"}
        rename => {"[netflow][l4_dst_port]" => "[logx][netflow][dest_port]"}
        rename => {"[netflow][ipv4_dst_addr]" => "[logx][netflow][dest_ip]"}
        rename => {"[netflow][protocol]" => "[logx][netflow][proto]"}

        #IPFIX fields
        rename => {"[netflow][sourceTransportPort]" => "[logx][netflow][src_port]"}
        rename => {"[netflow][sourceIPv4Address]" => "[logx][netflow][src_ip]"}
        rename => {"[netflow][destinationTransportPort]" => "[logx][netflow][dest_port]"}
        rename => {"[netflow][destinationIPv4Address]" => "[logx][netflow][dest_ip]"}
        rename => {"[netflow][protocolIdentifier]" => "[logx][netflow][proto]"}
      }
#......................................................................#
#Generating logx tree structure
      mutate {
        #Netflows fields
        rename => {"[netflow]" => "[logx][netflow]"}
      }
#......................................................................#
#Finally, remove unnecessary fields
   mutate {
      remove_field => ["@version","path"]
   }
}
   #Also, remove unwanted fields if the message not match with conditions
   mutate {
      remove_field => ["original_log_message","headers"]
   }
}
'
WHERE id=1201;
----------------------------------------------------------------------------------------------------------------------------------------
-- PALOALTO FIREWALL  --
----------------------------------------------------------------------------------------------------------------------------------------
UPDATE utm_logstash_filter
SET filter_version='2.0.1',logstash_filter='filter {

# Palo Alto Firewall filter version 2.0.1
# Support Syslog CEF format
# Based on PAN-OS version 10.2
# https://docs.paloaltonetworks.com/pan-os/10-2/pan-os-admin/monitoring/use-syslog-for-monitoring/syslog-field-descriptions (june, 2022)
# https://docs.paloaltonetworks.com/resources/cef (june, 2022)

    split {
     field => "message"
     terminator => "<utm-log-separator>"
    }

    #Looking for datasource generated by an agent and parse original message
    if [message]=~/\[utm_stack_agent_ds=(.+)\]-(.+)/ {
      grok {
        match => {
          "message" => [ "\[utm_stack_agent_ds=%{DATA:dataSource}\]-%{GREEDYDATA:original_log_message}" ]
        }
      }
    }
    if [original_log_message] {
      mutate {
        update => { "message" => "%{[original_log_message]}" }
      }
    }

    if ![dataType] {
        #First, search to define the entry point contain CEF:, contain |something, or look for Palo Alto
        if [message] and ((("CEF:" in [message] or "LEEF:" in [message])
        and ([message] =~/\|(\w+)?(\s)?Palo(\s)Alto(\s)Networks(\s)?(\w+)?\|/
        and [message] =~/\|(\w+)?(\s)?PAN-OS(\s)?(\w+)?\|/))
        or ([message] =~/(.+),(\s)?(TRAFFIC|START|END)(\s)?,(\s)?(start|end|drop|deny)/)
        or ([message] =~/(.+),(\s)?(THREAT)(\s)?,(\s)?(data|dlp|dlp-non-file|file|flood|packet|scan|spyware|url|ml-virus|virus|vulnerability|wildfire|wildfire-virus)(\s)?,(.+)/)
        or ([message] =~/(.+),(\s)?(HIP-MATCH|IPTAG)(\s)?,(.+)/)
        or ([message] =~/(.+),(\s)?(GLOBALPROTECT)(\s)?,(\s)?(data|file|flood|packet|scan|spyware|url|virus|vulnerability|wildfire|wildfire-virus)(\s)?,(.+)/)
        or ([message] =~/(.+),(\s)?(USERID)(\s)?,(\s)?(login|logout|register-tag|unregister-tag)(\s)?,(.+)/)
        or ([message] =~/(.+),(\s)?(DECRYPTION)(\s)?,(.+),(\s)?(allow|deny|drop|drop ICMP|reset both|reset client|reset server)(\s)?,(.+)/)
        or ([message] =~/(.+),(\s)?(SCTP)(\s)?,(.+),(\s)?(allow|deny)(\s)?,(.+)/)
        or ([message] =~/(.+),(\s)?(CONFIG)(\s)?,(.+),(\s)?(add|clone|commit|delete|edit|move|rename|set)(\s)?,(.+)/)
        or ([message] =~/(.+),(\s)?(AUTHENTICATION|SYSTEM|CORRELATION)(\s)?,(\s)?(crypto|dhcp|dnsproxy|dos|general|global-protect|ha|hw|nat|ntpd|pbf|port|pppoe|ras|routing|satd|sslmgr|sslvpn|userid|url-filtering|vpn)(\s)?,(.+)/)
        or ([message] =~/(.+),(\s)?(GTP)(\s)?,(\s)?(start|end|drop|deny)(\s)?,(.+)/)){
#......................................................................#
#Generating dataSource field required by CurrelationRulesEngine
#Checks if exists, if not evaluate to the host variable
           if (![dataSource]){
              mutate {
               add_field => { "dataSource" => "%{host}" }
              }
           }
#......................................................................#
#Generating dataType field required by CurrelationRulesEngine
              mutate {
               add_field => { "dataType" => "firewall-paloalto" }
              }
#......................................................................#
#If CEF formatted log do the parsing of the message
        if ("CEF:" in [message] or "LEEF:" in [message]) {
#......................................................................#
#Using grok to parse header of the message
            grok {
              match => {
                "message" => [
                   "(%{INT:not_defined})?(\s)?(<%{NUMBER:priority}>)?(%{INT:syslog_version})?((\s)%{GREEDYDATA:syslog_date_host}(\s))?(?<format_type>(CEF|LEEF)):(\s)?(?<format_version>(%{INT}\.%{INT}|%{INT}))%{GREEDYDATA:cef_or_leef_msg_all}"
                ]
              }
            }
        }
        if ("CEF:" in [message] ) {
#......................................................................#
#Logs have different structure according to Firewall Log Types, so first, define Log Type
#Using grok to parse components of the cef_message
#......................................................................#
#FIREWALL LOGS
#......................................................................#
        if ([cef_or_leef_msg_all]){
          #Detect if its a Traffic log
          if ([message] =~/\|(TRAFFIC|traffic)\|/){
              grok {
               match => {
                 "cef_or_leef_msg_all" => [
                    "\|%{DATA:embDeviceVendor}\|%{DATA:embDeviceProduct}\|%{DATA:pa_sender_sw_version}\|%{DATA:pa_subtype}\|%{DATA:pa_type}\|%{DATA:severity}\|%{GREEDYDATA:cef_or_leef_msg}"
                  ]
               }
              }
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#Detect if its an url threat log
          } else if ([message] =~/\|(THREAT|threat)\|/ and [message] =~/\|(URL|url)\|/){
              grok {
               match => {
                 "cef_or_leef_msg_all" => [
                    "\|%{DATA:embDeviceVendor}\|%{DATA:embDeviceProduct}\|%{DATA:pa_sender_sw_version}\|%{DATA:pa_subtype}\|%{DATA:pa_type}\|%{DATA:severity}\|%{GREEDYDATA:cef_or_leef_msg}"
                  ]
               }
              }
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#Detect if its a data threat log
          } else if ([message] =~/\|(THREAT|threat)\|/ and [message] =~/\|(DATA|data|DLP|dlp|dlp-non-file|FILE|file)\|/){
              grok {
               match => {
                 "cef_or_leef_msg_all" => [
                    "\|%{DATA:embDeviceVendor}\|%{DATA:embDeviceProduct}\|%{DATA:pa_sender_sw_version}\|%{DATA:pa_subtype}\|%{DATA:pa_type}\|%{DATA:severity}\|%{GREEDYDATA:cef_or_leef_msg}"
                  ]
               }
              }
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#Detect if its a WildFire threat log
          } else if ([message] =~/\|(THREAT|threat)\|/ and [message] =~/\|(WILDFIRE|wildfire)\|/){
              grok {
               match => {
                 "cef_or_leef_msg_all" => [
                    "\|%{DATA:embDeviceVendor}\|%{DATA:embDeviceProduct}\|%{DATA:pa_sender_sw_version}\|%{DATA:pa_subtype}\|%{DATA:pa_type}\|%{DATA:severity}\|%{GREEDYDATA:cef_or_leef_msg}"
                  ]
               }
              }
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#Detect if its general threat log
          } else if ([message] =~/\|(THREAT|threat)\|/){
              grok {
               match => {
                 "cef_or_leef_msg_all" => [
                    "\|%{DATA:embDeviceVendor}\|%{DATA:embDeviceProduct}\|%{DATA:pa_sender_sw_version}\|%{DATA:pa_threatid}\|%{DATA:pa_type}\|%{DATA:severity}\|%{GREEDYDATA:cef_or_leef_msg}"
                  ]
               }
              }
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#Detect if its a Config log
          } else if ([message] =~/\|(CONFIG|config)\|/ ){
              grok {
               match => {
                 "cef_or_leef_msg_all" => [
                    "\|%{DATA:embDeviceVendor}\|%{DATA:embDeviceProduct}\|%{DATA:pa_sender_sw_version}\|%{DATA:pa_result}\|%{DATA:pa_type}\|%{DATA:severity}\|%{GREEDYDATA:cef_or_leef_msg}"
                  ]
               }
              }
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#Detect if its a System log
          } else if ([message] =~/\|(SYSTEM|system)\|/ ){
              grok {
               match => {
                 "cef_or_leef_msg_all" => [
                    "\|%{DATA:embDeviceVendor}\|%{DATA:embDeviceProduct}\|%{DATA:pa_sender_sw_version}\|%{DATA:pa_subtype}\|%{DATA:pa_type}\|%{DATA:severity}\|%{GREEDYDATA:cef_or_leef_msg}"
                  ]
               }
              }
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#Detect if its a HIP-MATCH log
          } else if ([message] =~/\|(HIP-MATCH|hip-match)\|/ ){
              grok {
               match => {
                 "cef_or_leef_msg_all" => [
                    "\|%{DATA:embDeviceVendor}\|%{DATA:embDeviceProduct}\|%{DATA:pa_sender_sw_version}\|%{DATA:pa_matchtype}\|%{DATA:pa_type}\|%{DATA:severity}\|%{GREEDYDATA:cef_or_leef_msg}"
                  ]
               }
              }
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#Detect if its an AUTHENTICATION log
          } else if ([message] =~/\|(AUTHENTICATION|authentication)\|/ ){
              grok {
               match => {
                 "cef_or_leef_msg_all" => [
                    "\|%{DATA:embDeviceVendor}\|%{DATA:embDeviceProduct}\|%{DATA:pa_sender_sw_version}\|%{DATA:pa_subtype}\|%{DATA:pa_type}\|%{DATA:severity}\|%{GREEDYDATA:cef_or_leef_msg}"
                  ]
               }
              }
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#Detect if its an USERID log
          } else if ([message] =~/\|(USERID|userid)\|/ ){
              grok {
               match => {
                 "cef_or_leef_msg_all" => [
                    "\|%{DATA:embDeviceVendor}\|%{DATA:embDeviceProduct}\|%{DATA:pa_sender_sw_version}\|%{DATA:pa_subtype}\|%{DATA:pa_type}\|%{DATA:severity}\|%{GREEDYDATA:cef_or_leef_msg}"
                  ]
               }
              }
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#Detect if its an IPTAG log
          } else if ([message] =~/\|(IPTAG|iptag)\|/ ){
              grok {
               match => {
                 "cef_or_leef_msg_all" => [
                    "\|%{DATA:embDeviceVendor}\|%{DATA:embDeviceProduct}\|%{DATA:pa_sender_sw_version}\|%{DATA:pa_subtype}\|%{DATA:pa_type}\|%{DATA:severity}\|%{GREEDYDATA:cef_or_leef_msg}"
                  ]
               }
              }
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#Detect if its a Tunnel log
          } else if ([message] =~/\|(START|start|END|end)\|(START|start|END|end)\|/ ){
              grok {
               match => {
                 "cef_or_leef_msg_all" => [
                    "\|%{DATA:embDeviceVendor}\|%{DATA:embDeviceProduct}\|%{DATA:pa_sender_sw_version}\|%{DATA:pa_subtype}\|%{DATA:pa_type}\|%{DATA:severity}\|%{GREEDYDATA:cef_or_leef_msg}"
                  ]
               }
              }
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#Detect if its a CORRELATION log
          } else if ([message] =~/\|(CORRELATION|correlation)\|/ ){
              grok {
               match => {
                 "cef_or_leef_msg_all" => [
                    "\|%{DATA:embDeviceVendor}\|%{DATA:embDeviceProduct}\|%{DATA:pa_sender_sw_version}\|%{DATA:pa_category}\|%{DATA:pa_type}\|%{DATA:severity}\|%{GREEDYDATA:cef_or_leef_msg}"
                  ]
               }
              }
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#Detect if its a GTP log
          } else if ([message] =~/\|(GTP|gtp)\|/ ){
              grok {
               match => {
                 "cef_or_leef_msg_all" => [
                    "\|%{DATA:embDeviceVendor}\|%{DATA:embDeviceProduct}\|%{DATA:pa_sender_sw_version}\|%{DATA:pa_subtype}\|%{DATA:pa_type}\|%{DATA:severity}\|%{GREEDYDATA:cef_or_leef_msg}"
                  ]
               }
              }
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#Detect if its a SCTP log
          } else if ([message] =~/\|(SCTP|sctp)\|/ ){
              grok {
               match => {
                 "cef_or_leef_msg_all" => [
                    "\|%{DATA:embDeviceVendor}\|%{DATA:embDeviceProduct}\|%{DATA:pa_sender_sw_version}\|%{DATA:pa_type}\|%{GREEDYDATA:cef_or_leef_msg}"
                  ]
               }
              }
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#Detect if its a GLOBALPROTECT log
          } else if ([message] =~/\|(GLOBALPROTECT|globalprotect)\|/ ){
              grok {
               match => {
                 "cef_or_leef_msg_all" => [
                    "\|%{DATA:embDeviceVendor}\|%{DATA:embDeviceProduct}\|%{DATA:pa_sender_sw_version}\|%{DATA:pa_type}\|%{DATA:pa_subtype}\|%{GREEDYDATA:cef_or_leef_msg}"
                  ]
               }
              }
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#Detect if its a DECRYPTION log
          } else if ([message] =~/\|(DECRYPTION|decryption)\|/ ){
              grok {
               match => {
                 "cef_or_leef_msg_all" => [
                    "\|%{DATA:embDeviceVendor}\|%{DATA:embDeviceProduct}\|%{DATA:pa_sender_sw_version}\|%{DATA:pa_type}\|%{DATA:pa_subtype}\|%{GREEDYDATA:cef_or_leef_msg}"
                  ]
               }
              }
          }
# END OF FIREWALL LOGS BY TYPE
        }
        }

#......................................................................#
#If CSV formatted log do the parsing of the message

        if ([message] and ([message] =~/(.+),(\s)?(TRAFFIC|START|END)(\s)?,(\s)?(start|end|drop|deny)/)
        or ([message] =~/(.+),(\s)?(THREAT)(\s)?,(\s)?(data|dlp|dlp-non-file|file|flood|packet|scan|spyware|url|ml-virus|virus|vulnerability|wildfire|wildfire-virus)(\s)?,(.+)/)
        or ([message] =~/(.+),(\s)?(HIP-MATCH|IPTAG)(\s)?,(.+)/)
        or ([message] =~/(.+),(\s)?(GLOBALPROTECT)(\s)?,(\s)?(data|file|flood|packet|scan|spyware|url|virus|vulnerability|wildfire|wildfire-virus)(\s)?,(.+)/)
        or ([message] =~/(.+),(\s)?(USERID)(\s)?,(\s)?(login|logout|register-tag|unregister-tag)(\s)?,(.+)/)
        or ([message] =~/(.+),(\s)?(DECRYPTION)(\s)?,(.+),(\s)?(allow|deny|drop|drop ICMP|reset both|reset client|reset server)(\s)?,(.+)/)
        or ([message] =~/(.+),(\s)?(SCTP)(\s)?,(.+),(\s)?(allow|deny)(\s)?,(.+)/)
        or ([message] =~/(.+),(\s)?(CONFIG)(\s)?,(.+),(\s)?(add|clone|commit|delete|edit|move|rename|set)(\s)?,(.+)/)
        or ([message] =~/(.+),(\s)?(AUTHENTICATION|SYSTEM|CORRELATION)(\s)?,(\s)?(crypto|dhcp|dnsproxy|dos|general|global-protect|ha|hw|nat|ntpd|pbf|port|pppoe|ras|routing|satd|sslmgr|sslvpn|userid|url-filtering|vpn)(\s)?,(.+)/)
        or ([message] =~/(.+),(\s)?(GTP)(\s)?,(\s)?(start|end|drop|deny)(\s)?,(.+)/)){
          grok {
            match => {
              "message" => [
                "(%{INT:not_defined})?(\s)?(<%{NUMBER:priority}>)?(%{INT:syslog_version})?(\s)?%{DATA:syslog_date_host}(\s)?%{NUMBER:FUTURE_USE},%{GREEDYDATA:csv_msg_all}"
              ]
            }
          }
          if ([csv_msg_all]){
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#If csv contain "" word+ ""
            if ([csv_msg_all] =~/(.+)""(.+)""(.+)/){
              mutate { gsub => [ "csv_msg_all", ''""(.+)""'', ''"\1"''] }
            }
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#Detect if its a TRAFFIC log
            if ([message] =~/(.+),(\s)?(TRAFFIC)(\s)?,(\s)?(start|end|drop|deny)(\s)?,(.+)/){
              csv {
                source => "csv_msg_all"
                skip_header => "true"
                columns => ["receive_time", "serial", "pa_type", "pa_subtype", "FUTURE_USE", "time_generated", "src",
                            "dst", "natsrc", "natdst", "rule", "srcuser", "dstuser", "app", "vsys", "from", "to", "inbound_if",
                            "outbound_if", "logset", "FUTURE_USE", "sessionid", "repeatcnt", "spt", "dpt", "natspt", "natdpt",
                            "flags", "proto", "act", "bytes", "bytes_sent", "bytes_received", "packets", "start", "elapsed",
                            "category", "FUTURE_USE", "seqno", "actionflags", "srcloc", "dstloc", "FUTURE_USE", "pkts_sent",
                            "pkts_received", "session_end_reason", "dg_hier_level_1", "dg_hier_level_2", "dg_hier_level_3",
                            "dg_hier_level_4","vsys_name", "device_name", "action_source", "src_uuid", "dst_uuid", "tunnelid_imsi",
                            "monitortag_imei", "parent_session_id", "parent_start_time", "tunnel", "assoc_id", "chunks", "chunks_sent",
                            "chunks_received", "rule_uuid", "http2_connection", "link_change_count", "policy_id", "link_switches",
                            "sdwan_cluster", "sdwan_device_type", "sdwan_cluster_type", "sdwan_site", "dynusergroup_name", "xff_ip",
                            "src_category", "src_profile", "src_model", "src_vendor", "src_osfamily", "src_osversion", "src_host",
                            "src_mac", "dst_category", "dst_profile", "dst_model", "dst_vendor", "dst_osfamily", "dst_osversion",
                            "dst_host", "dst_mac", "container_id", "pod_namespace", "pod_name", "src_edl", "dst_edl", "hostid",
                            "serialnumber", "src_dag", "dst_dag", "session_owner", "high_res_timestamp", "nsdsai_sst", "nsdsai_sd",
                            "subcategory_of_app", "category_of_app", "technology_of_app", "risk_of_app", "characteristic_of_app",
                            "container_of_app", "tunneled_app", "is_saas_of_app", "sanctioned_state_of_app", "offloaded"]
            }
                      #......................................................................#
# Rename fields of TRAFFIC log
              mutate {
                rename => { "[receive_time]" => "[kv_field][receive_time]" }
                rename => { "[serial]" => "[kv_field][serial]" }
                rename => { "[pa_type]" => "[kv_field][pa_type]" }
                rename => { "[pa_subtype]" => "[kv_field][pa_subtype]" }
                rename => { "[time_generated]" => "[kv_field][time_generated]" }
                rename => { "[src]" => "[kv_field][src]" }
                rename => { "[dst]" => "[kv_field][dst]" }
                rename => { "[natsrc]" => "[kv_field][natsrc]" }
                rename => { "[natdst]" => "[kv_field][natdst]" }
                rename => { "[rule]" => "[kv_field][rule]" }
                rename => { "[srcuser]" => "[kv_field][srcuser]" }
                rename => { "[dstuser]" => "[kv_field][dstuser]" }
                rename => { "[app]" => "[kv_field][app]" }
                rename => { "[vsys]" => "[kv_field][vsys]" }
                rename => { "[from]" => "[kv_field][from]" }
                rename => { "[to]" => "[kv_field][to]" }
                rename => { "[inbound_if]" => "[kv_field][inbound_if]" }
                rename => { "[outbound_if]" => "[kv_field][outbound_if]" }
                rename => { "[logset]" => "[kv_field][logset]" }
                rename => { "[sessionid]" => "[kv_field][sessionid]" }
                rename => { "[repeatcnt]" => "[kv_field][repeatcnt]" }
                rename => { "[spt]" => "[kv_field][spt]" }
                rename => { "[dpt]" => "[kv_field][dpt]" }
                rename => { "[natspt]" => "[kv_field][natspt]" }
                rename => { "[natdpt]" => "[kv_field][natdpt]" }
                rename => { "[flags]" => "[kv_field][flags]" }
                rename => { "[proto]" => "[kv_field][proto]" }
                rename => { "[act]" => "[kv_field][act]" }
                rename => { "[bytes]" => "[kv_field][bytes]" }
                rename => { "[bytes_sent]" => "[kv_field][bytes_sent]" }
                rename => { "[bytes_received]" => "[kv_field][bytes_received]" }
                rename => { "[packets]" => "[kv_field][packets]" }
                rename => { "[start]" => "[kv_field][start]" }
                rename => { "[elapsed]" => "[kv_field][elapsed]" }
                rename => { "[category]" => "[kv_field][category]" }
                rename => { "[seqno]" => "[kv_field][seqno]" }
                rename => { "[actionflags]" => "[kv_field][actionflags]" }
                rename => { "[srcloc]" => "[kv_field][srcloc]" }
                rename => { "[dstloc]" => "[kv_field][dstloc]" }
                rename => { "[pkts_sent]" => "[kv_field][pkts_sent]" }
                rename => { "[pkts_received]" => "[kv_field][pkts_received]" }
                rename => { "[session_end_reason]" => "[kv_field][session_end_reason]" }
                rename => { "[dg_hier_level_1]" => "[kv_field][dg_hier_level_1]" }
                rename => { "[dg_hier_level_2]" => "[kv_field][dg_hier_level_2]" }
                rename => { "[dg_hier_level_3]" => "[kv_field][dg_hier_level_3]" }
                rename => { "[dg_hier_level_4]" => "[kv_field][dg_hier_level_4]" }
                rename => { "[vsys_name]" => "[kv_field][vsys_name]" }
                rename => { "[device_name]" => "[kv_field][device_name]" }
                rename => { "[action_source]" => "[kv_field][action_source]" }
                rename => { "[src_uuid]" => "[kv_field][src_uuid]" }
                rename => { "[dst_uuid]" => "[kv_field][dst_uuid]" }
                rename => { "[tunnelid_imsi]" => "[kv_field][tunnelid_imsi]" }
                rename => { "[monitortag_imei]" => "[kv_field][monitortag_imei]" }
                rename => { "[parent_session_id]" => "[kv_field][parent_session_id]" }
                rename => { "[parent_start_time]" => "[kv_field][parent_start_time]" }
                rename => { "[tunnel]" => "[kv_field][tunnel]" }
                rename => { "[assoc_id]" => "[kv_field][assoc_id]" }
                rename => { "[chunks]" => "[kv_field][chunks]" }
                rename => { "[chunks_sent]" => "[kv_field][chunks_sent]" }
                rename => { "[chunks_received]" => "[kv_field][chunks_received]" }
                rename => { "[rule_uuid]" => "[kv_field][rule_uuid]" }
                rename => { "[http2_connection]" => "[kv_field][http2_connection]" }
                rename => { "[link_change_count]" => "[kv_field][link_change_count]" }
                rename => { "[policy_id]" => "[kv_field][policy_id]" }
                rename => { "[link_switches]" => "[kv_field][link_switches]" }
                rename => { "[sdwan_cluster]" => "[kv_field][sdwan_cluster]" }
                rename => { "[sdwan_device_type]" => "[kv_field][sdwan_device_type]" }
                rename => { "[sdwan_cluster_type]" => "[kv_field][sdwan_cluster_type]" }
                rename => { "[sdwan_site]" => "[kv_field][sdwan_site]" }
                rename => { "[dynusergroup_name]" => "[kv_field][dynusergroup_name]" }
                rename => { "[xff_ip]" => "[kv_field][xff_ip]" }
                rename => { "[src_category]" => "[kv_field][src_category]" }
                rename => { "[src_profile]" => "[kv_field][src_profile]" }
                rename => { "[src_model]" => "[kv_field][src_model]" }
                rename => { "[src_vendor]" => "[kv_field][src_vendor]" }
                rename => { "[src_osfamily]" => "[kv_field][src_osfamily]" }
                rename => { "[src_osversion]" => "[kv_field][src_osversion]" }
                rename => { "[src_host]" => "[kv_field][src_host]" }
                rename => { "[src_mac]" => "[kv_field][src_mac]" }
                rename => { "[dst_category]" => "[kv_field][dst_category]" }
                rename => { "[dst_profile]" => "[kv_field][dst_profile]" }
                rename => { "[dst_model]" => "[kv_field][dst_model]" }
                rename => { "[dst_vendor]" => "[kv_field][dst_vendor]" }
                rename => { "[dst_osfamily]" => "[kv_field][dst_osfamily]" }
                rename => { "[dst_osversion]" => "[kv_field][dst_osversion]" }
                rename => { "[dst_host]" => "[kv_field][dst_host]" }
                rename => { "[dst_mac]" => "[kv_field][dst_mac]" }
                rename => { "[container_id]" => "[kv_field][container_id]" }
                rename => { "[pod_namespace]" => "[kv_field][pod_namespace]" }
                rename => { "[pod_name]" => "[kv_field][pod_name]" }
                rename => { "[src_edl]" => "[kv_field][src_edl]" }
                rename => { "[dst_edl]" => "[kv_field][dst_edl]" }
                rename => { "[hostid]" => "[kv_field][hostid]" }
                rename => { "[serialnumber]" => "[kv_field][serialnumber]" }
                rename => { "[src_dag]" => "[kv_field][src_dag]" }
                rename => { "[dst_dag]" => "[kv_field][dst_dag]" }
                rename => { "[session_owner]" => "[kv_field][session_owner]" }
                rename => { "[high_res_timestamp]" => "[kv_field][high_res_timestamp]" }
                rename => { "[nsdsai_sst]" => "[kv_field][nsdsai_sst]" }
                rename => { "[nsdsai_sd]" => "[kv_field][nsdsai_sd]" }
                rename => { "[subcategory_of_app]" => "[kv_field][subcategory_of_app]" }
                rename => { "[category_of_app]" => "[kv_field][category_of_app]" }
                rename => { "[technology_of_app]" => "[kv_field][technology_of_app]" }
                rename => { "[risk_of_app]" => "[kv_field][risk_of_app]" }
                rename => { "[characteristic_of_app]" => "[kv_field][characteristic_of_app]" }
                rename => { "[container_of_app]" => "[kv_field][container_of_app]" }
                rename => { "[tunneled_app]" => "[kv_field][tunneled_app]" }
                rename => { "[is_saas_of_app]" => "[kv_field][is_saas_of_app]" }
                rename => { "[sanctioned_state_of_app]" => "[kv_field][sanctioned_state_of_app]" }
                rename => { "[offloaded]" => "[kv_field][offloaded]" }
              }
            #--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#Detect if its a THREAT log
          }else if ([message] =~/(.+),(\s)?(THREAT)(\s)?,(\s)?(data|dlp|dlp-non-file|file|flood|packet|scan|spyware|url|ml-virus|virus|vulnerability|wildfire|wildfire-virus)(\s)?,(.+)/){
            csv {
              source => "csv_msg_all"
              skip_header => "true"
              columns => ["receive_time", "serial", "pa_type", "pa_subtype", "FUTURE_USE", "time_generated", "src",
                          "dst", "natsrc", "natdst", "rule", "srcuser", "dstuser", "app", "vsys", "from", "to", "inbound_if",
                          "outbound_if", "logset", "FUTURE_USE", "sessionid", "repeatcnt", "spt", "dpt", "natspt", "natdpt",
                          "flags", "proto", "act", "misc", "pa_threatid", "category", "severity", "direction",
                          "seqno", "actionflags", "srcloc", "dstloc", "FUTURE_USE", "contenttype", "pcap_id", "filedigest",
                          "cloud", "url_idx", "user_agent", "filetype", "xff", "referer", "sender", "subject", "recipient", "reportid",
                          "dg_hier_level_1", "dg_hier_level_2", "dg_hier_level_3", "dg_hier_level_4", "vsys_name", "device_name", "FUTURE_USE",
                          "src_uuid", "dst_uuid", "http_method", "tunnelid_imsi", "monitortag_imei", "parent_session_id", "parent_start_time",
                          "tunnel", "thr_category", "contentver", "FUTURE_USE", "assoc_id", "ppid", "http_headers", "url_category_list",
                          "rule_uuid", "http2_connection", "dynusergroup_name", "xff_ip", "src_category", "src_profile", "src_model",
                          "src_vendor", "src_osfamily", "src_osversion", "src_host", "src_mac", "dst_category", "dst_profile", "dst_model",
                          "dst_vendor", "dst_osfamily", "dst_osversion", "dst_host", "dst_mac", "container_id", "pod_namespace", "pod_name",
                          "src_edl", "dst_edl", "hostid", "serialnumber", "domain_edl", "src_dag", "dst_dag", "partial_hash", "high_res_timestamp",
                          "reason", "justification", "nssai_sst", "subcategory_of_app", "category_of_app", "technology_of_app", "risk_of_app",
                          "characteristic_of_app", "container_of_app", "tunneled_app", "is_saas_of_app", "sanctioned_state_of_app", "cloud_reportid"]
           }
                       #......................................................................#
# Rename fields of THREAT log
           mutate {
            rename => { "[receive_time]" => "[kv_field][receive_time]" }
            rename => { "[serial]" => "[kv_field][serial]" }
            rename => { "[pa_type]" => "[kv_field][pa_type]" }
            rename => { "[pa_subtype]" => "[kv_field][pa_subtype]" }
            rename => { "[time_generated]" => "[kv_field][time_generated]" }
            rename => { "[src]" => "[kv_field][src]" }
            rename => { "[dst]" => "[kv_field][dst]" }
            rename => { "[natsrc]" => "[kv_field][natsrc]" }
            rename => { "[natdst]" => "[kv_field][natdst]" }
            rename => { "[rule]" => "[kv_field][rule]" }
            rename => { "[srcuser]" => "[kv_field][srcuser]" }
            rename => { "[dstuser]" => "[kv_field][dstuser]" }
            rename => { "[app]" => "[kv_field][app]" }
            rename => { "[vsys]" => "[kv_field][vsys]" }
            rename => { "[from]" => "[kv_field][from]" }
            rename => { "[to]" => "[kv_field][to]" }
            rename => { "[inbound_if]" => "[kv_field][inbound_if]" }
            rename => { "[outbound_if]" => "[kv_field][outbound_if]" }
            rename => { "[logset]" => "[kv_field][logset]" }
            rename => { "[sessionid]" => "[kv_field][sessionid]" }
            rename => { "[repeatcnt]" => "[kv_field][repeatcnt]" }
            rename => { "[spt]" => "[kv_field][spt]" }
            rename => { "[dpt]" => "[kv_field][dpt]" }
            rename => { "[natspt]" => "[kv_field][natspt]" }
            rename => { "[natdpt]" => "[kv_field][natdpt]" }
            rename => { "[flags]" => "[kv_field][flags]" }
            rename => { "[proto]" => "[kv_field][proto]" }
            rename => { "[act]" => "[kv_field][act]" }
            rename => { "[misc]" => "[kv_field][misc]" }
            rename => { "[pa_threatid]" => "[kv_field][pa_threatid]" }
            rename => { "[category]" => "[kv_field][category]" }
            rename => { "[severity]" => "[kv_field][severity]" }
            rename => { "[direction]" => "[kv_field][direction]" }
            rename => { "[seqno]" => "[kv_field][seqno]" }
            rename => { "[actionflags]" => "[kv_field][actionflags]" }
            rename => { "[srcloc]" => "[kv_field][srcloc]" }
            rename => { "[dstloc]" => "[kv_field][dstloc]" }
            rename => { "[contenttype]" => "[kv_field][contenttype]" }
            rename => { "[pcap_id]" => "[kv_field][pcap_id]" }
            rename => { "[filedigest]" => "[kv_field][filedigest]" }
            rename => { "[cloud]" => "[kv_field][cloud]" }
            rename => { "[url_idx]" => "[kv_field][url_idx]" }
            rename => { "[user_agent]" => "[kv_field][user_agent]" }
            rename => { "[filetype]" => "[kv_field][filetype]" }
            rename => { "[xff]" => "[kv_field][xff]" }
            rename => { "[referer]" => "[kv_field][referer]" }
            rename => { "[sender]" => "[kv_field][sender]" }
            rename => { "[subject]" => "[kv_field][subject]" }
            rename => { "[recipient]" => "[kv_field][recipient]" }
            rename => { "[reportid]" => "[kv_field][reportid]" }
            rename => { "[dg_hier_level_1]" => "[kv_field][dg_hier_level_1]" }
            rename => { "[dg_hier_level_2]" => "[kv_field][dg_hier_level_2]" }
            rename => { "[dg_hier_level_3]" => "[kv_field][dg_hier_level_3]" }
            rename => { "[dg_hier_level_4]" => "[kv_field][dg_hier_level_4]" }
            rename => { "[vsys_name]" => "[kv_field][vsys_name]" }
            rename => { "[device_name]" => "[kv_field][device_name]" }
            rename => { "[src_uuid]" => "[kv_field][src_uuid]" }
            rename => { "[dst_uuid]" => "[kv_field][dst_uuid]" }
            rename => { "[http_method]" => "[kv_field][http_method]" }
            rename => { "[tunnelid_imsi]" => "[kv_field][tunnelid_imsi]" }
            rename => { "[monitortag_imei]" => "[kv_field][monitortag_imei]" }
            rename => { "[parent_session_id]" => "[kv_field][parent_session_id]" }
            rename => { "[parent_start_time]" => "[kv_field][parent_start_time]" }
            rename => { "[tunnel]" => "[kv_field][tunnel]" }
            rename => { "[thr_category]" => "[kv_field][thr_category]" }
            rename => { "[contentver]" => "[kv_field][contentver]" }
            rename => { "[assoc_id]" => "[kv_field][assoc_id]" }
            rename => { "[ppid]" => "[kv_field][ppid]" }
            rename => { "[http_headers]" => "[kv_field][http_headers]" }
            rename => { "[url_category_list]" => "[kv_field][url_category_list]" }
            rename => { "[rule_uuid]" => "[kv_field][rule_uuid]" }
            rename => { "[http2_connection]" => "[kv_field][http2_connection]" }
            rename => { "[dynusergroup_name]" => "[kv_field][dynusergroup_name]" }
            rename => { "[xff_ip]" => "[kv_field][xff_ip]" }
            rename => { "[src_category]" => "[kv_field][src_category]" }
            rename => { "[src_profile]" => "[kv_field][src_profile]" }
            rename => { "[src_model]" => "[kv_field][src_model]" }
            rename => { "[src_vendor]" => "[kv_field][src_vendor]" }
            rename => { "[src_osfamily]" => "[kv_field][src_osfamily]" }
            rename => { "[src_osversion]" => "[kv_field][src_osversion]" }
            rename => { "[src_host]" => "[kv_field][src_host]" }
            rename => { "[src_mac]" => "[kv_field][src_mac]" }
            rename => { "[dst_category]" => "[kv_field][dst_category]" }
            rename => { "[dst_profile]" => "[kv_field][dst_profile]" }
            rename => { "[dst_model]" => "[kv_field][dst_model]" }
            rename => { "[dst_vendor]" => "[kv_field][dst_vendor]" }
            rename => { "[dst_osfamily]" => "[kv_field][dst_osfamily]" }
            rename => { "[dst_osversion]" => "[kv_field][dst_osversion]" }
            rename => { "[dst_host]" => "[kv_field][dst_host]" }
            rename => { "[dst_mac]" => "[kv_field][dst_mac]" }
            rename => { "[container_id]" => "[kv_field][container_id]" }
            rename => { "[pod_namespace]" => "[kv_field][pod_namespace]" }
            rename => { "[pod_name]" => "[kv_field][pod_name]" }
            rename => { "[src_edl]" => "[kv_field][src_edl]" }
            rename => { "[dst_edl]" => "[kv_field][dst_edl]" }
            rename => { "[hostid]" => "[kv_field][hostid]" }
            rename => { "[serialnumber]" => "[kv_field][serialnumber]" }
            rename => { "[domain_edl]" => "[kv_field][domain_edl]" }
            rename => { "[src_dag]" => "[kv_field][src_dag]" }
            rename => { "[dst_dag]" => "[kv_field][dst_dag]" }
            rename => { "[partial_hash]" => "[kv_field][partial_hash]" }
            rename => { "[high_res_timestamp]" => "[kv_field][high_res_timestamp]" }
            rename => { "[reason]" => "[kv_field][reason]" }
            rename => { "[justification]" => "[kv_field][justification]" }
            rename => { "[nssai_sst]" => "[kv_field][nssai_sst]" }
            rename => { "[subcategory_of_app]" => "[kv_field][subcategory_of_app]" }
            rename => { "[category_of_app]" => "[kv_field][category_of_app]" }
            rename => { "[technology_of_app]" => "[kv_field][technology_of_app]" }
            rename => { "[risk_of_app]" => "[kv_field][risk_of_app]" }
            rename => { "[characteristic_of_app]" => "[kv_field][characteristic_of_app]" }
            rename => { "[container_of_app]" => "[kv_field][container_of_app]" }
            rename => { "[tunneled_app]" => "[kv_field][tunneled_app]" }
            rename => { "[is_saas_of_app]" => "[kv_field][is_saas_of_app]" }
            rename => { "[sanctioned_state_of_app]" => "[kv_field][sanctioned_state_of_app]" }
            rename => { "[cloud_reportid]" => "[kv_field][cloud_reportid]" }
           }
            #--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#Detect if its a HIP-MATCH log
          }else if ([message] =~/(.+),(\s)?(HIP-MATCH)(\s)?,(.+)/){
            csv {
              source => "csv_msg_all"
              skip_header => "true"
              columns => ["receive_time", "serial", "pa_type", "pa_subtype", "FUTURE_USE", "time_generated", "srcuser", "vsys",
                          "machinename", "os", "src", "matchname", "repeatcnt", "matchtype", "FUTURE_USE", "FUTURE_USE",
                          "seqno", "actionflags", "dg_hier_level_1", "dg_hier_level_2", "dg_hier_level_3", "dg_hier_level_4",
                          "vsys_name", "device_name", "vsys_id", "srcipv6", "hostid", "serialnumber", "mac", "high_res_timestamp"]
           }
           #......................................................................#
# Rename fields of HIP-MATCH log
          mutate {
            rename => { "[receive_time]" => "[kv_field][receive_time]" }
            rename => { "[serial]" => "[kv_field][serial]" }
            rename => { "[pa_type]" => "[kv_field][pa_type]" }
            rename => { "[pa_subtype]" => "[kv_field][pa_subtype]" }
            rename => { "[time_generated]" => "[kv_field][time_generated]" }
            rename => { "[srcuser]" => "[kv_field][srcuser]" }
            rename => { "[vsys]" => "[kv_field][vsys]" }
            rename => { "[machinename]" => "[kv_field][machinename]" }
            rename => { "[os]" => "[kv_field][os]" }
            rename => { "[src]" => "[kv_field][src]" }
            rename => { "[matchname]" => "[kv_field][matchname]" }
            rename => { "[repeatcnt]" => "[kv_field][repeatcnt]" }
            rename => { "[matchtype]" => "[kv_field][matchtype]" }
            rename => { "[seqno]" => "[kv_field][seqno]" }
            rename => { "[actionflags]" => "[kv_field][actionflags]" }
            rename => { "[dg_hier_level_1]" => "[kv_field][dg_hier_level_1]" }
            rename => { "[dg_hier_level_2]" => "[kv_field][dg_hier_level_2]" }
            rename => { "[dg_hier_level_3]" => "[kv_field][dg_hier_level_3]" }
            rename => { "[dg_hier_level_4]" => "[kv_field][dg_hier_level_4]" }
            rename => { "[vsys_name]" => "[kv_field][vsys_name]" }
            rename => { "[device_name]" => "[kv_field][device_name]" }
            rename => { "[vsys_id]" => "[kv_field][vsys_id]" }
            rename => { "[srcipv6]" => "[kv_field][srcipv6]" }
            rename => { "[hostid]" => "[kv_field][hostid]" }
            rename => { "[serialnumber]" => "[kv_field][serialnumber]" }
            rename => { "[mac]" => "[kv_field][mac]" }
            rename => { "[high_res_timestamp]" => "[kv_field][high_res_timestamp]" }
          }
          #--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#Detect if its a GLOBALPROTECT log
          }else if ([message] =~/(.+),(\s)?(GLOBALPROTECT)(\s)?,(\s)?(data|file|flood|packet|scan|spyware|url|virus|vulnerability|wildfire|wildfire-virus)(\s)?,(.+)/){
            csv {
              source => "csv_msg_all"
              skip_header => "true"
              columns => ["receive_time", "serial", "pa_type", "pa_subtype", "FUTURE_USE", "time_generated", "vsys","eventid",
                          "stage", "auth_method", "tunnel_type", "srcuser", "srcregion", "machinename", "public_ip", "public_ipv6",
                          "private_ip", "private_ipv6", "hostid", "serialnumber", "client_ver", "client_os", "client_os_ver",
                          "repeatcnt", "reason", "error", "opaque", "status", "location", "PanOSLoginDuration", "connect_method",
                          "error_code", "portal", "seqno", "actionflags", "high_res_timestamp", "selection_type", "response_time",
                          "priority", "attempted_gateways", "gateway", "dg_hier_level_1", "dg_hier_level_2", "dg_hier_level_3",
                          "dg_hier_level_4", "vsys_name", "device_name", "vsys_id"]
           }
#......................................................................#
# Rename fields of GLOBALPROTECT log
            mutate {
              rename => { "[receive_time]" => "[kv_field][receive_time]" }
              rename => { "[serial]" => "[kv_field][serial]" }
              rename => { "[pa_type]" => "[kv_field][pa_type]" }
              rename => { "[pa_subtype]" => "[kv_field][pa_subtype]" }
              rename => { "[time_generated]" => "[kv_field][time_generated]" }
              rename => { "[vsys]" => "[kv_field][vsys]" }
              rename => { "[eventid]" => "[kv_field][eventid]" }
              rename => { "[stage]" => "[kv_field][stage]" }
              rename => { "[auth_method]" => "[kv_field][auth_method]" }
              rename => { "[tunnel_type]" => "[kv_field][tunnel_type]" }
              rename => { "[srcuser]" => "[kv_field][srcuser]" }
              rename => { "[srcregion]" => "[kv_field][srcregion]" }
              rename => { "[machinename]" => "[kv_field][machinename]" }
              rename => { "[public_ip]" => "[kv_field][public_ip]" }
              rename => { "[public_ipv6]" => "[kv_field][public_ipv6]" }
              rename => { "[private_ip]" => "[kv_field][private_ip]" }
              rename => { "[private_ipv6]" => "[kv_field][private_ipv6]" }
              rename => { "[hostid]" => "[kv_field][hostid]" }
              rename => { "[serialnumber]" => "[kv_field][serialnumber]" }
              rename => { "[client_ver]" => "[kv_field][client_ver]" }
              rename => { "[client_os]" => "[kv_field][client_os]" }
              rename => { "[client_os_ver]" => "[kv_field][client_os_ver]" }
              rename => { "[repeatcnt]" => "[kv_field][repeatcnt]" }
              rename => { "[reason]" => "[kv_field][reason]" }
              rename => { "[error]" => "[kv_field][error]" }
              rename => { "[opaque]" => "[kv_field][opaque]" }
              rename => { "[status]" => "[kv_field][status]" }
              rename => { "[location]" => "[kv_field][location]" }
              rename => { "[PanOSLoginDuration]" => "[kv_field][PanOSLoginDuration]" }
              rename => { "[connect_method]" => "[kv_field][connect_method]" }
              rename => { "[error_code]" => "[kv_field][error_code]" }
              rename => { "[portal]" => "[kv_field][portal]" }
              rename => { "[seqno]" => "[kv_field][seqno]" }
              rename => { "[actionflags]" => "[kv_field][actionflags]" }
              rename => { "[high_res_timestamp]" => "[kv_field][high_res_timestamp]" }
              rename => { "[selection_type]" => "[kv_field][selection_type]" }
              rename => { "[response_time]" => "[kv_field][response_time]" }
              rename => { "[priority]" => "[kv_field][priority]" }
              rename => { "[attempted_gateways]" => "[kv_field][attempted_gateways]" }
              rename => { "[gateway]" => "[kv_field][gateway]" }
              rename => { "[dg_hier_level_1]" => "[kv_field][dg_hier_level_1]" }
              rename => { "[dg_hier_level_2]" => "[kv_field][dg_hier_level_2]" }
              rename => { "[dg_hier_level_3]" => "[kv_field][dg_hier_level_3]" }
              rename => { "[dg_hier_level_4]" => "[kv_field][dg_hier_level_4]" }
              rename => { "[vsys_name]" => "[kv_field][vsys_name]" }
              rename => { "[device_name]" => "[kv_field][device_name]" }
              rename => { "[vsys_id]" => "[kv_field][vsys_id]" }
            }
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#Detect if its a IPTAG log
          }else if([message] =~/(.+),(\s)?(.+),(\s)?(IPTAG)(\s)?,(.+)/){
              csv {
              source => "csv_msg_all"
              skip_header => "true"
              columns => ["receive_time", "serial", "pa_type", "pa_subtype", "FUTURE_USE", "time_generated", "vsys", "src", "tag_name",
                          "event_id", "repeatcnt", "timeout", "datasourcename", "datasource_type", "datasource_subtype", "seqno",
                          "actionflags", "dg_hier_level_1", "dg_hier_level_2", "dg_hier_level_3", "dg_hier_level_4", "vsys_name",
                          "device_name", "vsys_id", "high_res_timestamp"]
           }
#......................................................................#
# Rename fields of IPTAG log
            mutate {
              rename => { "[receive_time]" => "[kv_field][receive_time]" }
              rename => { "[serial]" => "[kv_field][serial]" }
              rename => { "[pa_type]" => "[kv_field][pa_type]" }
              rename => { "[pa_subtype]" => "[kv_field][pa_subtype]" }
              rename => { "[time_generated]" => "[kv_field][time_generated]" }
              rename => { "[vsys]" => "[kv_field][vsys]" }
              rename => { "[src]" => "[kv_field][src]" }
              rename => { "[tag_name]" => "[kv_field][tag_name]" }
              rename => { "[event_id]" => "[kv_field][event_id]" }
              rename => { "[repeatcnt]" => "[kv_field][repeatcnt]" }
              rename => { "[timeout]" => "[kv_field][timeout]" }
              rename => { "[datasourcename]" => "[kv_field][datasourcename]" }
              rename => { "[datasource_type]" => "[kv_field][datasource_type]" }
              rename => { "[datasource_subtype]" => "[kv_field][datasource_subtype]" }
              rename => { "[seqno]" => "[kv_field][seqno]" }
              rename => { "[actionflags]" => "[kv_field][actionflags]" }
              rename => { "[dg_hier_level_1]" => "[kv_field][dg_hier_level_1]" }
              rename => { "[dg_hier_level_2]" => "[kv_field][dg_hier_level_2]" }
              rename => { "[dg_hier_level_3]" => "[kv_field][dg_hier_level_3]" }
              rename => { "[dg_hier_level_4]" => "[kv_field][dg_hier_level_4]" }
              rename => { "[vsys_name]" => "[kv_field][vsys_name]" }
              rename => { "[device_name]" => "[kv_field][device_name]" }
              rename => { "[vsys_id]" => "[kv_field][vsys_id]" }
              rename => { "[high_res_timestamp]" => "[kv_field][high_res_timestamp]" }
            }
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#Detect if its a USERID log
          }else if ([message] =~/(.+),(\s)?(USERID)(\s)?,(\s)?(login|logout|register-tag|unregister-tag)(\s)?,(.+)/){
            csv {
              source => "csv_msg_all"
              skip_header => "true"
              columns => ["receive_time", "serial", "pa_type", "pa_subtype", "FUTURE_USE", "time_generated", "vsys", "src", "user",
                          "datasourcename", "event_id", "repeatcnt", "timeout", "beginport", "endport", "datasource", "datasource_type", "seqno",
                          "actionflags", "dg_hier_level_1", "dg_hier_level_2", "dg_hier_level_3", "dg_hier_level_4", "vsys_name",
                          "device_name", "vsys_id", "factortype", "factorcompletiontime", "factorno", "FUTURE_USE", "FUTURE_USE", "ugflags", "userbysource", "high_res_timestamp"]
           }
#......................................................................#
# Rename fields of USERID log
            mutate {
              rename => { "[receive_time]" => "[kv_field][receive_time]" }
              rename => { "[serial]" => "[kv_field][serial]" }
              rename => { "[pa_type]" => "[kv_field][pa_type]" }
              rename => { "[pa_subtype]" => "[kv_field][pa_subtype]" }
              rename => { "[time_generated]" => "[kv_field][time_generated]" }
              rename => { "[vsys]" => "[kv_field][vsys]" }
              rename => { "[src]" => "[kv_field][src]" }
              rename => { "[user]" => "[kv_field][user]" }
              rename => { "[datasourcename]" => "[kv_field][datasourcename]" }
              rename => { "[event_id]" => "[kv_field][event_id]" }
              rename => { "[repeatcnt]" => "[kv_field][repeatcnt]" }
              rename => { "[timeout]" => "[kv_field][timeout]" }
              rename => { "[beginport]" => "[kv_field][beginport]" }
              rename => { "[endport]" => "[kv_field][endport]" }
              rename => { "[datasource]" => "[kv_field][datasource]" }
              rename => { "[datasource_type]" => "[kv_field][datasource_type]" }
              rename => { "[seqno]" => "[kv_field][seqno]" }
              rename => { "[actionflags]" => "[kv_field][actionflags]" }
              rename => { "[dg_hier_level_1]" => "[kv_field][dg_hier_level_1]" }
              rename => { "[dg_hier_level_2]" => "[kv_field][dg_hier_level_2]" }
              rename => { "[dg_hier_level_3]" => "[kv_field][dg_hier_level_3]" }
              rename => { "[dg_hier_level_4]" => "[kv_field][dg_hier_level_4]" }
              rename => { "[vsys_name]" => "[kv_field][vsys_name]" }
              rename => { "[device_name]" => "[kv_field][device_name]" }
              rename => { "[vsys_id]" => "[kv_field][vsys_id]" }
              rename => { "[factortype]" => "[kv_field][factortype]" }
              rename => { "[factorcompletiontime]" => "[kv_field][factorcompletiontime]" }
              rename => { "[factorno]" => "[kv_field][factorno]" }
              rename => { "[ugflags]" => "[kv_field][ugflags]" }
              rename => { "[userbysource]" => "[kv_field][userbysource]" }
              rename => { "[high_res_timestamp]" => "[kv_field][high_res_timestamp]" }
            }
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#Detect if its a DECRYPTION log
          }else if ([message] =~/(.+),(\s)?(DECRYPTION)(\s)?,(.+),(\s)?(allow|deny|drop|drop ICMP|reset both|reset client|reset server)(\s)?,(.+)/){
              csv {
              source => "csv_msg_all"
              skip_header => "true"
              columns => ["receive_time", "serial", "pa_type", "pa_subtype", "config_ver", "time_generated", "src", "dst",
                          "natsrc", "natdst", "rule", "srcuser", "dstuser", "app", "vsys", "from", "to", "inbound_if",
                          "outbound_if", "logset", "time_received", "sessionid", "repeatcnt", "spt", "dpt", "natspt",
                          "natdpt", "flags", "proto", "act", "tunnel", "FUTURE_USE", "FUTURE_USE", "src_uuid", "dst_uuid",
                          "rule_uuid", "hs_stage_c2f", "hs_stage_f2s", "tls_version", "tls_keyxchg", "tls_enc", "tls_auth",
                          "policy_name", "ec_curve", "err_index", "root_status", "chain_status", "proxy_type", "cert_serial",
                          "fingerprint", "notbefore", "notafter", "cert_ver", "cert_size", "cn_len", "issuer_len", "rootcn_len",
                          "sni_len", "cert_flags", "cn", "issuer_cn", "root_cn", "sni", "error", "container_id", "pod_namespace",
                          "pod_name", "src_edl", "dst_edl", "src_dag", "dst_dag", "high_res_timestamp", "src_category",
                          "src_profile", "src_model", "src_vendor", "src_osfamily", "src_osversion", "src_host", "src_mac",
                          "dst_category", "dst_profile", "dst_model", "dst_vendor", "dst_osfamily", "dst_osversion",
                          "dst_host", "dst_mac", "seqno", "actionflags", "dg_hier_level_1", "dg_hier_level_2", "dg_hier_level_3",
                          "dg_hier_level_4", "vsys_name", "device_name", "vsys_id", "subcategory_of_app", "category_of_app",
                          "technology_of_app", "risk_of_app", "characteristic_of_app", "container_of_app", "is_saas_of_app",
                          "sanctioned_state_of_app"]
           }
#......................................................................#
# Rename fields of DECRYPTION log
            mutate {
              rename => { "[receive_time]" => "[kv_field][receive_time]" }
              rename => { "[serial]" => "[kv_field][serial]" }
              rename => { "[pa_type]" => "[kv_field][pa_type]" }
              rename => { "[pa_subtype]" => "[kv_field][pa_subtype]" }
              rename => { "[config_ver]" => "[kv_field][config_ver]" }
              rename => { "[time_generated]" => "[kv_field][time_generated]" }
              rename => { "[src]" => "[kv_field][src]" }
              rename => { "[dst]" => "[kv_field][dst]" }
              rename => { "[natsrc]" => "[kv_field][natsrc]" }
              rename => { "[natdst]" => "[kv_field][natdst]" }
              rename => { "[rule]" => "[kv_field][rule]" }
              rename => { "[srcuser]" => "[kv_field][srcuser]" }
              rename => { "[dstuser]" => "[kv_field][dstuser]" }
              rename => { "[app]" => "[kv_field][app]" }
              rename => { "[vsys]" => "[kv_field][vsys]" }
              rename => { "[from]" => "[kv_field][from]" }
              rename => { "[to]" => "[kv_field][to]" }
              rename => { "[inbound_if]" => "[kv_field][inbound_if]" }
              rename => { "[outbound_if]" => "[kv_field][outbound_if]" }
              rename => { "[logset]" => "[kv_field][logset]" }
              rename => { "[time_received]" => "[kv_field][time_received]" }
              rename => { "[sessionid]" => "[kv_field][sessionid]" }
              rename => { "[repeatcnt]" => "[kv_field][repeatcnt]" }
              rename => { "[spt]" => "[kv_field][spt]" }
              rename => { "[dpt]" => "[kv_field][dpt]" }
              rename => { "[natspt]" => "[kv_field][natspt]" }
              rename => { "[natdpt]" => "[kv_field][natdpt]" }
              rename => { "[flags]" => "[kv_field][flags]" }
              rename => { "[proto]" => "[kv_field][proto]" }
              rename => { "[act]" => "[kv_field][act]" }
              rename => { "[tunnel]" => "[kv_field][tunnel]" }
              rename => { "[src_uuid]" => "[kv_field][src_uuid]" }
              rename => { "[dst_uuid]" => "[kv_field][dst_uuid]" }
              rename => { "[rule_uuid]" => "[kv_field][rule_uuid]" }
              rename => { "[hs_stage_c2f]" => "[kv_field][hs_stage_c2f]" }
              rename => { "[hs_stage_f2s]" => "[kv_field][hs_stage_f2s]" }
              rename => { "[tls_version]" => "[kv_field][tls_version]" }
              rename => { "[tls_keyxchg]" => "[kv_field][tls_keyxchg]" }
              rename => { "[tls_enc]" => "[kv_field][tls_enc]" }
              rename => { "[tls_auth]" => "[kv_field][tls_auth]" }
              rename => { "[policy_name]" => "[kv_field][policy_name]" }
              rename => { "[ec_curve]" => "[kv_field][ec_curve]" }
              rename => { "[err_index]" => "[kv_field][err_index]" }
              rename => { "[root_status]" => "[kv_field][root_status]" }
              rename => { "[chain_status]" => "[kv_field][chain_status]" }
              rename => { "[proxy_type]" => "[kv_field][proxy_type]" }
              rename => { "[cert_serial]" => "[kv_field][cert_serial]" }
              rename => { "[fingerprint]" => "[kv_field][fingerprint]" }
              rename => { "[notbefore]" => "[kv_field][notbefore]" }
              rename => { "[notafter]" => "[kv_field][notafter]" }
              rename => { "[cert_ver]" => "[kv_field][cert_ver]" }
              rename => { "[cert_size]" => "[kv_field][cert_size]" }
              rename => { "[cn_len]" => "[kv_field][cn_len]" }
              rename => { "[issuer_len]" => "[kv_field][issuer_len]" }
              rename => { "[rootcn_len]" => "[kv_field][rootcn_len]" }
              rename => { "[sni_len]" => "[kv_field][sni_len]" }
              rename => { "[cert_flags]" => "[kv_field][cert_flags]" }
              rename => { "[cn]" => "[kv_field][cn]" }
              rename => { "[issuer_cn]" => "[kv_field][issuer_cn]" }
              rename => { "[root_cn]" => "[kv_field][root_cn]" }
              rename => { "[sni]" => "[kv_field][sni]" }
              rename => { "[error]" => "[kv_field][error]" }
              rename => { "[container_id]" => "[kv_field][container_id]" }
              rename => { "[pod_namespace]" => "[kv_field][pod_namespace]" }
              rename => { "[pod_name]" => "[kv_field][pod_name]" }
              rename => { "[src_edl]" => "[kv_field][src_edl]" }
              rename => { "[dst_edl]" => "[kv_field][dst_edl]" }
              rename => { "[src_dag]" => "[kv_field][src_dag]" }
              rename => { "[dst_dag]" => "[kv_field][dst_dag]" }
              rename => { "[high_res_timestamp]" => "[kv_field][high_res_timestamp]" }
              rename => { "[src_category]" => "[kv_field][src_category]" }
              rename => { "[src_profile]" => "[kv_field][src_profile]" }
              rename => { "[src_model]" => "[kv_field][src_model]" }
              rename => { "[src_vendor]" => "[kv_field][src_vendor]" }
              rename => { "[src_osfamily]" => "[kv_field][src_osfamily]" }
              rename => { "[src_osversion]" => "[kv_field][src_osversion]" }
              rename => { "[src_host]" => "[kv_field][src_host]" }
              rename => { "[src_mac]" => "[kv_field][src_mac]" }
              rename => { "[dst_category]" => "[kv_field][dst_category]" }
              rename => { "[dst_profile]" => "[kv_field][dst_profile]" }
              rename => { "[dst_model]" => "[kv_field][dst_model]" }
              rename => { "[dst_vendor]" => "[kv_field][dst_vendor]" }
              rename => { "[dst_osfamily]" => "[kv_field][dst_osfamily]" }
              rename => { "[dst_osversion]" => "[kv_field][dst_osversion]" }
              rename => { "[dst_host]" => "[kv_field][dst_host]" }
              rename => { "[dst_mac]" => "[kv_field][dst_mac]" }
              rename => { "[seqno]" => "[kv_field][seqno]" }
              rename => { "[actionflags]" => "[kv_field][actionflags]" }
              rename => { "[dg_hier_level_1]" => "[kv_field][dg_hier_level_1]" }
              rename => { "[dg_hier_level_2]" => "[kv_field][dg_hier_level_2]" }
              rename => { "[dg_hier_level_3]" => "[kv_field][dg_hier_level_3]" }
              rename => { "[dg_hier_level_4]" => "[kv_field][dg_hier_level_4]" }
              rename => { "[vsys_name]" => "[kv_field][vsys_name]" }
              rename => { "[device_name]" => "[kv_field][device_name]" }
              rename => { "[vsys_id]" => "[kv_field][vsys_id]" }
              rename => { "[subcategory_of_app]" => "[kv_field][subcategory_of_app]" }
              rename => { "[category_of_app]" => "[kv_field][category_of_app]" }
              rename => { "[technology_of_app]" => "[kv_field][technology_of_app]" }
              rename => { "[risk_of_app]" => "[kv_field][risk_of_app]" }
              rename => { "[characteristic_of_app]" => "[kv_field][characteristic_of_app]" }
              rename => { "[container_of_app]" => "[kv_field][container_of_app]" }
              rename => { "[is_saas_of_app]" => "[kv_field][is_saas_of_app]" }
              rename => { "[sanctioned_state_of_app]" => "[kv_field][sanctioned_state_of_app]" }
            }
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#Detect if its a TUNNEL INSPECTION log
          }else if ([message] =~/(.+),(\s)?(START|END)(\s)?,(\s)?(start|end|drop|deny)(\s)?,(.+)/){
            csv {
              source => "csv_msg_all"
              skip_header => "true"
              columns => ["receive_time", "serial", "pa_type", "pa_subtype", "FUTURE_USE", "time_generated", "src", "dst",
                          "natsrc", "natdst", "rule", "srcuser", "dstuser", "app", "vsys", "from", "to", "inbound_if",
                          "outbound_if", "logset", "FUTURE_USE", "sessionid", "repeatcnt", "spt", "dpt", "natspt",
                          "natdpt", "flags", "proto", "act", "severity", "seqno", "actionflags", "srcloc", "dstloc",
                          "dg_hier_level_1", "dg_hier_level_2", "dg_hier_level_3", "dg_hier_level_4","vsys_name", "device_name", "tunnelid",
                          "monitortag", "parent_session_id", "parent_start_time", "tunnel", "bytes", "bytes_sent", "bytes_received",
                          "packets", "pkts_sent", "pkts_received", "max_encap", "unknown_proto", "strict_check", "tunnel_fragment",
                          "sessions_created", "sessions_closed", "session_end_reason", "action_source", "start", "elapsed",
                          "tunnel_insp_rule", "remote_user_ip", "remote_user_id", "rule_uuid", "pcap_id", "dynusergroup_name", "src_edl",
                          "dst_edl", "high_res_timestamp", "nssai_sd", "nssai_sd", "pdu_session_id", "subcategory_of_app", "category_of_app",
                          "technology_of_app", "risk_of_app", "characteristic_of_app", "container_of_app", "is_saas_of_app", "sanctioned_state_of_app"]
           }
#......................................................................#
# Rename fields of TUNNEL INSPECTION log
            mutate {
              rename => { "[receive_time]" => "[kv_field][receive_time]" }
              rename => { "[serial]" => "[kv_field][serial]" }
              rename => { "[pa_type]" => "[kv_field][pa_type]" }
              rename => { "[pa_subtype]" => "[kv_field][pa_subtype]" }
              rename => { "[time_generated]" => "[kv_field][time_generated]" }
              rename => { "[src]" => "[kv_field][src]" }
              rename => { "[dst]" => "[kv_field][dst]" }
              rename => { "[natsrc]" => "[kv_field][natsrc]" }
              rename => { "[natdst]" => "[kv_field][natdst]" }
              rename => { "[rule]" => "[kv_field][rule]" }
              rename => { "[srcuser]" => "[kv_field][srcuser]" }
              rename => { "[dstuser]" => "[kv_field][dstuser]" }
              rename => { "[app]" => "[kv_field][app]" }
              rename => { "[vsys]" => "[kv_field][vsys]" }
              rename => { "[from]" => "[kv_field][from]" }
              rename => { "[to]" => "[kv_field][to]" }
              rename => { "[inbound_if]" => "[kv_field][inbound_if]" }
              rename => { "[outbound_if]" => "[kv_field][outbound_if]" }
              rename => { "[logset]" => "[kv_field][logset]" }
              rename => { "[sessionid]" => "[kv_field][sessionid]" }
              rename => { "[repeatcnt]" => "[kv_field][repeatcnt]" }
              rename => { "[spt]" => "[kv_field][spt]" }
              rename => { "[dpt]" => "[kv_field][dpt]" }
              rename => { "[natspt]" => "[kv_field][natspt]" }
              rename => { "[natdpt]" => "[kv_field][natdpt]" }
              rename => { "[flags]" => "[kv_field][flags]" }
              rename => { "[proto]" => "[kv_field][proto]" }
              rename => { "[act]" => "[kv_field][act]" }
              rename => { "[severity]" => "[kv_field][severity]" }
              rename => { "[seqno]" => "[kv_field][seqno]" }
              rename => { "[actionflags]" => "[kv_field][actionflags]" }
              rename => { "[srcloc]" => "[kv_field][srcloc]" }
              rename => { "[dstloc]" => "[kv_field][dstloc]" }
              rename => { "[dg_hier_level_1]" => "[kv_field][dg_hier_level_1]" }
              rename => { "[dg_hier_level_2]" => "[kv_field][dg_hier_level_2]" }
              rename => { "[dg_hier_level_3]" => "[kv_field][dg_hier_level_3]" }
              rename => { "[dg_hier_level_4]" => "[kv_field][dg_hier_level_4]" }
              rename => { "[vsys_name]" => "[kv_field][vsys_name]" }
              rename => { "[device_name]" => "[kv_field][device_name]" }
              rename => { "[tunnelid]" => "[kv_field][tunnelid]" }
              rename => { "[monitortag]" => "[kv_field][monitortag]" }
              rename => { "[parent_session_id]" => "[kv_field][parent_session_id]" }
              rename => { "[parent_start_time]" => "[kv_field][parent_start_time]" }
              rename => { "[tunnel]" => "[kv_field][tunnel]" }
              rename => { "[bytes]" => "[kv_field][bytes]" }
              rename => { "[bytes_sent]" => "[kv_field][bytes_sent]" }
              rename => { "[bytes_received]" => "[kv_field][bytes_received]" }
              rename => { "[packets]" => "[kv_field][packets]" }
              rename => { "[pkts_sent]" => "[kv_field][pkts_sent]" }
              rename => { "[pkts_received]" => "[kv_field][pkts_received]" }
              rename => { "[max_encap]" => "[kv_field][max_encap]" }
              rename => { "[unknown_proto]" => "[kv_field][unknown_proto]" }
              rename => { "[strict_check]" => "[kv_field][strict_check]" }
              rename => { "[tunnel_fragment]" => "[kv_field][tunnel_fragment]" }
              rename => { "[sessions_created]" => "[kv_field][sessions_created]" }
              rename => { "[sessions_closed]" => "[kv_field][sessions_closed]" }
              rename => { "[session_end_reason]" => "[kv_field][session_end_reason]" }
              rename => { "[action_source]" => "[kv_field][action_source]" }
              rename => { "[start]" => "[kv_field][start]" }
              rename => { "[elapsed]" => "[kv_field][elapsed]" }
              rename => { "[tunnel_insp_rule]" => "[kv_field][tunnel_insp_rule]" }
              rename => { "[remote_user_ip]" => "[kv_field][remote_user_ip]" }
              rename => { "[remote_user_id]" => "[kv_field][remote_user_id]" }
              rename => { "[rule_uuid]" => "[kv_field][rule_uuid]" }
              rename => { "[pcap_id]" => "[kv_field][pcap_id]" }
              rename => { "[dynusergroup_name]" => "[kv_field][dynusergroup_name]" }
              rename => { "[src_edl]" => "[kv_field][src_edl]" }
              rename => { "[dst_edl]" => "[kv_field][dst_edl]" }
              rename => { "[high_res_timestamp]" => "[kv_field][high_res_timestamp]" }
              rename => { "[nssai_sd]" => "[kv_field][nssai_sd]" }
              rename => { "[nssai_sd]" => "[kv_field][nssai_sd]" }
              rename => { "[pdu_session_id]" => "[kv_field][pdu_session_id]" }
              rename => { "[subcategory_of_app]" => "[kv_field][subcategory_of_app]" }
              rename => { "[category_of_app]" => "[kv_field][category_of_app]" }
              rename => { "[technology_of_app]" => "[kv_field][technology_of_app]" }
              rename => { "[risk_of_app]" => "[kv_field][risk_of_app]" }
              rename => { "[characteristic_of_app]" => "[kv_field][characteristic_of_app]" }
              rename => { "[container_of_app]" => "[kv_field][container_of_app]" }
              rename => { "[is_saas_of_app]" => "[kv_field][is_saas_of_app]" }
              rename => { "[sanctioned_state_of_app]" => "[kv_field][sanctioned_state_of_app]" }
            }
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#Detect if its a SCTP log
          }else if([message] =~/(.+),(\s)?(SCTP)(\s)?,(.+),(\s)?(allow|deny)(\s)?,(.+)/){
            csv {
              source => "csv_msg_all"
              skip_header => "true"
              columns => ["receive_time", "serial", "pa_type", "FUTURE_USE", "FUTURE_USE", "time_generated", "src",
                          "dst", "FUTURE_USE", "FUTURE_USE", "rule", "FUTURE_USE", "FUTURE_USE", "FUTURE_USE", "vsys", "from", "to", "inbound_if",
                          "outbound_if", "logset", "FUTURE_USE", "sessionid", "repeatcnt", "spt", "dpt", "FUTURE_USE", "FUTURE_USE",
                          "FUTURE_USE", "FUTURE_USE", "proto", "act", "dg_hier_level_1", "dg_hier_level_2", "dg_hier_level_3", "dg_hier_level_4",
                          "vsys_name", "device_name", "seqno", "FUTURE_USE", "assoc_id", "ppid", "severity", "sctp_chunk_type", "FUTURE_USE", "verif_tag_1",
                          "verif_tag_2", "sctp_cause_code", "diam_app_id", "diam_cmd_code", "diam_avp_code", "stream_id", "assoc_end_reason", "op_code",
                          "sccp_calling_ssn", "sccp_calling_gt", "sctp_filter", "chunks", "chunks_sent", "chunks_received", "packets", "pkts_sent", "pkts_received", "rule_uuid", "high_res_timestamp"]
           }
#......................................................................#
# Rename fields of SCTP log
            mutate {
              rename => { "[receive_time]" => "[kv_field][receive_time]" }
              rename => { "[serial]" => "[kv_field][serial]" }
              rename => { "[pa_type]" => "[kv_field][pa_type]" }
              rename => { "[time_generated]" => "[kv_field][time_generated]" }
              rename => { "[src]" => "[kv_field][src]" }
              rename => { "[dst]" => "[kv_field][dst]" }
              rename => { "[rule]" => "[kv_field][rule]" }
              rename => { "[vsys]" => "[kv_field][vsys]" }
              rename => { "[from]" => "[kv_field][from]" }
              rename => { "[to]" => "[kv_field][to]" }
              rename => { "[inbound_if]" => "[kv_field][inbound_if]" }
              rename => { "[outbound_if]" => "[kv_field][outbound_if]" }
              rename => { "[logset]" => "[kv_field][logset]" }
              rename => { "[sessionid]" => "[kv_field][sessionid]" }
              rename => { "[repeatcnt]" => "[kv_field][repeatcnt]" }
              rename => { "[spt]" => "[kv_field][spt]" }
              rename => { "[dpt]" => "[kv_field][dpt]" }
              rename => { "[proto]" => "[kv_field][proto]" }
              rename => { "[act]" => "[kv_field][act]" }
              rename => { "[dg_hier_level_1]" => "[kv_field][dg_hier_level_1]" }
              rename => { "[dg_hier_level_2]" => "[kv_field][dg_hier_level_2]" }
              rename => { "[dg_hier_level_3]" => "[kv_field][dg_hier_level_3]" }
              rename => { "[dg_hier_level_4]" => "[kv_field][dg_hier_level_4]" }
              rename => { "[vsys_name]" => "[kv_field][vsys_name]" }
              rename => { "[device_name]" => "[kv_field][device_name]" }
              rename => { "[seqno]" => "[kv_field][seqno]" }
              rename => { "[assoc_id]" => "[kv_field][assoc_id]" }
              rename => { "[ppid]" => "[kv_field][ppid]" }
              rename => { "[severity]" => "[kv_field][severity]" }
              rename => { "[sctp_chunk_type]" => "[kv_field][sctp_chunk_type]" }
              rename => { "[verif_tag_1]" => "[kv_field][verif_tag_1]" }
              rename => { "[verif_tag_2]" => "[kv_field][verif_tag_2]" }
              rename => { "[sctp_cause_code]" => "[kv_field][sctp_cause_code]" }
              rename => { "[diam_app_id]" => "[kv_field][diam_app_id]" }
              rename => { "[diam_cmd_code]" => "[kv_field][diam_cmd_code]" }
              rename => { "[diam_avp_code]" => "[kv_field][diam_avp_code]" }
              rename => { "[stream_id]" => "[kv_field][stream_id]" }
              rename => { "[assoc_end_reason]" => "[kv_field][assoc_end_reason]" }
              rename => { "[op_code]" => "[kv_field][op_code]" }
              rename => { "[sccp_calling_ssn]" => "[kv_field][sccp_calling_ssn]" }
              rename => { "[sccp_calling_gt]" => "[kv_field][sccp_calling_gt]" }
              rename => { "[sctp_filter]" => "[kv_field][sctp_filter]" }
              rename => { "[chunks]" => "[kv_field][chunks]" }
              rename => { "[chunks_sent]" => "[kv_field][chunks_sent]" }
              rename => { "[chunks_received]" => "[kv_field][chunks_received]" }
              rename => { "[packets]" => "[kv_field][packets]" }
              rename => { "[pkts_sent]" => "[kv_field][pkts_sent]" }
              rename => { "[pkts_received]" => "[kv_field][pkts_received]" }
              rename => { "[rule_uuid]" => "[kv_field][rule_uuid]" }
              rename => { "[high_res_timestamp]" => "[kv_field][high_res_timestamp]" }
            }
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#Detect if its a CONFIG log
          }else if([message] =~/(.+),(\s)?(CONFIG)(\s)?,(.+),(\s)?(add|clone|commit|delete|edit|move|rename|set)(\s)?,(.+)/){
            csv {
              source => "csv_msg_all"
              skip_header => "true"
              columns => ["receive_time", "serial", "pa_type", "pa_subtype", "FUTURE_USE", "time_generated", "host", "vsys",
                          "cmd", "admin", "client", "result", "path", "before_change_detail", "after_change_detail",
                          "seqno", "actionflags", "dg_hier_level_1", "dg_hier_level_2", "dg_hier_level_3", "dg_hier_level_4",
                          "vsys_name", "device_name", "dg_id", "comment", "FUTURE_USE", "high_res_timestamp"]
           }
#......................................................................#
# Rename fields of CONFIG log
          mutate {
            rename => { "[receive_time]" => "[kv_field][receive_time]" }
            rename => { "[serial]" => "[kv_field][serial]" }
            rename => { "[pa_type]" => "[kv_field][pa_type]" }
            rename => { "[pa_subtype]" => "[kv_field][pa_subtype]" }
            rename => { "[time_generated]" => "[kv_field][time_generated]" }
            rename => { "[host]" => "[kv_field][host]" }
            rename => { "[vsys]" => "[kv_field][vsys]" }
            rename => { "[cmd]" => "[kv_field][cmd]" }
            rename => { "[admin]" => "[kv_field][admin]" }
            rename => { "[client]" => "[kv_field][client]" }
            rename => { "[result]" => "[kv_field][result]" }
            rename => { "[path]" => "[kv_field][path]" }
            rename => { "[before_change_detail]" => "[kv_field][before_change_detail]" }
            rename => { "[after_change_detail]" => "[kv_field][after_change_detail]" }
            rename => { "[seqno]" => "[kv_field][seqno]" }
            rename => { "[actionflags]" => "[kv_field][actionflags]" }
            rename => { "[dg_hier_level_1]" => "[kv_field][dg_hier_level_1]" }
            rename => { "[dg_hier_level_2]" => "[kv_field][dg_hier_level_2]" }
            rename => { "[dg_hier_level_3]" => "[kv_field][dg_hier_level_3]" }
            rename => { "[dg_hier_level_4]" => "[kv_field][dg_hier_level_4]" }
            rename => { "[vsys_name]" => "[kv_field][vsys_name]" }
            rename => { "[device_name]" => "[kv_field][device_name]" }
            rename => { "[dg_id]" => "[kv_field][dg_id]" }
            rename => { "[comment]" => "[kv_field][comment]" }
            rename => { "[high_res_timestamp]" => "[kv_field][high_res_timestamp]" }
          }
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#Detect if its a AUTHENTICATION log
          }else if([message] =~/(.+),(\s)?(AUTHENTICATION)(\s)?,(\s)?(crypto|dhcp|dnsproxy|dos|general|global-protect|ha|hw|nat|ntpd|pbf|port|pppoe|ras|routing|satd|sslmgr|sslvpn|userid|url-filtering|vpn)(\s)?,(.+)/){
            csv {
              source => "csv_msg_all"
              skip_header => "true"
              columns => ["receive_time", "serial", "pa_type", "pa_subtype", "FUTURE_USE", "time_generated", "vsys", "src", "user",
                         "normalize_user", "object", "authpolicy", "repeatcnt", "authid", "vendor", "logset", "serverprofile",
                         "desc", "clienttype", "event", "factorno", "seqno", "actionflags", "dg_hier_level_1", "dg_hier_level_2",
                         "dg_hier_level_3", "dg_hier_level_4", "vsys_name", "device_name", "vsys_id", "authproto", "rule_uuid",
                         "high_res _timestamp", "src_category", "src_profile", "src_model","src_vendor", "src_osfamily", "src_osversion",
                         "src_host", "src_mac", "region", "FUTURE_USE", "user_agent", "sessionid"]
           }
#......................................................................#
# Rename fields of AUTHENTICATION log
            mutate {
              rename => { "[receive_time]" => "[kv_field][receive_time]" }
              rename => { "[serial]" => "[kv_field][serial]" }
              rename => { "[pa_type]" => "[kv_field][pa_type]" }
              rename => { "[pa_subtype]" => "[kv_field][pa_subtype]" }
              rename => { "[time_generated]" => "[kv_field][time_generated]" }
              rename => { "[vsys]" => "[kv_field][vsys]" }
              rename => { "[src]" => "[kv_field][src]" }
              rename => { "[user]" => "[kv_field][user]" }
              rename => { "[normalize_user]" => "[kv_field][normalize_user]" }
              rename => { "[object]" => "[kv_field][object]" }
              rename => { "[authpolicy]" => "[kv_field][authpolicy]" }
              rename => { "[repeatcnt]" => "[kv_field][repeatcnt]" }
              rename => { "[authid]" => "[kv_field][authid]" }
              rename => { "[vendor]" => "[kv_field][vendor]" }
              rename => { "[logset]" => "[kv_field][logset]" }
              rename => { "[serverprofile]" => "[kv_field][serverprofile]" }
              rename => { "[desc]" => "[kv_field][desc]" }
              rename => { "[clienttype]" => "[kv_field][clienttype]" }
              rename => { "[event]" => "[kv_field][event]" }
              rename => { "[factorno]" => "[kv_field][factorno]" }
              rename => { "[seqno]" => "[kv_field][seqno]" }
              rename => { "[actionflags]" => "[kv_field][actionflags]" }
              rename => { "[dg_hier_level_1]" => "[kv_field][dg_hier_level_1]" }
              rename => { "[dg_hier_level_2]" => "[kv_field][dg_hier_level_2]" }
              rename => { "[dg_hier_level_3]" => "[kv_field][dg_hier_level_3]" }
              rename => { "[dg_hier_level_4]" => "[kv_field][dg_hier_level_4]" }
              rename => { "[vsys_name]" => "[kv_field][vsys_name]" }
              rename => { "[device_name]" => "[kv_field][device_name]" }
              rename => { "[vsys_id]" => "[kv_field][vsys_id]" }
              rename => { "[authproto]" => "[kv_field][authproto]" }
              rename => { "[rule_uuid]" => "[kv_field][rule_uuid]" }
              rename => { "[high_res_timestamp]" => "[kv_field][high_res_timestamp]" }
              rename => { "[src_category]" => "[kv_field][src_category]" }
              rename => { "[src_profile]" => "[kv_field][src_profile]" }
              rename => { "[src_model]" => "[kv_field][src_model]" }
              rename => { "[src_vendor]" => "[kv_field][src_vendor]" }
              rename => { "[src_osfamily]" => "[kv_field][src_osfamily]" }
              rename => { "[src_osversion]" => "[kv_field][src_osversion]" }
              rename => { "[src_host]" => "[kv_field][src_host]" }
              rename => { "[src_mac]" => "[kv_field][src_mac]" }
              rename => { "[region]" => "[kv_field][region]" }
              rename => { "[user_agent]" => "[kv_field][user_agent]" }
              rename => { "[sessionid]" => "[kv_field][sessionid]" }
            }
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#Detect if its a SYSTEM log
          }else if([message] =~/(.+),(\s)?(SYSTEM)(\s)?,(\s)?(crypto|dhcp|dnsproxy|dos|general|global-protect|ha|hw|nat|ntpd|pbf|port|pppoe|ras|routing|satd|sslmgr|sslvpn|userid|url-filtering|vpn)(\s)?,(.+)/){
            csv {
              source => "csv_msg_all"
              skip_header => "true"
              columns => ["receive_time", "serial", "pa_type", "pa_subtype", "FUTURE_USE", "time_generated", "vsys", "eventid",
                          "object", "FUTURE_USE", "FUTURE_USE", "module", "severity", "opaque", "seqno", "actionflags",
                          "dg_hier_level_1", "dg_hier_level_2", "dg_hier_level_3", "dg_hier_level_4", "vsys_name",
                          "device_name", "FUTURE_USE", "FUTURE_USE", "high_res_timestamp"]
           }
#......................................................................#
# Rename fields of SYSTEM log
            mutate {
              rename => { "[receive_time]" => "[kv_field][receive_time]" }
              rename => { "[serial]" => "[kv_field][serial]" }
              rename => { "[pa_type]" => "[kv_field][pa_type]" }
              rename => { "[pa_subtype]" => "[kv_field][pa_subtype]" }
              rename => { "[time_generated]" => "[kv_field][time_generated]" }
              rename => { "[vsys]" => "[kv_field][vsys]" }
              rename => { "[eventid]" => "[kv_field][eventid]" }
              rename => { "[object]" => "[kv_field][object]" }
              rename => { "[module]" => "[kv_field][module]" }
              rename => { "[severity]" => "[kv_field][severity]" }
              rename => { "[opaque]" => "[kv_field][opaque]" }
              rename => { "[seqno]" => "[kv_field][seqno]" }
              rename => { "[actionflags]" => "[kv_field][actionflags]" }
              rename => { "[dg_hier_level_1]" => "[kv_field][dg_hier_level_1]" }
              rename => { "[dg_hier_level_2]" => "[kv_field][dg_hier_level_2]" }
              rename => { "[dg_hier_level_3]" => "[kv_field][dg_hier_level_3]" }
              rename => { "[dg_hier_level_4]" => "[kv_field][dg_hier_level_4]" }
              rename => { "[vsys_name]" => "[kv_field][vsys_name]" }
              rename => { "[device_name]" => "[kv_field][device_name]" }
              rename => { "[high_res_timestamp]" => "[kv_field][high_res_timestamp]" }
            }
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#Detect if its a CORRELATED EVENTS log
          }else if ([message] =~/(.+),(\s)?(CORRELATION)(\s)?,(\s)?(crypto|dhcp|dnsproxy|dos|general|global-protect|ha|hw|nat|ntpd|pbf|port|pppoe|ras|routing|satd|sslmgr|sslvpn|userid|url-filtering|vpn)(\s)?,(.+)/){
            csv {
              source => "csv_msg_all"
              skip_header => "true"
              columns => ["receive_time", "serial", "pa_type", "pa_subtype", "FUTURE_USE", "time_generated", "src",
                          "srcuser", "vsys", "category", "severity", "dg_hier_level_1", "dg_hier_level_2", "dg_hier_level_3",
                          "dg_hier_level_4", "vsys_name", "device_name", "vsys_id", "objectname", "object_id", "evidence"]
           }
#......................................................................#
# Rename fields of CORRELATED EVENTS log
            mutate {
              rename => { "[receive_time]" => "[kv_field][receive_time]" }
              rename => { "[serial]" => "[kv_field][serial]" }
              rename => { "[pa_type]" => "[kv_field][pa_type]" }
              rename => { "[pa_subtype]" => "[kv_field][pa_subtype]" }
              rename => { "[time_generated]" => "[kv_field][time_generated]" }
              rename => { "[src]" => "[kv_field][src]" }
              rename => { "[srcuser]" => "[kv_field][srcuser]" }
              rename => { "[vsys]" => "[kv_field][vsys]" }
              rename => { "[category]" => "[kv_field][category]" }
              rename => { "[severity]" => "[kv_field][severity]" }
              rename => { "[dg_hier_level_1]" => "[kv_field][dg_hier_level_1]" }
              rename => { "[dg_hier_level_2]" => "[kv_field][dg_hier_level_2]" }
              rename => { "[dg_hier_level_3]" => "[kv_field][dg_hier_level_3]" }
              rename => { "[dg_hier_level_4]" => "[kv_field][dg_hier_level_4]" }
              rename => { "[vsys_name]" => "[kv_field][vsys_name]" }
              rename => { "[device_name]" => "[kv_field][device_name]" }
              rename => { "[vsys_id]" => "[kv_field][vsys_id]" }
              rename => { "[objectname]" => "[kv_field][objectname]" }
              rename => { "[object_id]" => "[kv_field][object_id]" }
              rename => { "[evidence]" => "[kv_field][evidence]" }
            }
#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#Detect if its a GTP log
          }else if ([message] =~/(.+),(\s)?(GTP)(\s)?,(\s)?(start|end|drop|deny)(\s)?,(.+)/){
            csv {
              source => "csv_msg_all"
              skip_header => "true"
              columns => ["receive_time", "serial", "pa_type", "pa_subtype", "FUTURE_USE", "time_generated", "src",
                          "dst", "FUTURE_USE", "FUTURE_USE", "rule", "FUTURE_USE", "FUTURE_USE", "app", "vsys", "from", "to", "inbound_if",
                          "outbound_if", "logset", "FUTURE_USE", "sessionid", "FUTURE_USE", "spt", "dpt", "FUTURE_USE", "FUTURE_USE",
                          "FUTURE_USE", "proto", "act", "event_type", "msisdn", "apn", "rat", "msg_type", "end_ip_adr", "teid1",
                          "teid2", "gtp_interface", "cause_code", "severity", "mcc", "mnc", "area_code", "cell_id", "event_code",
                          "FUTURE_USE", "FUTURE_USE", "srcloc", "dstloc", "FUTURE_USE", "FUTURE_USE", "FUTURE_USE", "FUTURE_USE",
                          "FUTURE_USE", "FUTURE_USE", "FUTURE_USE", "imsi", "imei", "FUTURE_USE", "FUTURE_USE", "FUTURE_USE",
                          "FUTURE_USE", "FUTURE_USE", "FUTURE_USE", "FUTURE_USE", "FUTURE_USE", "FUTURE_USE", "FUTURE_USE", "FUTURE_USE",
                          "FUTURE_USE", "FUTURE_USE", "FUTURE_USE", "FUTURE_USE", "FUTURE_USE", "start", "elapsed", "tunnel_insp_rule",
                          "remote_user_ip", "remote_user_id", "rule_uuid", "pcap_id", "high_res_timestamp", "nsdsai_sst", "nsdsai_sd",
                          "subcategory_of_app", "category_of_app", "technology_of_app", "risk_of_app", "characteristic_of_app",
                          "container_of_app", "is_saas_of_app", "sanctioned_state_of_app"]
           }
           #......................................................................#
# Rename fields of GTP log
           mutate {
            rename => { "[receive_time]" => "[kv_field][receive_time]" }
            rename => { "[serial]" => "[kv_field][serial]" }
            rename => { "[pa_type]" => "[kv_field][pa_type]" }
            rename => { "[pa_subtype]" => "[kv_field][pa_subtype]" }
            rename => { "[time_generated]" => "[kv_field][time_generated]" }
            rename => { "[src]" => "[kv_field][src]" }
            rename => { "[dst]" => "[kv_field][dst]" }
            rename => { "[rule]" => "[kv_field][rule]" }
            rename => { "[app]" => "[kv_field][app]" }
            rename => { "[vsys]" => "[kv_field][vsys]" }
            rename => { "[from]" => "[kv_field][from]" }
            rename => { "[to]" => "[kv_field][to]" }
            rename => { "[inbound_if]" => "[kv_field][inbound_if]" }
            rename => { "[outbound_if]" => "[kv_field][outbound_if]" }
            rename => { "[logset]" => "[kv_field][logset]" }
            rename => { "[sessionid]" => "[kv_field][sessionid]" }
            rename => { "[spt]" => "[kv_field][spt]" }
            rename => { "[dpt]" => "[kv_field][dpt]" }
            rename => { "[proto]" => "[kv_field][proto]" }
            rename => { "[act]" => "[kv_field][act]" }
            rename => { "[event_type]" => "[kv_field][event_type]" }
            rename => { "[msisdn]" => "[kv_field][msisdn]" }
            rename => { "[apn]" => "[kv_field][apn]" }
            rename => { "[rat]" => "[kv_field][rat]" }
            rename => { "[msg_type]" => "[kv_field][msg_type]" }
            rename => { "[end_ip_adr]" => "[kv_field][end_ip_adr]" }
            rename => { "[teid1]" => "[kv_field][teid1]" }
            rename => { "[teid2]" => "[kv_field][teid2]" }
            rename => { "[gtp_interface]" => "[kv_field][gtp_interface]" }
            rename => { "[cause_code]" => "[kv_field][cause_code]" }
            rename => { "[severity]" => "[kv_field][severity]" }
            rename => { "[mcc]" => "[kv_field][mcc]" }
            rename => { "[mnc]" => "[kv_field][mnc]" }
            rename => { "[area_code]" => "[kv_field][area_code]" }
            rename => { "[cell_id]" => "[kv_field][cell_id]" }
            rename => { "[event_code]" => "[kv_field][event_code]" }
            rename => { "[srcloc]" => "[kv_field][srcloc]" }
            rename => { "[dstloc]" => "[kv_field][dstloc]" }
            rename => { "[imsi]" => "[kv_field][imsi]" }
            rename => { "[imei]" => "[kv_field][imei]" }
            rename => { "[start]" => "[kv_field][start]" }
            rename => { "[elapsed]" => "[kv_field][elapsed]" }
            rename => { "[tunnel_insp_rule]" => "[kv_field][tunnel_insp_rule]" }
            rename => { "[remote_user_ip]" => "[kv_field][remote_user_ip]" }
            rename => { "[remote_user_id]" => "[kv_field][remote_user_id]" }
            rename => { "[rule_uuid]" => "[kv_field][rule_uuid]" }
            rename => { "[pcap_id]" => "[kv_field][pcap_id]" }
            rename => { "[high_res_timestamp]" => "[kv_field][high_res_timestamp]" }
            rename => { "[nsdsai_sst]" => "[kv_field][nsdsai_sst]" }
            rename => { "[nsdsai_sd]" => "[kv_field][nsdsai_sd]" }
            rename => { "[subcategory_of_app]" => "[kv_field][subcategory_of_app]" }
            rename => { "[category_of_app]" => "[kv_field][category_of_app]" }
            rename => { "[technology_of_app]" => "[kv_field][technology_of_app]" }
            rename => { "[risk_of_app]" => "[kv_field][risk_of_app]" }
            rename => { "[characteristic_of_app]" => "[kv_field][characteristic_of_app]" }
            rename => { "[container_of_app]" => "[kv_field][container_of_app]" }
            rename => { "[is_saas_of_app]" => "[kv_field][is_saas_of_app]" }
            rename => { "[sanctioned_state_of_app]" => "[kv_field][sanctioned_state_of_app]" }
           }
          }
        }
      }

#......................................................................#
#Then, replace whitespaces with default string after = to avoid issues
              if ([cef_or_leef_msg]){
                 mutate { gsub => [ "cef_or_leef_msg", "(\w+)= ", "\1=X0X " ] }

#......................................................................#
#Using grok to parse individual fields
                 grok { match => { "cef_or_leef_msg" => ["act=%{DATA:act} %{WORD}=","act=%{GREEDYDATA:act}"] } }
                 grok { match => { "cef_or_leef_msg" => ["anOSTimeGeneratedHighResolution=%{DATA:anOSTimeGeneratedHighResolution} %{WORD}=","anOSTimeGeneratedHighResolution=%{GREEDYDATA:anOSTimeGeneratedHighResolution}"] } }
                 grok { match => { "cef_or_leef_msg" => ["app=%{DATA:app} %{WORD}=","app=%{GREEDYDATA:app}"] } }
                 grok { match => { "cef_or_leef_msg" => ["c6a2=%{DATA:c6a2} %{WORD}=","c6a2=%{GREEDYDATA:c6a2}"] } }
                 grok { match => { "cef_or_leef_msg" => ["c6a2Label=%{DATA:c6a2Label} %{WORD}=","c6a2Label=%{GREEDYDATA:c6a2Label}"] } }
                 grok { match => { "cef_or_leef_msg" => ["cat=%{DATA:cat} %{WORD}=","cat=%{GREEDYDATA:cat}"] } }
                 grok { match => { "cef_or_leef_msg" => ["cfp1=%{DATA:cfp1} %{WORD}=","cfp1=%{GREEDYDATA:cfp1}"] } }
                 grok { match => { "cef_or_leef_msg" => ["cfp1Label=%{DATA:cfp1Label} %{WORD}=","cfp1Label=%{GREEDYDATA:cfp1Label}"] } }
                 grok { match => { "cef_or_leef_msg" => ["cfp2=%{DATA:cfp2} %{WORD}=","cfp2=%{GREEDYDATA:cfp2}"] } }
                 grok { match => { "cef_or_leef_msg" => ["cfp2Label=%{DATA:cfp2Label} %{WORD}=","cfp2Label=%{GREEDYDATA:cfp2Label}"] } }
                 grok { match => { "cef_or_leef_msg" => ["cfp3=%{DATA:cfp3} %{WORD}=","cfp3=%{GREEDYDATA:cfp3}"] } }
                 grok { match => { "cef_or_leef_msg" => ["cfp3Label=%{DATA:cfp3Label} %{WORD}=","cfp3Label=%{GREEDYDATA:cfp3Label}"] } }
                 grok { match => { "cef_or_leef_msg" => ["cfp4=%{DATA:cfp4} %{WORD}=","cfp4=%{GREEDYDATA:cfp4}"] } }
                 grok { match => { "cef_or_leef_msg" => ["cfp4Label=%{DATA:cfp4Label} %{WORD}=","cfp4Label=%{GREEDYDATA:cfp4Label}"] } }
                 grok { match => { "cef_or_leef_msg" => ["cn1=%{DATA:cn1} %{WORD}=","cn1=%{GREEDYDATA:cn1}"] } }
                 grok { match => { "cef_or_leef_msg" => ["cn1Label=%{DATA:cn1Label} %{WORD}=","cn1Label=%{GREEDYDATA:cn1Label}"] } }
                 grok { match => { "cef_or_leef_msg" => ["cn2=%{DATA:cn2} %{WORD}=","cn2=%{GREEDYDATA:cn2}"] } }
                 grok { match => { "cef_or_leef_msg" => ["cn2Label=%{DATA:cn2Label} %{WORD}=","cn2Label=%{GREEDYDATA:cn2Label}"] } }
                 grok { match => { "cef_or_leef_msg" => ["cn3=%{DATA:cn3} %{WORD}=","cn3=%{GREEDYDATA:cn3}"] } }
                 grok { match => { "cef_or_leef_msg" => ["cn3Label=%{DATA:cn3Label} %{WORD}=","cn3Label=%{GREEDYDATA:cn3Label}"] } }
                 grok { match => { "cef_or_leef_msg" => ["cn4=%{DATA:cn4} %{WORD}=","cn4=%{GREEDYDATA:cn4}"] } }
                 grok { match => { "cef_or_leef_msg" => ["cn4Label=%{DATA:cn4Label} %{WORD}=","cn4Label=%{GREEDYDATA:cn4Label}"] } }
                 grok { match => { "cef_or_leef_msg" => ["cn5=%{DATA:cn5} %{WORD}=","cn5=%{GREEDYDATA:cn5}"] } }
                 grok { match => { "cef_or_leef_msg" => ["cn5Label=%{DATA:cn5Label} %{WORD}=","cn5Label=%{GREEDYDATA:cn5Label}"] } }
                 grok { match => { "cef_or_leef_msg" => ["cn6=%{DATA:cn6} %{WORD}=","cn6=%{GREEDYDATA:cn6}"] } }
                 grok { match => { "cef_or_leef_msg" => ["cn6Label=%{DATA:cn6Label} %{WORD}=","cn6Label=%{GREEDYDATA:cn6Label}"] } }
                 grok { match => { "cef_or_leef_msg" => ["cnt=%{DATA:cnt} %{WORD}=","cnt=%{GREEDYDATA:cnt}"] } }
                 grok { match => { "cef_or_leef_msg" => ["cs1=%{DATA:cs1} %{WORD}=","cs1=%{GREEDYDATA:cs1}"] } }
                 grok { match => { "cef_or_leef_msg" => ["cs1Label=%{DATA:cs1Label} %{WORD}=","cs1Label=%{GREEDYDATA:cs1Label}"] } }
                 grok { match => { "cef_or_leef_msg" => ["cs2=%{DATA:cs2} %{WORD}=","cs2=%{GREEDYDATA:cs2}"] } }
                 grok { match => { "cef_or_leef_msg" => ["cs2Label=%{DATA:cs2Label} %{WORD}=","cs2Label=%{GREEDYDATA:cs2Label}"] } }
                 grok { match => { "cef_or_leef_msg" => ["cs3=%{DATA:cs3} %{WORD}=","cs3=%{GREEDYDATA:cs3}"] } }
                 grok { match => { "cef_or_leef_msg" => ["cs3Label=%{DATA:cs3Label} %{WORD}=","cs3Label=%{GREEDYDATA:cs3Label}"] } }
                 grok { match => { "cef_or_leef_msg" => ["cs4=%{DATA:cs4} %{WORD}=","cs4=%{GREEDYDATA:cs4}"] } }
                 grok { match => { "cef_or_leef_msg" => ["cs4Label=%{DATA:cs4Label} %{WORD}=","cs4Label=%{GREEDYDATA:cs4Label}"] } }
                 grok { match => { "cef_or_leef_msg" => ["cs5=%{DATA:cs5} %{WORD}=","cs5=%{GREEDYDATA:cs5}"] } }
                 grok { match => { "cef_or_leef_msg" => ["cs5Label=%{DATA:cs5Label} %{WORD}=","cs5Label=%{GREEDYDATA:cs5Label}"] } }
                 grok { match => { "cef_or_leef_msg" => ["cs6=%{DATA:cs6} %{WORD}=","cs6=%{GREEDYDATA:cs6}"] } }
                 grok { match => { "cef_or_leef_msg" => ["cs6Label=%{DATA:cs6Label} %{WORD}=","cs6Label=%{GREEDYDATA:cs6Label}"] } }
                 grok { match => { "cef_or_leef_msg" => ["destinationServiceName=%{DATA:destinationServiceName} %{WORD}=","destinationServiceName=%{GREEDYDATA:destinationServiceName}"] } }
                 grok { match => { "cef_or_leef_msg" => ["destinationTranslatedAddress=%{DATA:destinationTranslatedAddress} %{WORD}=","destinationTranslatedAddress=%{GREEDYDATA:destinationTranslatedAddress}"] } }
                 grok { match => { "cef_or_leef_msg" => ["destinationTranslatedPort=%{DATA:destinationTranslatedPort} %{WORD}=","destinationTranslatedPort=%{GREEDYDATA:destinationTranslatedPort}"] } }
                 grok { match => { "cef_or_leef_msg" => ["deviceExternalId=%{DATA:deviceExternalId} %{WORD}=","deviceExternalId=%{GREEDYDATA:deviceExternalId}"] } }
                 grok { match => { "cef_or_leef_msg" => ["deviceInboundInterface=%{DATA:deviceInboundInterface} %{WORD}=","deviceInboundInterface=%{GREEDYDATA:deviceInboundInterface}"] } }
                 grok { match => { "cef_or_leef_msg" => ["deviceOutboundInterface=%{DATA:deviceOutboundInterface} %{WORD}=","deviceOutboundInterface=%{GREEDYDATA:deviceOutboundInterface}"] } }
                 grok { match => { "cef_or_leef_msg" => ["dpt=%{DATA:dpt} %{WORD}=","dpt=%{GREEDYDATA:dpt}"] } }
                 grok { match => { "cef_or_leef_msg" => ["dst=%{DATA:dst} %{WORD}=","dst=%{GREEDYDATA:dst}"] } }
                 grok { match => { "cef_or_leef_msg" => ["duid=%{DATA:duid} %{WORD}=","duid=%{GREEDYDATA:duid}"] } }
                 grok { match => { "cef_or_leef_msg" => ["duser=%{DATA:duser} %{WORD}=","duser=%{GREEDYDATA:duser}"] } }
                 grok { match => { "cef_or_leef_msg" => ["dvchost=%{DATA:dvchost} %{WORD}=","dvchost=%{GREEDYDATA:dvchost}"] } }
                 grok { match => { "cef_or_leef_msg" => ["end=%{DATA:end} %{WORD}=","end=%{GREEDYDATA:end}"] } }
                 grok { match => { "cef_or_leef_msg" => ["externalId=%{DATA:externalId} %{WORD}=","externalId=%{GREEDYDATA:externalId}"] } }
                 grok { match => { "cef_or_leef_msg" => ["fileHash=%{DATA:fileHash} %{WORD}=","fileHash=%{GREEDYDATA:fileHash}"] } }
                 grok { match => { "cef_or_leef_msg" => ["fileId=%{DATA:fileId} %{WORD}=","fileId=%{GREEDYDATA:fileId}"] } }
                 grok { match => { "cef_or_leef_msg" => ["filePath=%{DATA:filePath} %{WORD}=","filePath=%{GREEDYDATA:filePath}"] } }
                 grok { match => { "cef_or_leef_msg" => ["fileType=%{DATA:fileType} %{WORD}=","fileType=%{GREEDYDATA:fileType}"] } }
                 grok { match => { "cef_or_leef_msg" => ["flags=%{DATA:flags} %{WORD}=","flags=%{GREEDYDATA:flags}"] } }
                 grok { match => { "cef_or_leef_msg" => ["flexNumber1=%{DATA:flexNumber1} %{WORD}=","flexNumber1=%{GREEDYDATA:flexNumber1}"] } }
                 grok { match => { "cef_or_leef_msg" => ["flexNumber1Label=%{DATA:flexNumber1Label} %{WORD}=","flexNumber1Label=%{GREEDYDATA:flexNumber1Label}"] } }
                 grok { match => { "cef_or_leef_msg" => ["flexNumber2=%{DATA:flexNumber2} %{WORD}=","flexNumber2=%{GREEDYDATA:flexNumber2}"] } }
                 grok { match => { "cef_or_leef_msg" => ["flexNumber2Label=%{DATA:flexNumber2Label} %{WORD}=","flexNumber2Label=%{GREEDYDATA:flexNumber2Label}"] } }
                 grok { match => { "cef_or_leef_msg" => ["flexString1=%{DATA:flexString1} %{WORD}=","flexString1=%{GREEDYDATA:flexString1}"] } }
                 grok { match => { "cef_or_leef_msg" => ["flexString1Label=%{DATA:flexString1Label} %{WORD}=","flexString1Label=%{GREEDYDATA:flexString1Label}"] } }
                 grok { match => { "cef_or_leef_msg" => ["flexString2=%{DATA:flexString2} %{WORD}=","flexString2=%{GREEDYDATA:flexString2}"] } }
                 grok { match => { "cef_or_leef_msg" => ["flexString2Label=%{DATA:flexString2Label} %{WORD}=","flexString2Label=%{GREEDYDATA:flexString2Label}"] } }
                 grok { match => { "cef_or_leef_msg" => ["fname=%{DATA:fname} %{WORD}=","fname=%{GREEDYDATA:fname}"] } }
                 grok { match => { "cef_or_leef_msg" => ["in=%{DATA:in} %{WORD}=","in=%{GREEDYDATA:in}"] } }
                 grok { match => { "cef_or_leef_msg" => ["msg=%{DATA:msg} %{WORD}=","msg=%{GREEDYDATA:msg}"] } }
                 grok { match => { "cef_or_leef_msg" => ["oldFileId=%{DATA:oldFileId} %{WORD}=","oldFileId=%{GREEDYDATA:oldFileId}"] } }
                 grok { match => { "cef_or_leef_msg" => ["out=%{DATA:out} %{WORD}=","out=%{GREEDYDATA:out}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanASServiceDiff=%{DATA:PanASServiceDiff} %{WORD}=","PanASServiceDiff=%{GREEDYDATA:PanASServiceDiff}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanASServiceType=%{DATA:PanASServiceType} %{WORD}=","PanASServiceType=%{GREEDYDATA:PanASServiceType}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanContainerName=%{DATA:PanContainerName} %{WORD}=","PanContainerName=%{GREEDYDATA:PanContainerName}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanDomainEDL=%{DATA:PanDomainEDL} %{WORD}=","PanDomainEDL=%{GREEDYDATA:PanDomainEDL}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanDstDAG=%{DATA:PanDstDAG} %{WORD}=","PanDstDAG=%{GREEDYDATA:PanDstDAG}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanDstDeviceCat=%{DATA:PanDstDeviceCat} %{WORD}=","PanDstDeviceCat=%{GREEDYDATA:PanDstDeviceCat}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanDstDeviceModel=%{DATA:PanDstDeviceModel} %{WORD}=","PanDstDeviceModel=%{GREEDYDATA:PanDstDeviceModel}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanDstDeviceOS=%{DATA:PanDstDeviceOS} %{WORD}=","PanDstDeviceOS=%{GREEDYDATA:PanDstDeviceOS}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanDstDeviceOSv=%{DATA:PanDstDeviceOSv} %{WORD}=","PanDstDeviceOSv=%{GREEDYDATA:PanDstDeviceOSv}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanDstDeviceProf=%{DATA:PanDstDeviceProf} %{WORD}=","PanDstDeviceProf=%{GREEDYDATA:PanDstDeviceProf}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanDstDeviceVendor=%{DATA:PanDstDeviceVendor} %{WORD}=","PanDstDeviceVendor=%{GREEDYDATA:PanDstDeviceVendor}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanDstEDL=%{DATA:PanDstEDL} %{WORD}=","PanDstEDL=%{GREEDYDATA:PanDstEDL}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanDstHostname=%{DATA:PanDstHostname} %{WORD}=","PanDstHostname=%{GREEDYDATA:PanDstHostname}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanDstMac=%{DATA:PanDstMac} %{WORD}=","PanDstMac=%{GREEDYDATA:PanDstMac}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanDynamicUsrgrp=%{DATA:PanDynamicUsrgrp} %{WORD}=","PanDynamicUsrgrp=%{GREEDYDATA:PanDynamicUsrgrp}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanEPSerial=%{DATA:PanEPSerial} %{WORD}=","PanEPSerial=%{GREEDYDATA:PanEPSerial}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanGPHostID=%{DATA:PanGPHostID} %{WORD}=","PanGPHostID=%{GREEDYDATA:PanGPHostID}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanHASessionOwner=%{DATA:PanHASessionOwner} %{WORD}=","PanHASessionOwner=%{GREEDYDATA:PanHASessionOwner}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanJustification=%{DATA:PanJustification} %{WORD}=","PanJustification=%{GREEDYDATA:PanJustification}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanLinkChange=%{DATA:PanLinkChange} %{WORD}=","PanLinkChange=%{GREEDYDATA:PanLinkChange}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanLinkDetail=%{DATA:PanLinkDetail} %{WORD}=","PanLinkDetail=%{GREEDYDATA:PanLinkDetail}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSActionFlags=%{DATA:PanOSActionFlags} %{WORD}=","PanOSActionFlags=%{GREEDYDATA:PanOSActionFlags}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSAPName=%{DATA:PanOSAPName} %{WORD}=","PanOSAPName=%{GREEDYDATA:PanOSAPName}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSAreaCode=%{DATA:PanOSAreaCode} %{WORD}=","PanOSAreaCode=%{GREEDYDATA:PanOSAreaCode}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSAssocID=%{DATA:PanOSAssocID} %{WORD}=","PanOSAssocID=%{GREEDYDATA:PanOSAssocID}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSAttemptedGateways=%{DATA:PanOSAttemptedGateways} %{WORD}=","PanOSAttemptedGateways=%{GREEDYDATA:PanOSAttemptedGateways}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSAuthMethod=%{DATA:PanOSAuthMethod} %{WORD}=","PanOSAuthMethod=%{GREEDYDATA:PanOSAuthMethod}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSCellID=%{DATA:PanOSCellID} %{WORD}=","PanOSCellID=%{GREEDYDATA:PanOSCellID}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSCertificateFlags=%{DATA:PanOSCertificateFlags} %{WORD}=","PanOSCertificateFlags=%{GREEDYDATA:PanOSCertificateFlags}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSCertificateSerial=%{DATA:PanOSCertificateSerial} %{WORD}=","PanOSCertificateSerial=%{GREEDYDATA:PanOSCertificateSerial}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSCertificateSize=%{DATA:PanOSCertificateSize} %{WORD}=","PanOSCertificateSize=%{GREEDYDATA:PanOSCertificateSize}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSCertificateVersion=%{DATA:PanOSCertificateVersion} %{WORD}=","PanOSCertificateVersion=%{GREEDYDATA:PanOSCertificateVersion}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSChainStatus=%{DATA:PanOSChainStatus} %{WORD}=","PanOSChainStatus=%{GREEDYDATA:PanOSChainStatus}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSChunkType=%{DATA:PanOSChunkType} %{WORD}=","PanOSChunkType=%{GREEDYDATA:PanOSChunkType}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSClientToFirewall=%{DATA:PanOSClientToFirewall} %{WORD}=","PanOSClientToFirewall=%{GREEDYDATA:PanOSClientToFirewall}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSCommonName=%{DATA:PanOSCommonName} %{WORD}=","PanOSCommonName=%{GREEDYDATA:PanOSCommonName}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSCommonNameLength=%{DATA:PanOSCommonNameLength} %{WORD}=","PanOSCommonNameLength=%{GREEDYDATA:PanOSCommonNameLength}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSConfigVersion=%{DATA:PanOSConfigVersion} %{WORD}=","PanOSConfigVersion=%{GREEDYDATA:PanOSConfigVersion}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSConnectionError=%{DATA:PanOSConnectionError} %{WORD}=","PanOSConnectionError=%{GREEDYDATA:PanOSConnectionError}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSConnectionErrorID=%{DATA:PanOSConnectionErrorID} %{WORD}=","PanOSConnectionErrorID=%{GREEDYDATA:PanOSConnectionErrorID}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSConnectionMethod=%{DATA:PanOSConnectionMethod} %{WORD}=","PanOSConnectionMethod=%{GREEDYDATA:PanOSConnectionMethod}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSContainerID=%{DATA:PanOSContainerID} %{WORD}=","PanOSContainerID=%{GREEDYDATA:PanOSContainerID}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSContainerName=%{DATA:PanOSContainerName} %{WORD}=","PanOSContainerName=%{GREEDYDATA:PanOSContainerName}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSContainerNameSpace=%{DATA:PanOSContainerNameSpace} %{WORD}=","PanOSContainerNameSpace=%{GREEDYDATA:PanOSContainerNameSpace}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSContentVer=%{DATA:PanOSContentVer} %{WORD}=","PanOSContentVer=%{GREEDYDATA:PanOSContentVer}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSCountOfRepeats=%{DATA:PanOSCountOfRepeats} %{WORD}=","PanOSCountOfRepeats=%{GREEDYDATA:PanOSCountOfRepeats}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSDataSourceName=%{DATA:PanOSDataSourceName} %{WORD}=","PanOSDataSourceName=%{GREEDYDATA:PanOSDataSourceName}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSDataSourceSubType=%{DATA:PanOSDataSourceSubType} %{WORD}=","PanOSDataSourceSubType=%{GREEDYDATA:PanOSDataSourceSubType}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSDataSourceType=%{DATA:PanOSDataSourceType} %{WORD}=","PanOSDataSourceType=%{GREEDYDATA:PanOSDataSourceType}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSDesc=%{DATA:PanOSDesc} %{WORD}=","PanOSDesc=%{GREEDYDATA:PanOSDesc}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSDescription=%{DATA:PanOSDescription} %{WORD}=","PanOSDescription=%{GREEDYDATA:PanOSDescription}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSDestinationDeviceCategory=%{DATA:PanOSDestinationDeviceCategory} %{WORD}=","PanOSDestinationDeviceCategory=%{GREEDYDATA:PanOSDestinationDeviceCategory}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSDestinationDeviceHost=%{DATA:PanOSDestinationDeviceHost} %{WORD}=","PanOSDestinationDeviceHost=%{GREEDYDATA:PanOSDestinationDeviceHost}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSDestinationDeviceMac=%{DATA:PanOSDestinationDeviceMac} %{WORD}=","PanOSDestinationDeviceMac=%{GREEDYDATA:PanOSDestinationDeviceMac}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSDestinationDeviceModel=%{DATA:PanOSDestinationDeviceModel} %{WORD}=","PanOSDestinationDeviceModel=%{GREEDYDATA:PanOSDestinationDeviceModel}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSDestinationDeviceOSFamily=%{DATA:PanOSDestinationDeviceOSFamily} %{WORD}=","PanOSDestinationDeviceOSFamily=%{GREEDYDATA:PanOSDestinationDeviceOSFamily}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSDestinationDeviceOSVersion=%{DATA:PanOSDestinationDeviceOSVersion} %{WORD}=","PanOSDestinationDeviceOSVersion=%{GREEDYDATA:PanOSDestinationDeviceOSVersion}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSDestinationDeviceProfile=%{DATA:PanOSDestinationDeviceProfile} %{WORD}=","PanOSDestinationDeviceProfile=%{GREEDYDATA:PanOSDestinationDeviceProfile}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSDestinationDeviceVendor=%{DATA:PanOSDestinationDeviceVendor} %{WORD}=","PanOSDestinationDeviceVendor=%{GREEDYDATA:PanOSDestinationDeviceVendor}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSDestinationDynamicAddressGroup=%{DATA:PanOSDestinationDynamicAddressGroup} %{WORD}=","PanOSDestinationDynamicAddressGroup=%{GREEDYDATA:PanOSDestinationDynamicAddressGroup}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSDestinationEDL=%{DATA:PanOSDestinationEDL} %{WORD}=","PanOSDestinationEDL=%{GREEDYDATA:PanOSDestinationEDL}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSDestinationUUID=%{DATA:PanOSDestinationUUID} %{WORD}=","PanOSDestinationUUID=%{GREEDYDATA:PanOSDestinationUUID}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSDeviceSN=%{DATA:PanOSDeviceSN} %{WORD}=","PanOSDeviceSN=%{GREEDYDATA:PanOSDeviceSN}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSDGl1=%{DATA:PanOSDGl1} %{WORD}=","PanOSDGl1=%{GREEDYDATA:PanOSDGl1}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSDGl2=%{DATA:PanOSDGl2} %{WORD}=","PanOSDGl2=%{GREEDYDATA:PanOSDGl2}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSDGl3=%{DATA:PanOSDGl3} %{WORD}=","PanOSDGl3=%{GREEDYDATA:PanOSDGl3}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSDGl4=%{DATA:PanOSDGl4} %{WORD}=","PanOSDGl4=%{GREEDYDATA:PanOSDGl4}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSDiameterApp=%{DATA:PanOSDiameterApp} %{WORD}=","PanOSDiameterApp=%{GREEDYDATA:PanOSDiameterApp}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSDiameterAVPCode=%{DATA:PanOSDiameterAVPCode} %{WORD}=","PanOSDiameterAVPCode=%{GREEDYDATA:PanOSDiameterAVPCode}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSDiameterCmdCode=%{DATA:PanOSDiameterCmdCode} %{WORD}=","PanOSDiameterCmdCode=%{GREEDYDATA:PanOSDiameterCmdCode}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSDstUUID=%{DATA:PanOSDstUUID} %{WORD}=","PanOSDstUUID=%{GREEDYDATA:PanOSDstUUID}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSEllipticCurve=%{DATA:PanOSEllipticCurve} %{WORD}=","PanOSEllipticCurve=%{GREEDYDATA:PanOSEllipticCurve}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSEndpointDeviceName=%{DATA:PanOSEndpointDeviceName} %{WORD}=","PanOSEndpointDeviceName=%{GREEDYDATA:PanOSEndpointDeviceName}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSEndpointMac=%{DATA:PanOSEndpointMac} %{WORD}=","PanOSEndpointMac=%{GREEDYDATA:PanOSEndpointMac}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSEndpointOSType=%{DATA:PanOSEndpointOSType} %{WORD}=","PanOSEndpointOSType=%{GREEDYDATA:PanOSEndpointOSType}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSEndpointOSVersion=%{DATA:PanOSEndpointOSVersion} %{WORD}=","PanOSEndpointOSVersion=%{GREEDYDATA:PanOSEndpointOSVersion}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSEndpointSerialNumber=%{DATA:PanOSEndpointSerialNumber} %{WORD}=","PanOSEndpointSerialNumber=%{GREEDYDATA:PanOSEndpointSerialNumber}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSEndUserIP=%{DATA:PanOSEndUserIP} %{WORD}=","PanOSEndUserIP=%{GREEDYDATA:PanOSEndUserIP}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSErrorIndex=%{DATA:PanOSErrorIndex} %{WORD}=","PanOSErrorIndex=%{GREEDYDATA:PanOSErrorIndex}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSErrorMessage=%{DATA:PanOSErrorMessage} %{WORD}=","PanOSErrorMessage=%{GREEDYDATA:PanOSErrorMessage}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSEventID=%{DATA:PanOSEventID} %{WORD}=","PanOSEventID=%{GREEDYDATA:PanOSEventID}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSEventStatus=%{DATA:PanOSEventStatus} %{WORD}=","PanOSEventStatus=%{GREEDYDATA:PanOSEventStatus}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSFingerprint=%{DATA:PanOSFingerprint} %{WORD}=","PanOSFingerprint=%{GREEDYDATA:PanOSFingerprint}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSFirewallToServer=%{DATA:PanOSFirewallToServer} %{WORD}=","PanOSFirewallToServer=%{GREEDYDATA:PanOSFirewallToServer}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSFWDeviceGroup=%{DATA:PanOSFWDeviceGroup} %{WORD}=","PanOSFWDeviceGroup=%{GREEDYDATA:PanOSFWDeviceGroup}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSGateway=%{DATA:PanOSGateway} %{WORD}=","PanOSGateway=%{GREEDYDATA:PanOSGateway}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSGatewayPriority=%{DATA:PanOSGatewayPriority} %{WORD}=","PanOSGatewayPriority=%{GREEDYDATA:PanOSGatewayPriority}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSGatewaySelectionType=%{DATA:PanOSGatewaySelectionType} %{WORD}=","PanOSGatewaySelectionType=%{GREEDYDATA:PanOSGatewaySelectionType}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSGlobalProtectClientVersion=%{DATA:PanOSGlobalProtectClientVersion} %{WORD}=","PanOSGlobalProtectClientVersion=%{GREEDYDATA:PanOSGlobalProtectClientVersion}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSGPGatewayLocation=%{DATA:PanOSGPGatewayLocation} %{WORD}=","PanOSGPGatewayLocation=%{GREEDYDATA:PanOSGPGatewayLocation}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSGTPCause=%{DATA:PanOSGTPCause} %{WORD}=","PanOSGTPCause=%{GREEDYDATA:PanOSGTPCause}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSGTPEventCode=%{DATA:PanOSGTPEventCode} %{WORD}=","PanOSGTPEventCode=%{GREEDYDATA:PanOSGTPEventCode}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSGTPEventType=%{DATA:PanOSGTPEventType} %{WORD}=","PanOSGTPEventType=%{GREEDYDATA:PanOSGTPEventType}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSGTPInterface=%{DATA:PanOSGTPInterface} %{WORD}=","PanOSGTPInterface=%{GREEDYDATA:PanOSGTPInterface}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSGTPMsgType=%{DATA:PanOSGTPMsgType} %{WORD}=","PanOSGTPMsgType=%{GREEDYDATA:PanOSGTPMsgType}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSHostID=%{DATA:PanOSHostID} %{WORD}=","PanOSHostID=%{GREEDYDATA:PanOSHostID}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSHTTP2Con=%{DATA:PanOSHTTP2Con} %{WORD}=","PanOSHTTP2Con=%{GREEDYDATA:PanOSHTTP2Con}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSHTTPHeader=%{DATA:PanOSHTTPHeader} %{WORD}=","PanOSHTTPHeader=%{GREEDYDATA:PanOSHTTPHeader}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSHTTPUserAgent=%{DATA:PanOSHTTPUserAgent} %{WORD}=","PanOSHTTPUserAgent=%{GREEDYDATA:PanOSHTTPUserAgent}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSIssuerCommonName=%{DATA:PanOSIssuerCommonName} %{WORD}=","PanOSIssuerCommonName=%{GREEDYDATA:PanOSIssuerCommonName}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSIssuerNameLength=%{DATA:PanOSIssuerNameLength} %{WORD}=","PanOSIssuerNameLength=%{GREEDYDATA:PanOSIssuerNameLength}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSLoginDuration=%{DATA:PanOSLoginDuration} %{WORD}=","PanOSLoginDuration=%{GREEDYDATA:PanOSLoginDuration}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSLogTimeStamp=%{DATA:PanOSLogTimeStamp} %{WORD}=","PanOSLogTimeStamp=%{GREEDYDATA:PanOSLogTimeStamp}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSLogTypeSeqNo=%{DATA:PanOSLogTypeSeqNo} %{WORD}=","PanOSLogTypeSeqNo=%{GREEDYDATA:PanOSLogTypeSeqNo}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSMonitorTag=%{DATA:PanOSMonitorTag} %{WORD}=","PanOSMonitorTag=%{GREEDYDATA:PanOSMonitorTag}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSMSISDN=%{DATA:PanOSMSISDN} %{WORD}=","PanOSMSISDN=%{GREEDYDATA:PanOSMSISDN}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSOpCode=%{DATA:PanOSOpCode} %{WORD}=","PanOSOpCode=%{GREEDYDATA:PanOSOpCode}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSPacketsReceived=%{DATA:PanOSPacketsReceived} %{WORD}=","PanOSPacketsReceived=%{GREEDYDATA:PanOSPacketsReceived}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSPacketsSent=%{DATA:PanOSPacketsSent} %{WORD}=","PanOSPacketsSent=%{GREEDYDATA:PanOSPacketsSent}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSParentSessionID=%{DATA:PanOSParentSessionID} %{WORD}=","PanOSParentSessionID=%{GREEDYDATA:PanOSParentSessionID}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSParentStartTime=%{DATA:PanOSParentStartTime} %{WORD}=","PanOSParentStartTime=%{GREEDYDATA:PanOSParentStartTime}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSPayloadProtID=%{DATA:PanOSPayloadProtID} %{WORD}=","PanOSPayloadProtID=%{GREEDYDATA:PanOSPayloadProtID}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSPcapID=%{DATA:PanOSPcapID} %{WORD}=","PanOSPcapID=%{GREEDYDATA:PanOSPcapID}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSPolicyAuditComment=%{DATA:PanOSPolicyAuditComment} %{WORD}=","PanOSPolicyAuditComment=%{GREEDYDATA:PanOSPolicyAuditComment}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSPolicyName=%{DATA:PanOSPolicyName} %{WORD}=","PanOSPolicyName=%{GREEDYDATA:PanOSPolicyName}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSPortal=%{DATA:PanOSPortal} %{WORD}=","PanOSPortal=%{GREEDYDATA:PanOSPortal}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSPPID=%{DATA:PanOSPPID} %{WORD}=","PanOSPPID=%{GREEDYDATA:PanOSPPID}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSPrivateIPv4=%{DATA:PanOSPrivateIPv4} %{WORD}=","PanOSPrivateIPv4=%{GREEDYDATA:PanOSPrivateIPv4}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSPrivateIPv6=%{DATA:PanOSPrivateIPv6} %{WORD}=","PanOSPrivateIPv6=%{GREEDYDATA:PanOSPrivateIPv6}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSProxyType=%{DATA:PanOSProxyType} %{WORD}=","PanOSProxyType=%{GREEDYDATA:PanOSProxyType}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSPublicIPv4=%{DATA:PanOSPublicIPv4} %{WORD}=","PanOSPublicIPv4=%{GREEDYDATA:PanOSPublicIPv4}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSPublicIPv6=%{DATA:PanOSPublicIPv6} %{WORD}=","PanOSPublicIPv6=%{GREEDYDATA:PanOSPublicIPv6}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSQuarantineReason=%{DATA:PanOSQuarantineReason} %{WORD}=","PanOSQuarantineReason=%{GREEDYDATA:PanOSQuarantineReason}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSRadioTech=%{DATA:PanOSRadioTech} %{WORD}=","PanOSRadioTech=%{GREEDYDATA:PanOSRadioTech}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSReferer=%{DATA:PanOSReferer} %{WORD}=","PanOSReferer=%{GREEDYDATA:PanOSReferer}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSRmtUserID=%{DATA:PanOSRmtUserID} %{WORD}=","PanOSRmtUserID=%{GREEDYDATA:PanOSRmtUserID}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSRmtUserIP=%{DATA:PanOSRmtUserIP} %{WORD}=","PanOSRmtUserIP=%{GREEDYDATA:PanOSRmtUserIP}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSRootCNLength=%{DATA:PanOSRootCNLength} %{WORD}=","PanOSRootCNLength=%{GREEDYDATA:PanOSRootCNLength}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSRootCommonName=%{DATA:PanOSRootCommonName} %{WORD}=","PanOSRootCommonName=%{GREEDYDATA:PanOSRootCommonName}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSRootStatus=%{DATA:PanOSRootStatus} %{WORD}=","PanOSRootStatus=%{GREEDYDATA:PanOSRootStatus}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSRuleUUID=%{DATA:PanOSRuleUUID} %{WORD}=","PanOSRuleUUID=%{GREEDYDATA:PanOSRuleUUID}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSSCCPCallingGT=%{DATA:PanOSSCCPCallingGT} %{WORD}=","PanOSSCCPCallingGT=%{GREEDYDATA:PanOSSCCPCallingGT}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSSCCPCallingPartySSN=%{DATA:PanOSSCCPCallingPartySSN} %{WORD}=","PanOSSCCPCallingPartySSN=%{GREEDYDATA:PanOSSCCPCallingPartySSN}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSSCTPAssocEndReason=%{DATA:PanOSSCTPAssocEndReason} %{WORD}=","PanOSSCTPAssocEndReason=%{GREEDYDATA:PanOSSCTPAssocEndReason}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSSCTPAssocID=%{DATA:PanOSSCTPAssocID} %{WORD}=","PanOSSCTPAssocID=%{GREEDYDATA:PanOSSCTPAssocID}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSSCTPCauseCode=%{DATA:PanOSSCTPCauseCode} %{WORD}=","PanOSSCTPCauseCode=%{GREEDYDATA:PanOSSCTPCauseCode}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSSCTPChunkRcv=%{DATA:PanOSSCTPChunkRcv} %{WORD}=","PanOSSCTPChunkRcv=%{GREEDYDATA:PanOSSCTPChunkRcv}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSSCTPChunks=%{DATA:PanOSSCTPChunks} %{WORD}=","PanOSSCTPChunks=%{GREEDYDATA:PanOSSCTPChunks}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSSCTPChunkSent=%{DATA:PanOSSCTPChunkSent} %{WORD}=","PanOSSCTPChunkSent=%{GREEDYDATA:PanOSSCTPChunkSent}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSSCTPChunksRcv=%{DATA:PanOSSCTPChunksRcv} %{WORD}=","PanOSSCTPChunksRcv=%{GREEDYDATA:PanOSSCTPChunksRcv}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSSCTPFilter=%{DATA:PanOSSCTPFilter} %{WORD}=","PanOSSCTPFilter=%{GREEDYDATA:PanOSSCTPFilter}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSSCTPStreamID=%{DATA:PanOSSCTPStreamID} %{WORD}=","PanOSSCTPStreamID=%{GREEDYDATA:PanOSSCTPStreamID}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSSCTPVerTag1=%{DATA:PanOSSCTPVerTag1} %{WORD}=","PanOSSCTPVerTag1=%{GREEDYDATA:PanOSSCTPVerTag1}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSSCTPVerTag2=%{DATA:PanOSSCTPVerTag2} %{WORD}=","PanOSSCTPVerTag2=%{GREEDYDATA:PanOSSCTPVerTag2}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSSequenceNo=%{DATA:PanOSSequenceNo} %{WORD}=","PanOSSequenceNo=%{GREEDYDATA:PanOSSequenceNo}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSServerNameIndication=%{DATA:PanOSServerNameIndication} %{WORD}=","PanOSServerNameIndication=%{GREEDYDATA:PanOSServerNameIndication}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSServingCntryMCC=%{DATA:PanOSServingCntryMCC} %{WORD}=","PanOSServingCntryMCC=%{GREEDYDATA:PanOSServingCntryMCC}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSServingNetMNC=%{DATA:PanOSServingNetMNC} %{WORD}=","PanOSServingNetMNC=%{GREEDYDATA:PanOSServingNetMNC}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSSeverity=%{DATA:PanOSSeverity} %{WORD}=","PanOSSeverity=%{GREEDYDATA:PanOSSeverity}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSSNILength=%{DATA:PanOSSNILength} %{WORD}=","PanOSSNILength=%{GREEDYDATA:PanOSSNILength}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSSourceDeviceCategory=%{DATA:PanOSSourceDeviceCategory} %{WORD}=","PanOSSourceDeviceCategory=%{GREEDYDATA:PanOSSourceDeviceCategory}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSSourceDeviceHost=%{DATA:PanOSSourceDeviceHost} %{WORD}=","PanOSSourceDeviceHost=%{GREEDYDATA:PanOSSourceDeviceHost}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSSourceDeviceMac=%{DATA:PanOSSourceDeviceMac} %{WORD}=","PanOSSourceDeviceMac=%{GREEDYDATA:PanOSSourceDeviceMac}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSSourceDeviceModel=%{DATA:PanOSSourceDeviceModel} %{WORD}=","PanOSSourceDeviceModel=%{GREEDYDATA:PanOSSourceDeviceModel}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSSourceDeviceOSFamily=%{DATA:PanOSSourceDeviceOSFamily} %{WORD}=","PanOSSourceDeviceOSFamily=%{GREEDYDATA:PanOSSourceDeviceOSFamily}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSSourceDeviceOSVersion=%{DATA:PanOSSourceDeviceOSVersion} %{WORD}=","PanOSSourceDeviceOSVersion=%{GREEDYDATA:PanOSSourceDeviceOSVersion}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSSourceDeviceProfile=%{DATA:PanOSSourceDeviceProfile} %{WORD}=","PanOSSourceDeviceProfile=%{GREEDYDATA:PanOSSourceDeviceProfile}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSSourceDeviceVendor=%{DATA:PanOSSourceDeviceVendor} %{WORD}=","PanOSSourceDeviceVendor=%{GREEDYDATA:PanOSSourceDeviceVendor}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSSourceDynamicAddressGroup=%{DATA:PanOSSourceDynamicAddressGroup} %{WORD}=","PanOSSourceDynamicAddressGroup=%{GREEDYDATA:PanOSSourceDynamicAddressGroup}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSSourceEDL=%{DATA:PanOSSourceEDL} %{WORD}=","PanOSSourceEDL=%{GREEDYDATA:PanOSSourceEDL}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSSourceHostname=%{DATA:PanOSSourceHostname} %{WORD}=","PanOSSourceHostname=%{GREEDYDATA:PanOSSourceHostname}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSSourceMac=%{DATA:PanOSSourceMac} %{WORD}=","PanOSSourceMac=%{GREEDYDATA:PanOSSourceMac}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSSourceRegion=%{DATA:PanOSSourceRegion} %{WORD}=","PanOSSourceRegion=%{GREEDYDATA:PanOSSourceRegion}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSSourceUserName=%{DATA:PanOSSourceUserName} %{WORD}=","PanOSSourceUserName=%{GREEDYDATA:PanOSSourceUserName}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSSourceUUID=%{DATA:PanOSSourceUUID} %{WORD}=","PanOSSourceUUID=%{GREEDYDATA:PanOSSourceUUID}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSSrcUUID=%{DATA:PanOSSrcUUID} %{WORD}=","PanOSSrcUUID=%{GREEDYDATA:PanOSSrcUUID}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSSSLResponseTime=%{DATA:PanOSSSLResponseTime} %{WORD}=","PanOSSSLResponseTime=%{GREEDYDATA:PanOSSSLResponseTime}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSStage=%{DATA:PanOSStage} %{WORD}=","PanOSStage=%{GREEDYDATA:PanOSStage}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSTagName=%{DATA:PanOSTagName} %{WORD}=","PanOSTagName=%{GREEDYDATA:PanOSTagName}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSThreatCategory=%{DATA:PanOSThreatCategory} %{WORD}=","PanOSThreatCategory=%{GREEDYDATA:PanOSThreatCategory}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSTimeGeneratedHighResolution=%{DATA:PanOSTimeGeneratedHighResolution} %{WORD}=","PanOSTimeGeneratedHighResolution=%{GREEDYDATA:PanOSTimeGeneratedHighResolution}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSTimeNotAfter=%{DATA:PanOSTimeNotAfter} %{WORD}=","PanOSTimeNotAfter=%{GREEDYDATA:PanOSTimeNotAfter}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSTimeNotBefore=%{DATA:PanOSTimeNotBefore} %{WORD}=","PanOSTimeNotBefore=%{GREEDYDATA:PanOSTimeNotBefore}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSTimeout=%{DATA:PanOSTimeout} %{WORD}=","PanOSTimeout=%{GREEDYDATA:PanOSTimeout}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSTimeReceivedManagementPlane=%{DATA:PanOSTimeReceivedManagementPlane} %{WORD}=","PanOSTimeReceivedManagementPlane=%{GREEDYDATA:PanOSTimeReceivedManagementPlane}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSTLSAuth=%{DATA:PanOSTLSAuth} %{WORD}=","PanOSTLSAuth=%{GREEDYDATA:PanOSTLSAuth}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSTLSEncryptionAlgorithm=%{DATA:PanOSTLSEncryptionAlgorithm} %{WORD}=","PanOSTLSEncryptionAlgorithm=%{GREEDYDATA:PanOSTLSEncryptionAlgorithm}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSTLSKeyExchange=%{DATA:PanOSTLSKeyExchange} %{WORD}=","PanOSTLSKeyExchange=%{GREEDYDATA:PanOSTLSKeyExchange}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSTLSVersion=%{DATA:PanOSTLSVersion} %{WORD}=","PanOSTLSVersion=%{GREEDYDATA:PanOSTLSVersion}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSTrafficOriginRegion=%{DATA:PanOSTrafficOriginRegion} %{WORD}=","PanOSTrafficOriginRegion=%{GREEDYDATA:PanOSTrafficOriginRegion}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSTrafficSessionID=%{DATA:PanOSTrafficSessionID} %{WORD}=","PanOSTrafficSessionID=%{GREEDYDATA:PanOSTrafficSessionID}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSTunneInspectionRule=%{DATA:PanOSTunneInspectionRule} %{WORD}=","PanOSTunneInspectionRule=%{GREEDYDATA:PanOSTunneInspectionRule}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSTunnel=%{DATA:PanOSTunnel} %{WORD}=","PanOSTunnel=%{GREEDYDATA:PanOSTunnel}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSTunnelEndptID1=%{DATA:PanOSTunnelEndptID1} %{WORD}=","PanOSTunnelEndptID1=%{GREEDYDATA:PanOSTunnelEndptID1}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSTunnelEndptID2=%{DATA:PanOSTunnelEndptID2} %{WORD}=","PanOSTunnelEndptID2=%{GREEDYDATA:PanOSTunnelEndptID2}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSTunnelFragment=%{DATA:PanOSTunnelFragment} %{WORD}=","PanOSTunnelFragment=%{GREEDYDATA:PanOSTunnelFragment}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSTunnelID=%{DATA:PanOSTunnelID} %{WORD}=","PanOSTunnelID=%{GREEDYDATA:PanOSTunnelID}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSTunnelInspectionRule=%{DATA:PanOSTunnelInspectionRule} %{WORD}=","PanOSTunnelInspectionRule=%{GREEDYDATA:PanOSTunnelInspectionRule}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSTunnelType=%{DATA:PanOSTunnelType} %{WORD}=","PanOSTunnelType=%{GREEDYDATA:PanOSTunnelType}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSUGFlags=%{DATA:PanOSUGFlags} %{WORD}=","PanOSUGFlags=%{GREEDYDATA:PanOSUGFlags}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSURLCatList=%{DATA:PanOSURLCatList} %{WORD}=","PanOSURLCatList=%{GREEDYDATA:PanOSURLCatList}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSUserBySource=%{DATA:PanOSUserBySource} %{WORD}=","PanOSUserBySource=%{GREEDYDATA:PanOSUserBySource}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSVirtualSystem=%{DATA:PanOSVirtualSystem} %{WORD}=","PanOSVirtualSystem=%{GREEDYDATA:PanOSVirtualSystem}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSVsysName=%{DATA:PanOSVsysName} %{WORD}=","PanOSVsysName=%{GREEDYDATA:PanOSVsysName}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanOSXForwarderfor=%{DATA:PanOSXForwarderfor} %{WORD}=","PanOSXForwarderfor=%{GREEDYDATA:PanOSXForwarderfor}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanPartialHash=%{DATA:PanPartialHash} %{WORD}=","PanPartialHash=%{GREEDYDATA:PanPartialHash}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanPODName=%{DATA:PanPODName} %{WORD}=","PanPODName=%{GREEDYDATA:PanPODName}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanPODNamespace=%{DATA:PanPODNamespace} %{WORD}=","PanPODNamespace=%{GREEDYDATA:PanPODNamespace}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanPolicyID=%{DATA:PanPolicyID} %{WORD}=","PanPolicyID=%{GREEDYDATA:PanPolicyID}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanReasonFilteringAction=%{DATA:PanReasonFilteringAction} %{WORD}=","PanReasonFilteringAction=%{GREEDYDATA:PanReasonFilteringAction}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanSDWANCluster=%{DATA:PanSDWANCluster} %{WORD}=","PanSDWANCluster=%{GREEDYDATA:PanSDWANCluster}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanSDWANClustype=%{DATA:PanSDWANClustype} %{WORD}=","PanSDWANClustype=%{GREEDYDATA:PanSDWANClustype}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanSDWANDevice=%{DATA:PanSDWANDevice} %{WORD}=","PanSDWANDevice=%{GREEDYDATA:PanSDWANDevice}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanSDWANSite=%{DATA:PanSDWANSite} %{WORD}=","PanSDWANSite=%{GREEDYDATA:PanSDWANSite}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanSrcDAG=%{DATA:PanSrcDAG} %{WORD}=","PanSrcDAG=%{GREEDYDATA:PanSrcDAG}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanSrcDeviceCat=%{DATA:PanSrcDeviceCat} %{WORD}=","PanSrcDeviceCat=%{GREEDYDATA:PanSrcDeviceCat}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanSrcDeviceModel=%{DATA:PanSrcDeviceModel} %{WORD}=","PanSrcDeviceModel=%{GREEDYDATA:PanSrcDeviceModel}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanSrcDeviceOS=%{DATA:PanSrcDeviceOS} %{WORD}=","PanSrcDeviceOS=%{GREEDYDATA:PanSrcDeviceOS}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanSrcDeviceOSv=%{DATA:PanSrcDeviceOSv} %{WORD}=","PanSrcDeviceOSv=%{GREEDYDATA:PanSrcDeviceOSv}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanSrcDeviceProf=%{DATA:PanSrcDeviceProf} %{WORD}=","PanSrcDeviceProf=%{GREEDYDATA:PanSrcDeviceProf}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanSrcDeviceVendor=%{DATA:PanSrcDeviceVendor} %{WORD}=","PanSrcDeviceVendor=%{GREEDYDATA:PanSrcDeviceVendor}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanSrcEDL=%{DATA:PanSrcEDL} %{WORD}=","PanSrcEDL=%{GREEDYDATA:PanSrcEDL}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanSrcHostname=%{DATA:PanSrcHostname} %{WORD}=","PanSrcHostname=%{GREEDYDATA:PanSrcHostname}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanSrcMac=%{DATA:PanSrcMac} %{WORD}=","PanSrcMac=%{GREEDYDATA:PanSrcMac}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanTimeHighRes=%{DATA:PanTimeHighRes} %{WORD}=","PanTimeHighRes=%{GREEDYDATA:PanTimeHighRes}"] } }
                 grok { match => { "cef_or_leef_msg" => ["PanXFFIP=%{DATA:PanXFFIP} %{WORD}=","PanXFFIP=%{GREEDYDATA:PanXFFIP}"] } }
                 grok { match => { "cef_or_leef_msg" => ["proto=%{DATA:proto} %{WORD}=","proto=%{GREEDYDATA:proto}"] } }
                 grok { match => { "cef_or_leef_msg" => ["reason=%{DATA:reason} %{WORD}=","reason=%{GREEDYDATA:reason}"] } }
                 grok { match => { "cef_or_leef_msg" => ["request=%{DATA:request} %{WORD}=","request=%{GREEDYDATA:request}"] } }
                 grok { match => { "cef_or_leef_msg" => ["requestClientApplication=%{DATA:requestClientApplication} %{WORD}=","requestClientApplication=%{GREEDYDATA:requestClientApplication}"] } }
                 grok { match => { "cef_or_leef_msg" => ["requestContext=%{DATA:requestContext} %{WORD}=","requestContext=%{GREEDYDATA:requestContext}"] } }
                 grok { match => { "cef_or_leef_msg" => ["requestMethod=%{DATA:requestMethod} %{WORD}=","requestMethod=%{GREEDYDATA:requestMethod}"] } }
                 grok { match => { "cef_or_leef_msg" => ["rt=%{DATA:rt} %{WORD}=","rt=%{GREEDYDATA:rt}"] } }
                 grok { match => { "cef_or_leef_msg" => ["shost=%{DATA:shost} %{WORD}=","shost=%{GREEDYDATA:shost}"] } }
                 grok { match => { "cef_or_leef_msg" => ["sourceTranslatedAddress=%{DATA:sourceTranslatedAddress} %{WORD}=","sourceTranslatedAddress=%{GREEDYDATA:sourceTranslatedAddress}"] } }
                 grok { match => { "cef_or_leef_msg" => ["sourceTranslatedPort=%{DATA:sourceTranslatedPort} %{WORD}=","sourceTranslatedPort=%{GREEDYDATA:sourceTranslatedPort}"] } }
                 grok { match => { "cef_or_leef_msg" => ["spt=%{DATA:spt} %{WORD}=","spt=%{GREEDYDATA:spt}"] } }
                 grok { match => { "cef_or_leef_msg" => ["src=%{DATA:src} %{WORD}=","src=%{GREEDYDATA:src}"] } }
                 grok { match => { "cef_or_leef_msg" => ["start=%{DATA:start} %{WORD}=","start=%{GREEDYDATA:start}"] } }
                 grok { match => { "cef_or_leef_msg" => ["suid=%{DATA:suid} %{WORD}=","suid=%{GREEDYDATA:suid}"] } }
                 grok { match => { "cef_or_leef_msg" => ["suser=%{DATA:suser} %{WORD}=","suser=%{GREEDYDATA:suser}"] } }
#......................................................................#
# Rename fields (individual groks results)
                mutate {
                 rename => { "[act]" => "[kv_field][act]" }
                 rename => { "[anOSTimeGeneratedHighResolution]" => "[kv_field][anOSTimeGeneratedHighResolution]" }
                 rename => { "[app]" => "[kv_field][app]" }
                 rename => { "[c6a2]" => "[kv_field][c6a2]" }
                 rename => { "[c6a2Label]" => "[kv_field][c6a2Label]" }
                 rename => { "[cat]" => "[kv_field][cat]" }
                 rename => { "[cfp1]" => "[kv_field][cfp1]" }
                 rename => { "[cfp1Label]" => "[kv_field][cfp1Label]" }
                 rename => { "[cfp2]" => "[kv_field][cfp2]" }
                 rename => { "[cfp2Label]" => "[kv_field][cfp2Label]" }
                 rename => { "[cfp3]" => "[kv_field][cfp3]" }
                 rename => { "[cfp3Label]" => "[kv_field][cfp3Label]" }
                 rename => { "[cfp4]" => "[kv_field][cfp4]" }
                 rename => { "[cfp4Label]" => "[kv_field][cfp4Label]" }
                 rename => { "[cn1]" => "[kv_field][cn1]" }
                 rename => { "[cn1Label]" => "[kv_field][cn1Label]" }
                 rename => { "[cn2]" => "[kv_field][cn2]" }
                 rename => { "[cn2Label]" => "[kv_field][cn2Label]" }
                 rename => { "[cn3]" => "[kv_field][cn3]" }
                 rename => { "[cn3Label]" => "[kv_field][cn3Label]" }
                 rename => { "[cn4]" => "[kv_field][cn4]" }
                 rename => { "[cn4Label]" => "[kv_field][cn4Label]" }
                 rename => { "[cn5]" => "[kv_field][cn5]" }
                 rename => { "[cn5Label]" => "[kv_field][cn5Label]" }
                 rename => { "[cn6]" => "[kv_field][cn6]" }
                 rename => { "[cn6Label]" => "[kv_field][cn6Label]" }
                 rename => { "[cnt]" => "[kv_field][cnt]" }
                 rename => { "[cs1]" => "[kv_field][cs1]" }
                 rename => { "[cs1Label]" => "[kv_field][cs1Label]" }
                 rename => { "[cs2]" => "[kv_field][cs2]" }
                 rename => { "[cs2Label]" => "[kv_field][cs2Label]" }
                 rename => { "[cs3]" => "[kv_field][cs3]" }
                 rename => { "[cs3Label]" => "[kv_field][cs3Label]" }
                 rename => { "[cs4]" => "[kv_field][cs4]" }
                 rename => { "[cs4Label]" => "[kv_field][cs4Label]" }
                 rename => { "[cs5]" => "[kv_field][cs5]" }
                 rename => { "[cs5Label]" => "[kv_field][cs5Label]" }
                 rename => { "[cs6]" => "[kv_field][cs6]" }
                 rename => { "[cs6Label]" => "[kv_field][cs6Label]" }
                 rename => { "[destinationServiceName]" => "[kv_field][destinationServiceName]" }
                 rename => { "[destinationTranslatedAddress]" => "[kv_field][destinationTranslatedAddress]" }
                 rename => { "[destinationTranslatedPort]" => "[kv_field][destinationTranslatedPort]" }
                 rename => { "[deviceExternalId]" => "[kv_field][deviceExternalId]" }
                 rename => { "[deviceInboundInterface]" => "[kv_field][deviceInboundInterface]" }
                 rename => { "[deviceOutboundInterface]" => "[kv_field][deviceOutboundInterface]" }
                 rename => { "[dpt]" => "[kv_field][dpt]" }
                 rename => { "[dst]" => "[kv_field][dst]" }
                 rename => { "[duid]" => "[kv_field][duid]" }
                 rename => { "[duser]" => "[kv_field][duser]" }
                 rename => { "[dvchost]" => "[kv_field][dvchost]" }
                 rename => { "[end]" => "[kv_field][end]" }
                 rename => { "[externalId]" => "[kv_field][externalId]" }
                 rename => { "[fileHash]" => "[kv_field][fileHash]" }
                 rename => { "[fileId]" => "[kv_field][fileId]" }
                 rename => { "[filePath]" => "[kv_field][filePath]" }
                 rename => { "[fileType]" => "[kv_field][fileType]" }
                 rename => { "[flags]" => "[kv_field][flags]" }
                 rename => { "[flexNumber1]" => "[kv_field][flexNumber1]" }
                 rename => { "[flexNumber1Label]" => "[kv_field][flexNumber1Label]" }
                 rename => { "[flexNumber2]" => "[kv_field][flexNumber2]" }
                 rename => { "[flexNumber2Label]" => "[kv_field][flexNumber2Label]" }
                 rename => { "[flexString1]" => "[kv_field][flexString1]" }
                 rename => { "[flexString1Label]" => "[kv_field][flexString1Label]" }
                 rename => { "[flexString2]" => "[kv_field][flexString2]" }
                 rename => { "[flexString2Label]" => "[kv_field][flexString2Label]" }
                 rename => { "[fname]" => "[kv_field][fname]" }
                 rename => { "[in]" => "[kv_field][in]" }
                 rename => { "[msg]" => "[kv_field][msg]" }
                 rename => { "[oldFileId]" => "[kv_field][oldFileId]" }
                 rename => { "[out]" => "[kv_field][out]" }
                 rename => { "[PanASServiceDiff]" => "[kv_field][PanASServiceDiff]" }
                 rename => { "[PanASServiceType]" => "[kv_field][PanASServiceType]" }
                 rename => { "[PanContainerName]" => "[kv_field][PanContainerName]" }
                 rename => { "[PanDomainEDL]" => "[kv_field][PanDomainEDL]" }
                 rename => { "[PanDstDAG]" => "[kv_field][PanDstDAG]" }
                 rename => { "[PanDstDeviceCat]" => "[kv_field][PanDstDeviceCat]" }
                 rename => { "[PanDstDeviceModel]" => "[kv_field][PanDstDeviceModel]" }
                 rename => { "[PanDstDeviceOS]" => "[kv_field][PanDstDeviceOS]" }
                 rename => { "[PanDstDeviceOSv]" => "[kv_field][PanDstDeviceOSv]" }
                 rename => { "[PanDstDeviceProf]" => "[kv_field][PanDstDeviceProf]" }
                 rename => { "[PanDstDeviceVendor]" => "[kv_field][PanDstDeviceVendor]" }
                 rename => { "[PanDstEDL]" => "[kv_field][PanDstEDL]" }
                 rename => { "[PanDstHostname]" => "[kv_field][PanDstHostname]" }
                 rename => { "[PanDstMac]" => "[kv_field][PanDstMac]" }
                 rename => { "[PanDynamicUsrgrp]" => "[kv_field][PanDynamicUsrgrp]" }
                 rename => { "[PanEPSerial]" => "[kv_field][PanEPSerial]" }
                 rename => { "[PanGPHostID]" => "[kv_field][PanGPHostID]" }
                 rename => { "[PanHASessionOwner]" => "[kv_field][PanHASessionOwner]" }
                 rename => { "[PanJustification]" => "[kv_field][PanJustification]" }
                 rename => { "[PanLinkChange]" => "[kv_field][PanLinkChange]" }
                 rename => { "[PanLinkDetail]" => "[kv_field][PanLinkDetail]" }
                 rename => { "[PanOSActionFlags]" => "[kv_field][PanOSActionFlags]" }
                 rename => { "[PanOSAPName]" => "[kv_field][PanOSAPName]" }
                 rename => { "[PanOSAreaCode]" => "[kv_field][PanOSAreaCode]" }
                 rename => { "[PanOSAssocID]" => "[kv_field][PanOSAssocID]" }
                 rename => { "[PanOSAttemptedGateways]" => "[kv_field][PanOSAttemptedGateways]" }
                 rename => { "[PanOSAuthMethod]" => "[kv_field][PanOSAuthMethod]" }
                 rename => { "[PanOSCellID]" => "[kv_field][PanOSCellID]" }
                 rename => { "[PanOSCertificateFlags]" => "[kv_field][PanOSCertificateFlags]" }
                 rename => { "[PanOSCertificateSerial]" => "[kv_field][PanOSCertificateSerial]" }
                 rename => { "[PanOSCertificateSize]" => "[kv_field][PanOSCertificateSize]" }
                 rename => { "[PanOSCertificateVersion]" => "[kv_field][PanOSCertificateVersion]" }
                 rename => { "[PanOSChainStatus]" => "[kv_field][PanOSChainStatus]" }
                 rename => { "[PanOSChunkType]" => "[kv_field][PanOSChunkType]" }
                 rename => { "[PanOSClientToFirewall]" => "[kv_field][PanOSClientToFirewall]" }
                 rename => { "[PanOSCommonName]" => "[kv_field][PanOSCommonName]" }
                 rename => { "[PanOSCommonNameLength]" => "[kv_field][PanOSCommonNameLength]" }
                 rename => { "[PanOSConfigVersion]" => "[kv_field][PanOSConfigVersion]" }
                 rename => { "[PanOSConnectionError]" => "[kv_field][PanOSConnectionError]" }
                 rename => { "[PanOSConnectionErrorID]" => "[kv_field][PanOSConnectionErrorID]" }
                 rename => { "[PanOSConnectionMethod]" => "[kv_field][PanOSConnectionMethod]" }
                 rename => { "[PanOSContainerID]" => "[kv_field][PanOSContainerID]" }
                 rename => { "[PanOSContainerName]" => "[kv_field][PanOSContainerName]" }
                 rename => { "[PanOSContainerNameSpace]" => "[kv_field][PanOSContainerNameSpace]" }
                 rename => { "[PanOSContentVer]" => "[kv_field][PanOSContentVer]" }
                 rename => { "[PanOSCountOfRepeats]" => "[kv_field][PanOSCountOfRepeats]" }
                 rename => { "[PanOSDataSourceName]" => "[kv_field][PanOSDataSourceName]" }
                 rename => { "[PanOSDataSourceSubType]" => "[kv_field][PanOSDataSourceSubType]" }
                 rename => { "[PanOSDataSourceType]" => "[kv_field][PanOSDataSourceType]" }
                 rename => { "[PanOSDesc]" => "[kv_field][PanOSDesc]" }
                 rename => { "[PanOSDescription]" => "[kv_field][PanOSDescription]" }
                 rename => { "[PanOSDestinationDeviceCategory]" => "[kv_field][PanOSDestinationDeviceCategory]" }
                 rename => { "[PanOSDestinationDeviceHost]" => "[kv_field][PanOSDestinationDeviceHost]" }
                 rename => { "[PanOSDestinationDeviceMac]" => "[kv_field][PanOSDestinationDeviceMac]" }
                 rename => { "[PanOSDestinationDeviceModel]" => "[kv_field][PanOSDestinationDeviceModel]" }
                 rename => { "[PanOSDestinationDeviceOSFamily]" => "[kv_field][PanOSDestinationDeviceOSFamily]" }
                 rename => { "[PanOSDestinationDeviceOSVersion]" => "[kv_field][PanOSDestinationDeviceOSVersion]" }
                 rename => { "[PanOSDestinationDeviceProfile]" => "[kv_field][PanOSDestinationDeviceProfile]" }
                 rename => { "[PanOSDestinationDeviceVendor]" => "[kv_field][PanOSDestinationDeviceVendor]" }
                 rename => { "[PanOSDestinationDynamicAddressGroup]" => "[kv_field][PanOSDestinationDynamicAddressGroup]" }
                 rename => { "[PanOSDestinationEDL]" => "[kv_field][PanOSDestinationEDL]" }
                 rename => { "[PanOSDestinationUUID]" => "[kv_field][PanOSDestinationUUID]" }
                 rename => { "[PanOSDeviceSN]" => "[kv_field][PanOSDeviceSN]" }
                 rename => { "[PanOSDGl1]" => "[kv_field][PanOSDGl1]" }
                 rename => { "[PanOSDGl2]" => "[kv_field][PanOSDGl2]" }
                 rename => { "[PanOSDGl3]" => "[kv_field][PanOSDGl3]" }
                 rename => { "[PanOSDGl4]" => "[kv_field][PanOSDGl4]" }
                 rename => { "[PanOSDiameterApp]" => "[kv_field][PanOSDiameterApp]" }
                 rename => { "[PanOSDiameterAVPCode]" => "[kv_field][PanOSDiameterAVPCode]" }
                 rename => { "[PanOSDiameterCmdCode]" => "[kv_field][PanOSDiameterCmdCode]" }
                 rename => { "[PanOSDstUUID]" => "[kv_field][PanOSDstUUID]" }
                 rename => { "[PanOSEllipticCurve]" => "[kv_field][PanOSEllipticCurve]" }
                 rename => { "[PanOSEndpointDeviceName]" => "[kv_field][PanOSEndpointDeviceName]" }
                 rename => { "[PanOSEndpointMac]" => "[kv_field][PanOSEndpointMac]" }
                 rename => { "[PanOSEndpointOSType]" => "[kv_field][PanOSEndpointOSType]" }
                 rename => { "[PanOSEndpointOSVersion]" => "[kv_field][PanOSEndpointOSVersion]" }
                 rename => { "[PanOSEndpointSerialNumber]" => "[kv_field][PanOSEndpointSerialNumber]" }
                 rename => { "[PanOSEndUserIP]" => "[kv_field][PanOSEndUserIP]" }
                 rename => { "[PanOSErrorIndex]" => "[kv_field][PanOSErrorIndex]" }
                 rename => { "[PanOSErrorMessage]" => "[kv_field][PanOSErrorMessage]" }
                 rename => { "[PanOSEventID]" => "[kv_field][PanOSEventID]" }
                 rename => { "[PanOSEventStatus]" => "[kv_field][PanOSEventStatus]" }
                 rename => { "[PanOSFingerprint]" => "[kv_field][PanOSFingerprint]" }
                 rename => { "[PanOSFirewallToServer]" => "[kv_field][PanOSFirewallToServer]" }
                 rename => { "[PanOSFWDeviceGroup]" => "[kv_field][PanOSFWDeviceGroup]" }
                 rename => { "[PanOSGateway]" => "[kv_field][PanOSGateway]" }
                 rename => { "[PanOSGatewayPriority]" => "[kv_field][PanOSGatewayPriority]" }
                 rename => { "[PanOSGatewaySelectionType]" => "[kv_field][PanOSGatewaySelectionType]" }
                 rename => { "[PanOSGlobalProtectClientVersion]" => "[kv_field][PanOSGlobalProtectClientVersion]" }
                 rename => { "[PanOSGPGatewayLocation]" => "[kv_field][PanOSGPGatewayLocation]" }
                 rename => { "[PanOSGTPCause]" => "[kv_field][PanOSGTPCause]" }
                 rename => { "[PanOSGTPEventCode]" => "[kv_field][PanOSGTPEventCode]" }
                 rename => { "[PanOSGTPEventType]" => "[kv_field][PanOSGTPEventType]" }
                 rename => { "[PanOSGTPInterface]" => "[kv_field][PanOSGTPInterface]" }
                 rename => { "[PanOSGTPMsgType]" => "[kv_field][PanOSGTPMsgType]" }
                 rename => { "[PanOSHostID]" => "[kv_field][PanOSHostID]" }
                 rename => { "[PanOSHTTP2Con]" => "[kv_field][PanOSHTTP2Con]" }
                 rename => { "[PanOSHTTPHeader]" => "[kv_field][PanOSHTTPHeader]" }
                 rename => { "[PanOSHTTPUserAgent]" => "[kv_field][PanOSHTTPUserAgent]" }
                 rename => { "[PanOSIssuerCommonName]" => "[kv_field][PanOSIssuerCommonName]" }
                 rename => { "[PanOSIssuerNameLength]" => "[kv_field][PanOSIssuerNameLength]" }
                 rename => { "[PanOSLoginDuration]" => "[kv_field][PanOSLoginDuration]" }
                 rename => { "[PanOSLogTimeStamp]" => "[kv_field][PanOSLogTimeStamp]" }
                 rename => { "[PanOSLogTypeSeqNo]" => "[kv_field][PanOSLogTypeSeqNo]" }
                 rename => { "[PanOSMonitorTag]" => "[kv_field][PanOSMonitorTag]" }
                 rename => { "[PanOSMSISDN]" => "[kv_field][PanOSMSISDN]" }
                 rename => { "[PanOSOpCode]" => "[kv_field][PanOSOpCode]" }
                 rename => { "[PanOSPacketsReceived]" => "[kv_field][PanOSPacketsReceived]" }
                 rename => { "[PanOSPacketsSent]" => "[kv_field][PanOSPacketsSent]" }
                 rename => { "[PanOSParentSessionID]" => "[kv_field][PanOSParentSessionID]" }
                 rename => { "[PanOSParentStartTime]" => "[kv_field][PanOSParentStartTime]" }
                 rename => { "[PanOSPayloadProtID]" => "[kv_field][PanOSPayloadProtID]" }
                 rename => { "[PanOSPcapID]" => "[kv_field][PanOSPcapID]" }
                 rename => { "[PanOSPolicyAuditComment]" => "[kv_field][PanOSPolicyAuditComment]" }
                 rename => { "[PanOSPolicyName]" => "[kv_field][PanOSPolicyName]" }
                 rename => { "[PanOSPortal]" => "[kv_field][PanOSPortal]" }
                 rename => { "[PanOSPPID]" => "[kv_field][PanOSPPID]" }
                 rename => { "[PanOSPrivateIPv4]" => "[kv_field][PanOSPrivateIPv4]" }
                 rename => { "[PanOSPrivateIPv6]" => "[kv_field][PanOSPrivateIPv6]" }
                 rename => { "[PanOSProxyType]" => "[kv_field][PanOSProxyType]" }
                 rename => { "[PanOSPublicIPv4]" => "[kv_field][PanOSPublicIPv4]" }
                 rename => { "[PanOSPublicIPv6]" => "[kv_field][PanOSPublicIPv6]" }
                 rename => { "[PanOSQuarantineReason]" => "[kv_field][PanOSQuarantineReason]" }
                 rename => { "[PanOSRadioTech]" => "[kv_field][PanOSRadioTech]" }
                 rename => { "[PanOSReferer]" => "[kv_field][PanOSReferer]" }
                 rename => { "[PanOSRmtUserID]" => "[kv_field][PanOSRmtUserID]" }
                 rename => { "[PanOSRmtUserIP]" => "[kv_field][PanOSRmtUserIP]" }
                 rename => { "[PanOSRootCNLength]" => "[kv_field][PanOSRootCNLength]" }
                 rename => { "[PanOSRootCommonName]" => "[kv_field][PanOSRootCommonName]" }
                 rename => { "[PanOSRootStatus]" => "[kv_field][PanOSRootStatus]" }
                 rename => { "[PanOSRuleUUID]" => "[kv_field][PanOSRuleUUID]" }
                 rename => { "[PanOSSCCPCallingGT]" => "[kv_field][PanOSSCCPCallingGT]" }
                 rename => { "[PanOSSCCPCallingPartySSN]" => "[kv_field][PanOSSCCPCallingPartySSN]" }
                 rename => { "[PanOSSCTPAssocEndReason]" => "[kv_field][PanOSSCTPAssocEndReason]" }
                 rename => { "[PanOSSCTPAssocID]" => "[kv_field][PanOSSCTPAssocID]" }
                 rename => { "[PanOSSCTPCauseCode]" => "[kv_field][PanOSSCTPCauseCode]" }
                 rename => { "[PanOSSCTPChunkRcv]" => "[kv_field][PanOSSCTPChunkRcv]" }
                 rename => { "[PanOSSCTPChunks]" => "[kv_field][PanOSSCTPChunks]" }
                 rename => { "[PanOSSCTPChunkSent]" => "[kv_field][PanOSSCTPChunkSent]" }
                 rename => { "[PanOSSCTPChunksRcv]" => "[kv_field][PanOSSCTPChunksRcv]" }
                 rename => { "[PanOSSCTPFilter]" => "[kv_field][PanOSSCTPFilter]" }
                 rename => { "[PanOSSCTPStreamID]" => "[kv_field][PanOSSCTPStreamID]" }
                 rename => { "[PanOSSCTPVerTag1]" => "[kv_field][PanOSSCTPVerTag1]" }
                 rename => { "[PanOSSCTPVerTag2]" => "[kv_field][PanOSSCTPVerTag2]" }
                 rename => { "[PanOSSequenceNo]" => "[kv_field][PanOSSequenceNo]" }
                 rename => { "[PanOSServerNameIndication]" => "[kv_field][PanOSServerNameIndication]" }
                 rename => { "[PanOSServingCntryMCC]" => "[kv_field][PanOSServingCntryMCC]" }
                 rename => { "[PanOSServingNetMNC]" => "[kv_field][PanOSServingNetMNC]" }
                 rename => { "[PanOSSeverity]" => "[kv_field][PanOSSeverity]" }
                 rename => { "[PanOSSNILength]" => "[kv_field][PanOSSNILength]" }
                 rename => { "[PanOSSourceDeviceCategory]" => "[kv_field][PanOSSourceDeviceCategory]" }
                 rename => { "[PanOSSourceDeviceHost]" => "[kv_field][PanOSSourceDeviceHost]" }
                 rename => { "[PanOSSourceDeviceMac]" => "[kv_field][PanOSSourceDeviceMac]" }
                 rename => { "[PanOSSourceDeviceModel]" => "[kv_field][PanOSSourceDeviceModel]" }
                 rename => { "[PanOSSourceDeviceOSFamily]" => "[kv_field][PanOSSourceDeviceOSFamily]" }
                 rename => { "[PanOSSourceDeviceOSVersion]" => "[kv_field][PanOSSourceDeviceOSVersion]" }
                 rename => { "[PanOSSourceDeviceProfile]" => "[kv_field][PanOSSourceDeviceProfile]" }
                 rename => { "[PanOSSourceDeviceVendor]" => "[kv_field][PanOSSourceDeviceVendor]" }
                 rename => { "[PanOSSourceDynamicAddressGroup]" => "[kv_field][PanOSSourceDynamicAddressGroup]" }
                 rename => { "[PanOSSourceEDL]" => "[kv_field][PanOSSourceEDL]" }
                 rename => { "[PanOSSourceHostname]" => "[kv_field][PanOSSourceHostname]" }
                 rename => { "[PanOSSourceMac]" => "[kv_field][PanOSSourceMac]" }
                 rename => { "[PanOSSourceRegion]" => "[kv_field][PanOSSourceRegion]" }
                 rename => { "[PanOSSourceUserName]" => "[kv_field][PanOSSourceUserName]" }
                 rename => { "[PanOSSourceUUID]" => "[kv_field][PanOSSourceUUID]" }
                 rename => { "[PanOSSrcUUID]" => "[kv_field][PanOSSrcUUID]" }
                 rename => { "[PanOSSSLResponseTime]" => "[kv_field][PanOSSSLResponseTime]" }
                 rename => { "[PanOSStage]" => "[kv_field][PanOSStage]" }
                 rename => { "[PanOSTagName]" => "[kv_field][PanOSTagName]" }
                 rename => { "[PanOSThreatCategory]" => "[kv_field][PanOSThreatCategory]" }
                 rename => { "[PanOSTimeGeneratedHighResolution]" => "[kv_field][PanOSTimeGeneratedHighResolution]" }
                 rename => { "[PanOSTimeNotAfter]" => "[kv_field][PanOSTimeNotAfter]" }
                 rename => { "[PanOSTimeNotBefore]" => "[kv_field][PanOSTimeNotBefore]" }
                 rename => { "[PanOSTimeout]" => "[kv_field][PanOSTimeout]" }
                 rename => { "[PanOSTimeReceivedManagementPlane]" => "[kv_field][PanOSTimeReceivedManagementPlane]" }
                 rename => { "[PanOSTLSAuth]" => "[kv_field][PanOSTLSAuth]" }
                 rename => { "[PanOSTLSEncryptionAlgorithm]" => "[kv_field][PanOSTLSEncryptionAlgorithm]" }
                 rename => { "[PanOSTLSKeyExchange]" => "[kv_field][PanOSTLSKeyExchange]" }
                 rename => { "[PanOSTLSVersion]" => "[kv_field][PanOSTLSVersion]" }
                 rename => { "[PanOSTrafficOriginRegion]" => "[kv_field][PanOSTrafficOriginRegion]" }
                 rename => { "[PanOSTrafficSessionID]" => "[kv_field][PanOSTrafficSessionID]" }
                 rename => { "[PanOSTunneInspectionRule]" => "[kv_field][PanOSTunneInspectionRule]" }
                 rename => { "[PanOSTunnel]" => "[kv_field][PanOSTunnel]" }
                 rename => { "[PanOSTunnelEndptID1]" => "[kv_field][PanOSTunnelEndptID1]" }
                 rename => { "[PanOSTunnelEndptID2]" => "[kv_field][PanOSTunnelEndptID2]" }
                 rename => { "[PanOSTunnelFragment]" => "[kv_field][PanOSTunnelFragment]" }
                 rename => { "[PanOSTunnelID]" => "[kv_field][PanOSTunnelID]" }
                 rename => { "[PanOSTunnelInspectionRule]" => "[kv_field][PanOSTunnelInspectionRule]" }
                 rename => { "[PanOSTunnelType]" => "[kv_field][PanOSTunnelType]" }
                 rename => { "[PanOSUGFlags]" => "[kv_field][PanOSUGFlags]" }
                 rename => { "[PanOSURLCatList]" => "[kv_field][PanOSURLCatList]" }
                 rename => { "[PanOSUserBySource]" => "[kv_field][PanOSUserBySource]" }
                 rename => { "[PanOSVirtualSystem]" => "[kv_field][PanOSVirtualSystem]" }
                 rename => { "[PanOSVsysName]" => "[kv_field][PanOSVsysName]" }
                 rename => { "[PanOSXForwarderfor]" => "[kv_field][PanOSXForwarderfor]" }
                 rename => { "[PanPartialHash]" => "[kv_field][PanPartialHash]" }
                 rename => { "[PanPODName]" => "[kv_field][PanPODName]" }
                 rename => { "[PanPODNamespace]" => "[kv_field][PanPODNamespace]" }
                 rename => { "[PanPolicyID]" => "[kv_field][PanPolicyID]" }
                 rename => { "[PanReasonFilteringAction]" => "[kv_field][PanReasonFilteringAction]" }
                 rename => { "[PanSDWANCluster]" => "[kv_field][PanSDWANCluster]" }
                 rename => { "[PanSDWANClustype]" => "[kv_field][PanSDWANClustype]" }
                 rename => { "[PanSDWANDevice]" => "[kv_field][PanSDWANDevice]" }
                 rename => { "[PanSDWANSite]" => "[kv_field][PanSDWANSite]" }
                 rename => { "[PanSrcDAG]" => "[kv_field][PanSrcDAG]" }
                 rename => { "[PanSrcDeviceCat]" => "[kv_field][PanSrcDeviceCat]" }
                 rename => { "[PanSrcDeviceModel]" => "[kv_field][PanSrcDeviceModel]" }
                 rename => { "[PanSrcDeviceOS]" => "[kv_field][PanSrcDeviceOS]" }
                 rename => { "[PanSrcDeviceOSv]" => "[kv_field][PanSrcDeviceOSv]" }
                 rename => { "[PanSrcDeviceProf]" => "[kv_field][PanSrcDeviceProf]" }
                 rename => { "[PanSrcDeviceVendor]" => "[kv_field][PanSrcDeviceVendor]" }
                 rename => { "[PanSrcEDL]" => "[kv_field][PanSrcEDL]" }
                 rename => { "[PanSrcHostname]" => "[kv_field][PanSrcHostname]" }
                 rename => { "[PanSrcMac]" => "[kv_field][PanSrcMac]" }
                 rename => { "[PanTimeHighRes]" => "[kv_field][PanTimeHighRes]" }
                 rename => { "[PanXFFIP]" => "[kv_field][PanXFFIP]" }
                 rename => { "[proto]" => "[kv_field][proto]" }
                 rename => { "[reason]" => "[kv_field][reason]" }
                 rename => { "[request]" => "[kv_field][request]" }
                 rename => { "[requestClientApplication]" => "[kv_field][requestClientApplication]" }
                 rename => { "[requestContext]" => "[kv_field][requestContext]" }
                 rename => { "[requestMethod]" => "[kv_field][requestMethod]" }
                 rename => { "[rt]" => "[kv_field][rt]" }
                 rename => { "[shost]" => "[kv_field][shost]" }
                 rename => { "[sourceTranslatedAddress]" => "[kv_field][sourceTranslatedAddress]" }
                 rename => { "[sourceTranslatedPort]" => "[kv_field][sourceTranslatedPort]" }
                 rename => { "[spt]" => "[kv_field][spt]" }
                 rename => { "[src]" => "[kv_field][src]" }
                 rename => { "[start]" => "[kv_field][start]" }
                 rename => { "[suid]" => "[kv_field][suid]" }
                 rename => { "[suser]" => "[kv_field][suser]" }
                }
              }
#......................................................................#
#Add standard fields to the tree structure
#......................................................................#
        mutate {
          #Rename the fileds
          rename => { "[embDeviceVendor]" => "[kv_field][embDeviceVendor]" }
          rename => { "[embDeviceProduct]" => "[kv_field][embDeviceProduct]" }
          rename => { "[format_version]" => "[kv_field][format_version]" }
          rename => { "[format_type]" => "[kv_field][format_type]" }
          rename => { "[embDeviceVersion]" => "[kv_field][embDeviceVersion]" }
          rename => { "[priority]" => "[kv_field][priority]" }
          rename => { "[severity]" => "[kv_field][severity]" }
          rename => { "[pa_sender_sw_version]" => "[kv_field][pa_sender_sw_version]" }
          rename => { "[pa_subtype]" => "[kv_field][pa_subtype]" }
          rename => { "[pa_type]" => "[kv_field][pa_type]" }
          rename => { "[pa_threatid]" => "[kv_field][pa_threatid]" }
          rename => { "[pa_result]" => "[kv_field][pa_result]" }
          rename => { "[pa_matchtype]" => "[kv_field][pa_matchtype]" }
          rename => { "[pa_category]" => "[kv_field][pa_category]" }
          rename => { "[message]" => "[kv_field][message]" }
        }

#......................................................................#
#Correlation standard fields
#......................................................................#
    #src can be in multiple fields
    if [kv_field][src] {
        mutate {
          rename => { "[kv_field][src]" => "[kv_field][src_ip]" }
        }
    }

        mutate {
          rename => { "[kv_field][dst]" => "[kv_field][dest_ip]" }
          rename => { "[kv_field][spt]" => "[kv_field][src_port]" }
          rename => { "[kv_field][dpt]" => "[kv_field][dest_port]" }
        }
#......................................................................#
#Generate UTM ACTION field when connection established
#......................................................................#
    #Traffic
    if ([kv_field][pa_type] and [kv_field][pa_subtype])
    and ( [kv_field][pa_type] == "TRAFFIC" and ([kv_field][pa_subtype]=~/(START|END|start|end)/)  )
    and ([kv_field][act] and [kv_field][act] =~/^(allow|reset-client|reset-server|reset-both)$/ ) {
      mutate {
        add_field => { "[logx][utm][action]" => "Success" }
      }
    #URL Threat
    } else if ( [kv_field][pa_type] and [kv_field][pa_subtype])
    and ( [kv_field][pa_type] == "THREAT" and [kv_field][pa_subtype] =~/(URL|url)/
    and ([kv_field][act] and [kv_field][act] =~/^(allow|alert|continue|override)$/ ) ){
      mutate {
        add_field => { "[logx][utm][action]" => "Success" }
      }
    #DATA Threat
    } else if ( [kv_field][pa_type] and [kv_field][pa_subtype])
    and ( [kv_field][pa_type] == "THREAT" and [kv_field][pa_subtype] =~/(DATA|data|DLP|dlp|dlp-non-file|FILE|file)/
    and ([kv_field][act] and [kv_field][act] =~/^(allow|alert|continue)$/ ) ){
      mutate {
        add_field => { "[logx][utm][action]" => "Success" }
      }
    #Wildfire, is a third party analyzer, not define a connection
    } else if ( [kv_field][pa_type] and [kv_field][pa_subtype])
    and ( [kv_field][pa_type] == "THREAT" and [kv_field][pa_subtype] =~/(WILDFIRE|wildfire)/ ){

    #General Threat
    } else if ( [kv_field][pa_type] and [kv_field][pa_threatid]) and ( [kv_field][pa_type] == "THREAT" )
    and ([kv_field][act] and [kv_field][act] =~/^(alert|allow|reset-client|reset-server|reset-both|continue)$/ ){
      mutate {
        add_field => { "[logx][utm][action]" => "Success" }
      }
    #Config
    } else if ( [kv_field][pa_type] ) and ( [kv_field][pa_type] =~/(CONFIG|config)/ ) {
      mutate {
        add_field => { "[logx][utm][action]" => "Success" }
      }
    #System, not enough info
    } else if ( [kv_field][pa_type] ) and ( [kv_field][pa_type] =~/(SYSTEM|system)/ ) {
    #HIP-MATCH, are rules, dont seems to be a connection
    } else if ( [kv_field][pa_type] ) and ( [kv_field][pa_type] =~/(HIP-MATCH|hip-match)/ ) {
    #Authentication, not enough info needs validation of msg values
    } else if ( [kv_field][pa_type]) and ( [kv_field][pa_type]  =~/(AUTHENTICATION|authentication)/ )
    and ([kv_field][msg] and [kv_field][msg] =~/(Allow|allow|Success|success)/ ){
      mutate {
        add_field => { "[logx][utm][action]" => "Success" }
      }
    #USERID, enables you to identify all users on your network, are known users so is always a connection
    } else if ( [kv_field][pa_type]) and ( [kv_field][pa_type]  =~/(USERID|userid)/ ) {
      mutate {
        add_field => { "[logx][utm][action]" => "Success" }
      }
    #IPTAG, tag mapped to the source IP address, seems to be a proccess after established connection
    } else if ( [kv_field][pa_type]) and ( [kv_field][pa_type]  =~/(IPTAG|iptag)/ ) {
      mutate {
        add_field => { "[logx][utm][action]" => "Success" }
      }
    #Tunnel
    } else if ( [kv_field][pa_type] and [kv_field][pa_subtype])
    and ( [kv_field][pa_type]  =~/(START|start|END|end)/ )
    and ( [kv_field][pa_subtype]  =~/(START|start|END|end)/ ) {
      mutate {
        add_field => { "[logx][utm][action]" => "Success" }
      }
    #CORRELATION, seems to be logs for kind of threats detected
    } else if ( [kv_field][pa_type])
    and ( [kv_field][pa_type]  =~/(CORRELATION|correlation)/ ) {

    #GTP
    } else if ( [kv_field][pa_type] and [kv_field][pa_subtype])
    and ( [kv_field][pa_type]  =~/(GTP|gtp)/ )
    and ( [kv_field][pa_subtype]  =~/(START|start|END|end)/ )
    and ([kv_field][act] and [kv_field][act] =~/^(allow|Allow)$/ ) {
      mutate {
        add_field => { "[logx][utm][action]" => "Success" }
      }
    #SCTP
    } else if ( [kv_field][pa_type] )
    and ( [kv_field][pa_type]  =~/(SCTP|sctp)/ )
    and ([kv_field][act] and [kv_field][act] =~/^(allow|Allow)$/ ) {
      mutate {
        add_field => { "[logx][utm][action]" => "Success" }
      }
    #GLOBALPROTECT
    } else if ( [kv_field][pa_type] ) and ( [kv_field][pa_type]  =~/(GLOBALPROTECT|globalprotect)/ )
    and (([kv_field][PanOSLoginDuration] and [kv_field][PanOSLoginDuration] != "0") or ![kv_field][PanOSLoginDuration]) {
      mutate {
        add_field => { "[logx][utm][action]" => "Success" }
      }
    #Decryption
    } else if ( [kv_field][pa_type] ) and ( [kv_field][pa_type]  =~/(DECRYPTION|decryption)/ )
    and ([kv_field][act] and [kv_field][act] =~/^(allow|reset-client|reset-server|reset-both)$/ ) {
      mutate {
        add_field => { "[logx][utm][action]" => "Success" }
      }
    }

#......................................................................#
#Set null the fields with de X0X value (default string for null), and replace simple and double quotation
#also generate logx tree structure dynamically
          if [kv_field] {
            ruby {
                code => ''
                    event.get("[kv_field]").each do |k, v|
                          if (v == "X0X")
                            event.set("[logx][paloalto_fw][#{k}]",nil)
                          elsif (k=~/(\W)$/)
                              event.remove(k)
                          elsif !(v.kind_of?(Array))
                              new_v = v.to_s.gsub(/\"/, "")
                              new_v = new_v.gsub(/\''/, "")
                              event.set("[logx][paloalto_fw][#{k}]",new_v)
                          else
                              event.set("[logx][paloalto_fw][#{k}]",v)
                          end
                       end
                    ''
            }
          }
#......................................................................#
   #Finally, remove unnecessary fields
   mutate {
      remove_field => ["@version","path","tags","type","syslog_version","kv_field","FUTURE_USE",
      "not_defined","cef_or_leef_msg_all","cef_or_leef_msg","syslog_date_host","irrelevant","init_msg","csv_msg_all"]
   }
  }
 }
   #Also, remove unwanted fields if the message not match with conditions
   mutate {
      remove_field => ["original_log_message","headers"]
   }
}
'
WHERE id=1509;
----------------------------------------------------------------------------------------------------------------------------------------
-- SONICWALL  --
----------------------------------------------------------------------------------------------------------------------------------------
UPDATE utm_logstash_filter
SET filter_version='2.0.1',logstash_filter='filter {

# SonicWall filter version 2.0.1
# Support Syslog CEF format
# Based in https://www.sonicwall.com/techdocs/pdf/sonicos-6-5-4-log-events-reference-guide.pdf
# and https://docs.elastic.co/integrations/sonicwall_firewall
# and https://www.ossec.net/docs/log_samples/firewalls/sonicwall.html
# and https://docs.trellix.com/es-ES/bundle/enterprise-security-manager-data-sources-configuration-reference-guide/page/GUID-AE747DCA-9D60-4148-A97D-B6D3AE581AD7.html
# and http://docs.ospatrol.com/en/latest/log_samples/firewalls/sonicwall.html
# and https://documentation.cysiv.com/articles/#!data-source-onboarding-device-configuration-reference/sonicwall-reference-information-and-cim-field-mapping

    split {
     field => "message"
     terminator => "<utm-log-separator>"
    }

    #Looking for datasource generated by an agent and parse original message
    if [message]=~/\[utm_stack_agent_ds=(.+)\]-(.+)/ {
      grok {
        match => {
          "message" => [ "\[utm_stack_agent_ds=%{DATA:dataSource}\]-%{GREEDYDATA:original_log_message}" ]
        }
      }
    }
    if [original_log_message] {
      mutate {
        update => { "message" => "%{[original_log_message]}" }
      }
    }

    if ![dataType] {
        #First,search to define the entry point contain id= and sn= and fw= and time= or CEF
        if (([message] and [message] =~/\bid=\b(.+)\bsn=\b/ and [message] =~/\bfw=\b/ and [message] =~/\btime=/)
        or ("CEF:" in [message] and [message] =~/\|(\w+)?(\s)?SonicWall(\s)?(\w+)?\|/)){
          #......................................................................#
          #Generating dataSource field required by CorrelationRulesEngine
          #Checks if exists, if not evaluate to the host variable
          if (![dataSource]){
            mutate {
              add_field => { "dataSource" => "%{host}" }
            }
          }
          #......................................................................#
          #Generating dataType field required by CorrelationRulesEngine
          mutate {
            add_field => { "dataType" => "firewall-sonicwall" }
          }
          #Checking if the log is in syslog format
          if ([message] =~/\bid=\b(.+)\bsn=\b/ and [message] =~/\bfw=\b/ and [message] =~/\btime=/){
            #......................................................................#
            #Using grok to parse header of the message
            grok {
            match => {
              "message" => [
                 "(%{INT:not_defined})?(\s)?(<%{NUMBER:priority}>)?(%{INT:syslog_version})?(%{DATA:syslog_date_host})?id=%{WORD:id} %{GREEDYDATA:msg_all}"
              ]
            }
          }
          }
          #Checking if the log is in CEF format
          if ("CEF:" in [message] and [message] =~/\|(\w+)?(\s)?SonicWall(\s)?(\w+)?\|/){
            #......................................................................#
            #Using grok to parse header of the message
            grok {
              match => {
                "message" => [
                  "(%{INT:not_defined})?(\s)?(<%{NUMBER:priority}>)?(%{INT:syslog_version})?(\s)?%{GREEDYDATA:syslog_date_host} CEF:(\s)?%{INT:cef_version}%{GREEDYDATA:cef_msg_all}"
                ]
              }
            }
            #......................................................................#
            #Checking that the cef_msg_all field exists and using grok to parse cef_msg_all
            if ([cef_msg_all]){
              grok {
                match => {
                  "cef_msg_all" => [
                    "\|%{DATA:dvc_vendor}\|%{DATA:dvc_product}\|%{DATA:dvc_version}\|%{INT:event_id}\|%{DATA:event_name}\|%{INT:severity}\|%{GREEDYDATA:msg_all}"
                  ]
                }
              }
            }
          }
          #......................................................................#
          #Checking that the msg_all field exists
          if ([msg_all]){
            #......................................................................#
            #Using grok to parse common msg_all field components in syslog format and CEF format
            grok { match => { "msg_all" => [" app=%{NUMBER:num_app_id} %{WORD:}="," app=%{GREEDYDATA:num_app_id}"] } }
            grok { match => { "msg_all" => [" appcat=%{DATA:app_cat} %{WORD:}="," appcat=%{GREEDYDATA:app_cat}"] } }
            grok { match => { "msg_all" => [" appid=%{DATA:appid} %{WORD:}="," appid=%{GREEDYDATA:appid}"] } }
            grok { match => { "msg_all" => [" arg=%{DATA:arg} %{WORD:}="," arg=%{GREEDYDATA:arg}"] } }
            grok { match => { "msg_all" => [" bcastRx=%{DATA:bcast_pkt_received} %{WORD:}="," bcastRx=%{GREEDYDATA:bcast_pkt_received}"] } }
            grok { match => { "msg_all" => [" bcastTx=%{DATA:bcast_pkt_transm} %{WORD:}="," bcastTx=%{GREEDYDATA:bcast_pkt_transm}"] } }
            grok { match => { "msg_all" => [" bid=%{NUMBER:blade_id} %{WORD:}="," bid=%{GREEDYDATA:blade_id}"] } }
            grok { match => { "msg_all" => [" bytesRx=%{DATA:bytes_rcvd} %{WORD:}="," bytesRx=%{GREEDYDATA:bytes_rcvd}"] } }
            grok { match => { "msg_all" => [" bytesTx=%{DATA:bytes_sent} %{WORD:}="," bytesTx=%{GREEDYDATA:bytes_sent}"] } }
            grok { match => { "msg_all" => [" [Cc]ategory=(\")?%{DATA:cfs_category}(\")? %{WORD:}="," [Cc]ategory=%{GREEDYDATA:cfs_category}"] } }
            grok { match => { "msg_all" => [" dpi=%{NUMBER:deep_packet_inspection} %{WORD:}="," dpi=%{GREEDYDATA:deep_packet_inspection}"] } }
            grok { match => { "msg_all" => [" dst=%{DATA:dst} %{WORD:}="," dst=%{GREEDYDATA:dst}"] } }
            grok { match => { "msg_all" => [" dstname=%{DATA:request} %{WORD:}="," dstname=%{GREEDYDATA:request}"] } }
            grok { match => { "msg_all" => [" gcat=%{DATA:group_cat} %{WORD:}="," gcat=%{GREEDYDATA:group_cat}"] } }
            grok { match => { "msg_all" => [" goodRxBytes=%{DATA:good_bytes_received} %{WORD:}="," goodRxBytes=%{GREEDYDATA:good_bytes_received}"] } }
            grok { match => { "msg_all" => [" goodTxBytes=%{DATA:good_bytes_transm} %{WORD:}="," goodTxBytes=%{GREEDYDATA:good_bytes_transm}"] } }
            grok { match => { "msg_all" => [" if=%{DATA:interface_statistics_reported} %{WORD:}="," if=%{GREEDYDATA:interface_statistics_reported}"] } }
            grok { match => { "msg_all" => [" ipscat=(\")?%{DATA:ipscat}(\")? %{WORD:}="," ipscat=%{GREEDYDATA:ipscat}"] } }
            grok { match => { "msg_all" => [" ipspri=%{NUMBER:ipspri} %{WORD:}="," ipspri=%{GREEDYDATA:ipspri}"] } }
            grok { match => { "msg_all" => [" msg=(\")?%{DATA:msg}(\")? %{WORD:}="," msg=%{GREEDYDATA:msg}"] } }
            grok { match => { "msg_all" => [" mgmtip=%{DATA:mgmt_source_ip} %{WORD:}="," mgmtip=%{GREEDYDATA:mgmt_source_ip}"] } }
            grok { match => { "msg_all" => [" proto=%{DATA:protocol} %{WORD:}="," proto=%{GREEDYDATA:protocol}"] } }
            grok { match => { "msg_all" => [" radio=%{DATA:radio} %{WORD:}="," radio=%{GREEDYDATA:radio}"] } }
            grok { match => { "msg_all" => [" referer=(\")?%{DATA:referer}(\")? %{WORD:}="," referer=%{GREEDYDATA:referer}"] } }
            grok { match => { "msg_all" => [" sid=%{NUMBER:sid} %{WORD:}="," sid=%{GREEDYDATA:sid}"] } }
            grok { match => { "msg_all" => [" spycat=%{DATA:anti_spyware_cat} %{WORD:}="," spycat=%{GREEDYDATA:anti_spyware_cat}"] } }
            grok { match => { "msg_all" => [" spypri=%{DATA:anti_spyware_pri} %{WORD:}="," spypri=%{GREEDYDATA:anti_spyware_pri}"] } }
            grok { match => { "msg_all" => [" src=%{DATA:src} %{WORD:}="," src=%{GREEDYDATA:src}"] } }
            grok { match => { "msg_all" => [" station=%{DATA:station} %{WORD:}="," station=%{GREEDYDATA:station}"] } }
            grok { match => { "msg_all" => [" ucastRx=%{DATA:ucast_pkt_received} %{WORD:}="," ucastRx=%{GREEDYDATA:ucast_pkt_received}"] } }
            grok { match => { "msg_all" => [" ucastTx=%{DATA:ucast_pkt_transm} %{WORD:}="," ucastTx=%{GREEDYDATA:ucast_pkt_transm}"] } }

            #......................................................................#
            #Using grok to parse msg_all components from syslog format only
            grok { match => { "msg_all" => [" af_polid=%{NUMBER:af_policy_id} %{WORD:}="," af_polid=%{GREEDYDATA:af_policy_id}"] } }
            grok { match => { "msg_all" => [" af_policy=%{DATA:af_policy} %{WORD:}="," af_policy=%{GREEDYDATA:af_policy}"] } }
            grok { match => { "msg_all" => [" af_type=%{DATA:af_policy_type} %{WORD:}="," af_type=%{GREEDYDATA:af_policy_type}"] } }
            grok { match => { "msg_all" => [" af_service=%{WORD:af_policy_service} %{WORD:}="," af_service=%{GREEDYDATA:af_policy_service}"] } }
            grok { match => { "msg_all" => [" af_action=%{DATA:af_policy_action} %{WORD:}="," af_action=%{GREEDYDATA:af_policy_action}"] } }
            grok { match => { "msg_all" => [" af_object=%{DATA:af_policy_object} %{WORD:}="," af_object=%{GREEDYDATA:af_policy_object}"] } }
            grok { match => { "msg_all" => [" ai=%{NUMBER:active_interface} %{WORD:}="," ai=%{GREEDYDATA:active_interface}"] } }
            grok { match => { "msg_all" => [" appName=%{DATA:app_name} %{WORD:}="," appName=%{GREEDYDATA:app_name}"] } }
            grok { match => { "msg_all" => [" c=%{NUMBER:msg_category} %{WORD:}="," c=%{GREEDYDATA:msg_category}"] } }
            grok { match => { "msg_all" => [" catid=%{DATA:rule_category} %{WORD:}="," catid=%{GREEDYDATA:rule_category}"] } }
            grok { match => { "msg_all" => [" cdur=%{NUMBER:conn_duration} %{WORD:}="," cdur=%{GREEDYDATA:conn_duration}"] } }
            grok { match => { "msg_all" => [" change=%{DATA:change} %{WORD:}="," change=%{GREEDYDATA:change}"] } }
            grok { match => { "msg_all" => [" code=%{NUMBER:code} %{WORD:}="," code=%{GREEDYDATA:code}"] } }
            grok { match => { "msg_all" => [" conns=%{NUMBER:conns} %{WORD:}="," conns=%{GREEDYDATA:conns}"] } }
            grok { match => { "msg_all" => [" contentObject=%{DATA:contentObject} %{WORD:}="," contentObject=%{GREEDYDATA:contentObject}"] } }
            grok { match => { "msg_all" => [" icmpCode=%{DATA:icmpCode} %{WORD:}="," icmpCode=%{GREEDYDATA:icmpCode}"] } }
            grok { match => { "msg_all" => [" dstMac=%{DATA:dstMac} %{WORD:}="," dstMac=%{GREEDYDATA:dstMac}"] } }
            grok { match => { "msg_all" => [" dstV6=%{DATA:dstV6} %{WORD:}="," dstV6=%{GREEDYDATA:dstV6}"] } }
            grok { match => { "msg_all" => [" dstZone=%{DATA:dstZone} %{WORD:}="," dstZone=%{GREEDYDATA:dstZone}"] } }
            grok { match => { "msg_all" => [" dur=%{NUMBER:session_dur} %{WORD:}="," dur=%{GREEDYDATA:session_dur}"] } }
            grok { match => { "msg_all" => [" dyn=%{DATA:fw_status_report} %{WORD:}="," dyn=%{GREEDYDATA:fw_status_report}"] } }
            grok { match => { "msg_all" => [" f=%{NUMBER:flow_type} %{WORD:}="," f=%{GREEDYDATA:flow_type}"] } }
            grok { match => { "msg_all" => [" fileid=(\")?%{DATA:fileid}(\")? %{WORD:}="," fileid=%{GREEDYDATA:fileid}"] } }
            grok { match => { "msg_all" => [" filetxstatus=%{DATA:filetxstatus} %{WORD:}="," filetxstatus=%{GREEDYDATA:filetxstatus}"] } }
            grok { match => { "msg_all" => [" fw=%{DATA:fw_wan} %{WORD:}="," fw=%{GREEDYDATA:fw_wan}"] } }
            grok { match => { "msg_all" => [" fw_action=(\")?%{DATA:fw_action}(\")? %{WORD:}="," fw_action=%{GREEDYDATA:fw_action}"] } }
            grok { match => { "msg_all" => [" fwlan=%{DATA:fw_lan} %{WORD:}="," fwlan=%{GREEDYDATA:fw_lan}"] } }
            grok { match => { "msg_all" => [" i=%{NUMBER:interval} %{WORD:}="," i=%{GREEDYDATA:interval}"] } }
            grok { match => { "msg_all" => [" lic=%{NUMBER:lic} %{WORD:}="," lic=%{GREEDYDATA:lic}"] } }
            grok { match => { "msg_all" => [" m=%{NUMBER:event_id} %{WORD:}="," m=%{GREEDYDATA:event_id}"] } }
            grok { match => { "msg_all" => [" mailFrom=%{DATA:mailFrom} %{WORD:}="," mailFrom=%{GREEDYDATA:mailFrom}"] } }
            grok { match => { "msg_all" => [" n=%{NUMBER:msg_count} %{WORD:}="," n=%{GREEDYDATA:msg_count}"] } }
            grok { match => { "msg_all" => [" natDst=%{DATA:nat_dst} %{WORD:}="," natDst=%{GREEDYDATA:nat_dst}"] } }
            grok { match => { "msg_all" => [" natDstV6=%{DATA:nat_dst_v6} %{WORD:}="," natDstV6=%{GREEDYDATA:nat_dst_v6}"] } }
            grok { match => { "msg_all" => [" natSrc=%{DATA:nat_src} %{WORD:}="," natSrc=%{GREEDYDATA:nat_src}"] } }
            grok { match => { "msg_all" => [" natSrcV6=%{DATA:nat_src_v6} %{WORD:}="," natSrcV6=%{GREEDYDATA:nat_src_v6}"] } }
            grok { match => { "msg_all" => [" note=(\")?%{DATA:note}(\")? %{WORD:}="," note=%{GREEDYDATA:note}"] } }
            grok { match => { "msg_all" => [" npcs=%{DATA:npcs} %{WORD:}="," npcs=%{GREEDYDATA:npcs}"] } }
            grok { match => { "msg_all" => [" op=%{NUMBER:request_method} %{WORD:}="," op=%{GREEDYDATA:request_method}"] } }
            grok { match => { "msg_all" => [" packetdatId=%{DATA:packetdatId} %{WORD:}="," packetdatId=%{GREEDYDATA:packetdatId}"] } }
            grok { match => { "msg_all" => [" packetdatNum=%{DATA:packetdatNum} %{WORD:}="," packetdatNum=%{GREEDYDATA:packetdatNum}"] } }
            grok { match => { "msg_all" => [" packetdatEnc=%{DATA:packetdatEnc} %{WORD:}="," packetdatEnc=%{GREEDYDATA:packetdatEnc}"] } }
            grok { match => { "msg_all" => [" pri=%{NUMBER:severity} %{WORD:}="," pri=%{GREEDYDATA:severity}"] } }
            grok { match => { "msg_all" => [" pt=%{DATA:pt} %{WORD:}="," pt=%{GREEDYDATA:pt}"] } }
            grok { match => { "msg_all" => [" rcptTo=%{DATA:email_recipient} %{WORD:}="," rcptTo=%{GREEDYDATA:email_recipient}"] } }
            grok { match => { "msg_all" => [" rcvd=%{NUMBER:bytes_rcvd} %{WORD:}="," rcvd=%{GREEDYDATA:bytes_rcvd}"] } }
            grok { match => { "msg_all" => [" result=%{NUMBER:result_code} %{WORD:}="," result=%{GREEDYDATA:result_code}"] } }
            grok { match => { "msg_all" => [" rpkt=%{NUMBER:pkt_received} %{WORD:}="," rpkt=%{GREEDYDATA:pkt_received}"] } }
            grok { match => { "msg_all" => [" rule=(\")?%{DATA:rule}(\")? %{WORD:}="," rule=%{GREEDYDATA:rule}"] } }
            grok { match => { "msg_all" => [" sent=%{NUMBER:bytes_sent} %{WORD:}="," sent=%{GREEDYDATA:bytes_sent}"] } }
            grok { match => { "msg_all" => [" sess=%{DATA:sess} %{WORD:}="," sess=%{GREEDYDATA:sess}"] } }
            grok { match => { "msg_all" => ["(\s)?sn=%{WORD:serial_num} %{WORD:}=","(\s)?sn=%{GREEDYDATA:serial_num}"] } }
            grok { match => { "msg_all" => [" spkt=%{NUMBER:pkt_sent} %{WORD:}="," spkt=%{GREEDYDATA:pkt_sent}"] } }
            grok { match => { "msg_all" => [" srcMac=%{DATA:srcMac} %{WORD:}="," srcMac=%{GREEDYDATA:srcMac}"] } }
            grok { match => { "msg_all" => [" srcZone=%{DATA:srcZone} %{WORD:}="," srcZone=%{GREEDYDATA:srcZone}"] } }
            grok { match => { "msg_all" => [" time=(\")?%{DATA:time}(\")? %{WORD:}="," time=%{GREEDYDATA:time}"] } }
            grok { match => { "msg_all" => [" type=%{DATA:icmp_type} %{WORD:}="," type=%{GREEDYDATA:icmp_type}"] } }
            grok { match => { "msg_all" => [" unsynched=%{DATA:unsynched} %{WORD:}="," unsynched=%{GREEDYDATA:unsynched}"] } }
            grok { match => { "msg_all" => [" usestandbysa=%{NUMBER:usestandbysa} %{WORD:}="," usestandbysa=%{GREEDYDATA:usestandbysa}"] } }
            grok { match => { "msg_all" => [" (usr|user)=(\")?%{DATA:user}(\")? %{WORD:}="," (usr|user)=%{GREEDYDATA:user}"] } }
            grok { match => { "msg_all" => [" vpnpolicy=(\")?%{DATA:vpnpolicy}(\")? %{WORD:}="," vpnpolicy=%{GREEDYDATA:vpnpolicy}"] } }
            grok { match => { "msg_all" => [" vpnpolicyDst=(\")?%{DATA:vpnpolicyDst}(\")? %{WORD:}="," vpnpolicyDst=%{GREEDYDATA:vpnpolicyDst}"] } }

            #......................................................................#
            #Using grok to parse msg_all components from CEF format only
            grok { match => { "msg_all" => ["(\s)?cat=%{NUMBER:msg_category} %{WORD:}="] } }
            grok { match => { "msg_all" => [" cn3Label=%{NUMBER:conn_duration} %{WORD:}="," cn3Label=%{GREEDYDATA:conn_duration}"] } }
            grok { match => { "msg_all" => [" SWGMSchangeUrl=%{DATA:change} %{WORD:}="," SWGMSchangeUrl=%{GREEDYDATA:change}"] } }
            grok { match => { "msg_all" => [" reason=%{NUMBER:code} %{WORD:}="," reason=%{GREEDYDATA:code}"] } }
            grok { match => { "msg_all" => [" cn2=%{DATA:icmpCode} %{WORD:}="," cn2=%{GREEDYDATA:icmpCode}"] } }
            grok { match => { "msg_all" => [" cs4=%{DATA:interface_statistics} %{WORD:}="," cs4=%{GREEDYDATA:interface_statistics}"] } }
            grok { match => { "msg_all" => [" deviceOutboundInterface=%{DATA:device_outbound_interface} %{WORD:}="," deviceOutboundInterface=%{GREEDYDATA:device_outbound_interface}"] } }
            grok { match => { "msg_all" => [" deviceInboundInterface=%{DATA:device_inbound_interface} %{WORD:}="," deviceInboundInterface=%{GREEDYDATA:device_inbound_interface}"] } }
            grok { match => { "msg_all" => [" dpt=%{NUMBER:dest_port} %{WORD:}="," dpt=%{GREEDYDATA:dest_port}"] } }
            grok { match => { "msg_all" => [" dnpt=%{NUMBER:nat_dest_port} %{WORD:}="," dnpt=%{GREEDYDATA:nat_dest_port}"] } }
            grok { match => { "msg_all" => [" dmac=%{DATA:dstMac} %{WORD:}="," dmac=%{GREEDYDATA:dstMac}"] } }
            grok { match => { "msg_all" => [" request=%{DATA:request} %{WORD:}="," request=%{GREEDYDATA:request}"] } }
            grok { match => { "msg_all" => [" cs4Label=%{DATA:dstZone} %{WORD:}="," cs4Label=%{GREEDYDATA:dstZone}"] } }
            grok { match => { "msg_all" => [" cs6label=%{NUMBER:session_dur} %{WORD:}="," cs6label=%{GREEDYDATA:session_dur}"] } }
            grok { match => { "msg_all" => [" flowType=%{NUMBER:flow_type} %{WORD:}="," flowType=%{GREEDYDATA:flow_type}"] } }
            grok { match => { "msg_all" => [" cnt=%{NUMBER:msg_count} %{WORD:}="," cnt=%{GREEDYDATA:msg_count}"] } }
            grok { match => { "msg_all" => [" cs2Label=%{DATA:nat_dst} %{WORD:}="," cs2Label=%{GREEDYDATA:nat_dst}"] } }
            grok { match => { "msg_all" => [" cs1Label=%{DATA:nat_src} %{WORD:}="," cs1Label=%{GREEDYDATA:nat_src}"] } }
            grok { match => { "msg_all" => [" cs6=(\")?%{DATA:note}(\")? %{WORD:}="," cs6=%{GREEDYDATA:note}"] } }
            grok { match => { "msg_all" => [" cs5=%{DATA:npcs} %{WORD:}="," cs5=%{GREEDYDATA:npcs}"] } }
            grok { match => { "msg_all" => [" requestMethod=%{NUMBER:request_method} %{WORD:}="," requestMethod=%{GREEDYDATA:request_method}"] } }
            grok { match => { "msg_all" => [" in=%{NUMBER:bytes_rcvd} %{WORD:}="," in=%{GREEDYDATA:bytes_rcvd}"] } }
            grok { match => { "msg_all" => [" outcome=%{NUMBER:result_code} %{WORD:}="," outcome=%{GREEDYDATA:result_code}"] } }
            grok { match => { "msg_all" => [" cn1Label=%{NUMBER:pkt_received} %{WORD:}="," cn1Label=%{GREEDYDATA:pkt_received}"] } }
            grok { match => { "msg_all" => [" cs1=(\")?%{DATA:rule}(\")? %{WORD:}="," cs1=%{GREEDYDATA:rule}"] } }
            grok { match => { "msg_all" => [" out=%{NUMBER:bytes_sent} %{WORD:}="," out=%{GREEDYDATA:bytes_sent}"] } }
            grok { match => { "msg_all" => [" cs5Label=%{DATA:sess} %{WORD:}="," cs5Label=%{GREEDYDATA:sess}"] } }
            grok { match => { "msg_all" => [" cn2Label=%{NUMBER:pkt_sent} %{WORD:}="," cn2Label=%{GREEDYDATA:pkt_sent}"] } }
            grok { match => { "msg_all" => [" spt=%{NUMBER:src_port} %{WORD:}="," spt=%{GREEDYDATA:src_port}"] } }
            grok { match => { "msg_all" => [" snpt=%{NUMBER:nat_src_port} %{WORD:}="," snpt=%{GREEDYDATA:nat_src_port}"] } }
            grok { match => { "msg_all" => [" smac=%{DATA:srcMac} %{WORD:}="," smac=%{GREEDYDATA:srcMac}"] } }
            grok { match => { "msg_all" => [" cs3Label=%{DATA:srcZone} %{WORD:}="," cs3Label=%{GREEDYDATA:srcZone}"] } }
            grok { match => { "msg_all" => [" cn1=%{DATA:icmp_type} %{WORD:}="," cn1=%{GREEDYDATA:icmp_type}"] } }
            grok { match => { "msg_all" => [" susr=(\")?%{DATA:user}(\")? %{WORD:}="," susr=%{GREEDYDATA:user}"] } }
            grok { match => { "msg_all" => [" cs2=%{DATA:vpnpolicy} %{WORD:}="," cs2=%{GREEDYDATA:vpnpolicy}"] } }
            grok { match => { "msg_all" => [" cs3=%{DATA:vpnpolicyDst} %{WORD:}="," cs3=%{GREEDYDATA:vpnpolicyDst}"] } }

          }
          #Checking if the src field exists and using grok to parse it
          if ([src]){
            grok {
              match => { "src" => "%{IPORHOST:src_ip}(:%{NUMBER:src_port})?(:%{WORD:device_inbound_interface})?(:%{GREEDYDATA:src_resolved_name})?"}
            }
          }
          #Checking if the dst field exists and using grok to parse it
          if ([dst]){
            grok {
              match => { "dst" => "%{IPORHOST:dest_ip}(:%{NUMBER:dest_port})?(:%{WORD:device_outbound_interface})?(:%{GREEDYDATA:dest_resolved_name})?"}
            }
          }
          #Checking if the protocol field exists and using grok to parse it
          if ([protocol]){
            grok {
              match => { "protocol" => "%{WORD:proto}(/%{GREEDYDATA:service})?"}
            }
          }
          #......................................................................#
          #Generate UTM ACTION field when connection established
          #......................................................................#
          if ([event_id] and (
              ( ([event_id]=="16") or ([event_id]=="24") or ([event_id]=="29") or ([event_id]=="31") or ([event_id]=="36") or ([event_id]=="43") or ([event_id]=="53") or ([event_id]=="58") or ([event_id]=="87") or ([event_id]=="88")
                  or ([event_id]=="89") or ([event_id]=="98") or ([event_id]=="131") or ([event_id]=="132") or ([event_id]=="168") or ([event_id]=="199") or ([event_id]=="205") or ([event_id]=="207") or ([event_id]=="215")
                  or ([event_id]=="235") or ([event_id]=="236") or ([event_id]=="237") or ([event_id]=="238") or ([event_id]=="261") or ([event_id]=="262") or ([event_id]=="263") or ([event_id]=="264") or ([event_id]=="265")
                  or ([event_id]=="273") or ([event_id]=="286") or ([event_id]=="288") or ([event_id]=="289") or ([event_id]=="307") or ([event_id]=="318") or ([event_id]=="319") or ([event_id]=="327") or ([event_id]=="335")
                  or ([event_id]=="346") or ([event_id]=="351") or ([event_id]=="352") or ([event_id]=="353") or ([event_id]=="354") or ([event_id]=="355") or ([event_id]=="356") or ([event_id]=="357") or ([event_id]=="358")
                  or ([event_id]=="372") or ([event_id]=="373") or ([event_id]=="375") or ([event_id]=="378") or ([event_id]=="379") or ([event_id]=="381") or ([event_id]=="388") or ([event_id]=="389") or ([event_id]=="390")
                  or ([event_id]=="391") or ([event_id]=="392") or ([event_id]=="393") or ([event_id]=="394") or ([event_id]=="395") or ([event_id]=="396") or ([event_id]=="429") or ([event_id]=="430") or ([event_id]=="431")
                  or ([event_id]=="432") or ([event_id]=="433") or ([event_id]=="445") or ([event_id]=="429") or ([event_id]=="535") or ([event_id]=="537") or ([event_id]=="542") or ([event_id]=="622") or ([event_id]=="623")
                  or ([event_id]=="634") or ([event_id]=="636") or ([event_id]=="646") or ([event_id]=="647") or ([event_id]=="651") or ([event_id]=="666") or ([event_id]=="712") or ([event_id]=="713") or ([event_id]=="734")
                  or ([event_id]=="735") or ([event_id]=="760") or ([event_id]=="797") or ([event_id]=="798") or ([event_id]=="820") or ([event_id]=="859") or ([event_id]=="891") or ([event_id]=="892") or ([event_id]=="1008")
                  or ([event_id]=="1027") or ([event_id]=="1028") or ([event_id]=="1080") or ([event_id]=="1087") or ([event_id]=="1091") or ([event_id]=="1092") or ([event_id]=="1112") or ([event_id]=="1114") or ([event_id]=="1116")
                  or ([event_id]=="1124") or ([event_id]=="1153") or ([event_id]=="1179") or ([event_id]=="1183") or ([event_id]=="1187") or ([event_id]=="1267") or ([event_id]=="1424") or ([event_id]=="1445") or ([event_id]=="1452")
                  or ([event_id]=="1490") or ([event_id]=="1491") or ([event_id]=="1498") or ([event_id]=="1500") or ([event_id]=="1502") or ([event_id]=="1503") or ([event_id]=="1504") or ([event_id]=="1534"))
              or ((([event_id]!="16") and ([event_id]!="24") and ([event_id]!="29") and ([event_id]!="31") and ([event_id]!="36") and ([event_id]!="43") and ([event_id]!="53") and ([event_id]!="58") and ([event_id]!="87") and ([event_id]!="88")
                  and ([event_id]!="89") and ([event_id]!="98") and ([event_id]!="131") and ([event_id]!="132") and ([event_id]!="168") and ([event_id]!="199") and ([event_id]!="205") and ([event_id]!="207") and ([event_id]!="215")
                  and ([event_id]!="235") and ([event_id]!="236") and ([event_id]!="237") and ([event_id]!="238") and ([event_id]!="261") and ([event_id]!="262") and ([event_id]!="263") and ([event_id]!="264") and ([event_id]!="265")
                  and ([event_id]!="273") and ([event_id]!="286") and ([event_id]!="288") and ([event_id]!="289") and ([event_id]!="307") and ([event_id]!="318") and ([event_id]!="319") and ([event_id]!="327") and ([event_id]!="335")
                  and ([event_id]!="346") and ([event_id]!="351") and ([event_id]!="352") and ([event_id]!="353") and ([event_id]!="354") and ([event_id]!="355") and ([event_id]!="356") and ([event_id]!="357") and ([event_id]!="358")
                  and ([event_id]!="372") and ([event_id]!="373") and ([event_id]!="375") and ([event_id]!="378") and ([event_id]!="379") and ([event_id]!="381") and ([event_id]!="388") and ([event_id]!="389") and ([event_id]!="390")
                  and ([event_id]!="391") and ([event_id]!="392") and ([event_id]!="393") and ([event_id]!="394") and ([event_id]!="395") and ([event_id]!="396") and ([event_id]!="429") and ([event_id]!="430") and ([event_id]!="431")
                  and ([event_id]!="432") and ([event_id]!="433") and ([event_id]!="445") and ([event_id]!="429") and ([event_id]!="535") and ([event_id]!="537") and ([event_id]!="542") and ([event_id]!="622") and ([event_id]!="623")
                  and ([event_id]!="634") and ([event_id]!="636") and ([event_id]!="646") and ([event_id]!="647") and ([event_id]!="651") and ([event_id]!="666") and ([event_id]!="712") and ([event_id]!="713") and ([event_id]!="734")
                  and ([event_id]!="735") and ([event_id]!="760") and ([event_id]!="797") and ([event_id]!="798") and ([event_id]!="820") and ([event_id]!="859") and ([event_id]!="891") and ([event_id]!="892") and ([event_id]!="1008")
                  and ([event_id]!="1027") and ([event_id]!="1028") and ([event_id]!="1080") and ([event_id]!="1087") and ([event_id]!="1091") and ([event_id]!="1092") and ([event_id]!="1112") and ([event_id]!="1114") and ([event_id]!="1116")
                  and ([event_id]!="1124") and ([event_id]!="1153") and ([event_id]!="1179") and ([event_id]!="1183") and ([event_id]!="1187") and ([event_id]!="1267") and ([event_id]!="1424") and ([event_id]!="1445") and ([event_id]!="1452")
                  and ([event_id]!="1490") and ([event_id]!="1491") and ([event_id]!="1498") and ([event_id]!="1500") and ([event_id]!="1502") and ([event_id]!="1503") and ([event_id]!="1504") and ([event_id]!="1534"))
                  and ([src_ip]) and ([dest_ip]) and ([bytes_rcvd]) and ([bytes_rcvd]!="0") and (([bytes_sent] and ([bytes_sent]!="0")) or ([proto] and ([proto]=="ftp")))))){
                    mutate {
                      add_field => { "[logx][utm][action]" => "Success" }
                    }
                  }

          mutate {
            #Rename fields used by correlation engine
            rename => { "[src_ip]" => "[logx][sonicwall][src_ip]" }
            rename => { "[src_port]" => "[logx][sonicwall][src_port]" }
            rename => { "[dest_ip]" => "[logx][sonicwall][dest_ip]" }
            rename => { "[dest_port]" => "[logx][sonicwall][dest_port]" }
            rename => { "[proto]" => "[logx][sonicwall][proto]" }

            #Rename all others fields
            rename => { "[device_inbound_interface]" => "[logx][sonicwall][device_inbound_interface]" }
            rename => { "[device_outbound_interface]" => "[logx][sonicwall][device_outbound_interface]" }
            rename => { "[src_resolved_name]" => "[logx][sonicwall][src_resolved_name]" }
            rename => { "[dest_resolved_name]" => "[logx][sonicwall][dest_resolved_name]" }
            rename => { "[af_policy_id]" => "[logx][sonicwall][af_policy_id]" }
            rename => { "[af_policy]" => "[logx][sonicwall][af_policy]" }
            rename => { "[af_policy_type]" => "[logx][sonicwall][af_policy_type]" }
            rename => { "[=%{WORD:af_policy_service]" => "[logx][sonicwall][af_policy_service]" }
            rename => { "[af_policy_action]" => "[logx][sonicwall][af_policy_action]" }
            rename => { "[af_policy_object]" => "[logx][sonicwall][af_policy_object]" }
            rename => { "[active_interface]" => "[logx][sonicwall][active_interface]" }
            rename => { "[num_app_id]" => "[logx][sonicwall][num_app_id]" }
            rename => { "[app_cat]" => "[logx][sonicwall][app_cat]" }
            rename => { "[appid]" => "[logx][sonicwall][appid]" }
            rename => { "[app_name]" => "[logx][sonicwall][app_name]" }
            rename => { "[arg]" => "[logx][sonicwall][arg]" }
            rename => { "[bcast_pkt_received]" => "[logx][sonicwall][bcast_pkt_received]" }
            rename => { "[bcast_pkt_transm]" => "[logx][sonicwall][bcast_pkt_transm]" }
            rename => { "[blade_id]" => "[logx][sonicwall][blade_id]" }
            rename => { "[msg_category]" => "[logx][sonicwall][msg_category]" }
            rename => { "[cfs_category]" => "[logx][sonicwall][cfs_category]" }
            rename => { "[rule_category]" => "[logx][sonicwall][rule_category]" }
            rename => { "[conn_duration]" => "[logx][sonicwall][conn_duration]" }
            rename => { "[change]" => "[logx][sonicwall][change]" }
            rename => { "[code]" => "[logx][sonicwall][code]" }
            rename => { "[conns]" => "[logx][sonicwall][conns]" }
            rename => { "[contentObject]" => "[logx][sonicwall][contentObject]" }
            rename => { "[deep_packet_inspection]" => "[logx][sonicwall][deep_packet_inspection]" }
            rename => { "[dstMac]" => "[logx][sonicwall][destMac]" }
            rename => { "[dstV6]" => "[logx][sonicwall][destV6]" }
            rename => { "[dstname]" => "[logx][sonicwall][destname]" }
            rename => { "[dstZone]" => "[logx][sonicwall][destZone]" }
            rename => { "[session_dur]" => "[logx][sonicwall][session_dur]" }
            rename => { "[fw_status_report]" => "[logx][sonicwall][fw_status_report]" }
            rename => { "[flow_type]" => "[logx][sonicwall][flow_type]" }
            rename => { "[fileid]" => "[logx][sonicwall][fileid]" }
            rename => { "[filetxstatus]" => "[logx][sonicwall][filetxstatus]" }
            rename => { "[fw_wan]" => "[logx][sonicwall][fw_wan]" }
            rename => { "[fw_action]" => "[logx][sonicwall][fw_action]" }
            rename => { "[fw_lan]" => "[logx][sonicwall][fw_lan]" }
            rename => { "[group_cat]" => "[logx][sonicwall][group_cat]" }
            rename => { "[good_bytes_received]" => "[logx][sonicwall][good_bytes_received]" }
            rename => { "[good_bytes_transm]" => "[logx][sonicwall][good_bytes_transm]" }
            rename => { "[id]" => "[logx][sonicwall][id]"}
            rename => { "[interval]" => "[logx][sonicwall][interval]" }
            rename => { "[icmpCode]" => "[logx][sonicwall][icmpCode]" }
            rename => { "[interface_statistics_reported]" => "[logx][sonicwall][interface_statistics_reported]" }
            rename => { "[ipscat]" => "[logx][sonicwall][ipscat]" }
            rename => { "[ipspri]" => "[logx][sonicwall][ipspri]" }
            rename => { "[lic]" => "[logx][sonicwall][lic]" }
            rename => { "[event_id]" => "[logx][sonicwall][event_id]" }
            rename => { "[mailFrom]" => "[logx][sonicwall][mailFrom]" }
            rename => { "[msg]" => "[logx][sonicwall][msg]" }
            rename => { "[mgmt_source_ip]" => "[logx][sonicwall][mgmt_source_ip]" }
            rename => { "[msg_count]" => "[logx][sonicwall][msg_count]" }
            rename => { "[nat_dst]" => "[logx][sonicwall][nat_dest]" }
            rename => { "[nat_dst_v6]" => "[logx][sonicwall][nat_dest_v6]" }
            rename => { "[nat_src]" => "[logx][sonicwall][nat_src]" }
            rename => { "[nat_src_v6]" => "[logx][sonicwall][nat_src_v6]" }
            rename => { "[note]" => "[logx][sonicwall][note]" }
            rename => { "[npcs]" => "[logx][sonicwall][npcs]" }
            rename => { "[request_method]" => "[logx][sonicwall][request_method]" }
            rename => { "[packetdatId]" => "[logx][sonicwall][packetdatId]" }
            rename => { "[packetdatNum]" => "[logx][sonicwall][packetdatNum]" }
            rename => { "[packetdatEnc]" => "[logx][sonicwall][packetdatEnc]" }
            rename => { "[severity]" => "[logx][sonicwall][severity]" }
            rename => { "[pt]" => "[logx][sonicwall][pt]" }
            rename => { "[email_recipient]" => "[logx][sonicwall][email_recipient]" }
            rename => { "[radio]" => "[logx][sonicwall][radio]" }
            rename => { "[bytes_rcvd]" => "[logx][sonicwall][bytes_rcvd]" }
            rename => { "[referer]" => "[logx][sonicwall][referer]" }
            rename => { "[result_code]" => "[logx][sonicwall][result_code]" }
            rename => { "[pkt_received]" => "[logx][sonicwall][pkt_received]" }
            rename => { "[rule]" => "[logx][sonicwall][rule]" }
            rename => { "[bytes_sent]" => "[logx][sonicwall][bytes_sent]" }
            rename => { "[service]" => "[logx][sonicwall][service]" }
            rename => { "[sess]" => "[logx][sonicwall][sess]" }
            rename => { "[sid]" => "[logx][sonicwall][sid]" }
            rename => { "[serial_num]" => "[logx][sonicwall][serial_num]" }
            rename => { "[pkt_sent]" => "[logx][sonicwall][pkt_sent]" }
            rename => { "[priority]" => "[logx][sonicwall][priority]" }
            rename => { "[anti_spyware_cat]" => "[logx][sonicwall][anti_spyware_cat]" }
            rename => { "[anti_spyware_pri]" => "[logx][sonicwall][anti_spyware_pri]" }
            rename => { "[srcMac]" => "[logx][sonicwall][srcMac]" }
            rename => { "[srcZone]" => "[logx][sonicwall][srcZone]" }
            rename => { "[station]" => "[logx][sonicwall][station]" }
            rename => { "[time]" => "[logx][sonicwall][time]" }
            rename => { "[icmp_type]" => "[logx][sonicwall][icmp_type]" }
            rename => { "[ucast_pkt_received]" => "[logx][sonicwall][ucast_pkt_received]" }
            rename => { "[ucast_pkt_transm]" => "[logx][sonicwall][ucast_pkt_transm]" }
            rename => { "[unsynched]" => "[logx][sonicwall][unsynched]" }
            rename => { "[usestandbysa]" => "[logx][sonicwall][usestandbysa]" }
            rename => { "[user]" => "[logx][sonicwall][user]" }
            rename => { "[vpnpolicy]" => "[logx][sonicwall][vpnpolicy]" }
            rename => { "[vpnpolicyDst]" => "[logx][sonicwall][vpnpolicyDst]" }

            #Rename fields of CEF format only
            rename => { "[nat_dest_port]" => "[logx][sonicwall][nat_dest_port]" }
            rename => { "[request]" => "[logx][sonicwall][request]" }
            rename => { "[nat_src_port]" => "[logx][sonicwall][nat_src_port]" }
            rename => { "[cef_version]" => "[logx][sonicwall][cef_version]" }
            rename => { "[dvc_vendor]" => "[logx][sonicwall][dvc_vendor]" }
            rename => { "[dvc_product]" => "[logx][sonicwall][dvc_product]" }
            rename => { "[dvc_version]" => "[logx][sonicwall][dvc_version]" }
            rename => { "[event_name]" => "[logx][sonicwall][event_name]" }
          }

          #Finally, remove unnecessary fields
          mutate {
              remove_field => ["@version","path","tags","type","syslog_version",
              "not_defined","src","protocol","dst","msg_all","cef_msg_all","syslog_date_host"]
          }
        }
 }
   #Also, remove unwanted fields if the message not match with conditions
   mutate {
      remove_field => ["original_log_message","headers"]
   }
}
'
WHERE id=1511;
----------------------------------------------------------------------------------------------------------------------------------------
-- SOPHOS XG FIREWALL --
----------------------------------------------------------------------------------------------------------------------------------------
UPDATE utm_logstash_filter
SET filter_version='2.0.1',logstash_filter='filter {

# Sophos filter version 2.0.1
# Based on https://docs.sophos.com/nsg/sophos-firewall/17.5/PDF/SFOS_Logfile_Guide_17.5.pdf
# and https://docs.sophos.com/nsg/sophos-firewall/18.5/PDF/SF%20syslog%20guide%2018.5.pdf
# and https://docs.sophos.com/nsg/sophos-firewall/17.5/Help/en-us/webhelp/onlinehelp/nsg/sfos/concepts/LogMessages.html
# and https://docs.sophos.com/nsg/sophos-firewall/17.5/Help/en-us/webhelp/onlinehelp/nsg/concepts/LogIDStructure.html
# and https://docs.sophos.com/nsg/sophos-firewall/17.5/Help/en-us/webhelp/onlinehelp/nsg/sfos/concepts/LogFields.html

	split {
     field => "message"
     terminator => "<utm-log-separator>"
    }

  #Looking for datasource generated by an agent and parse original message
  if [message]=~/\[utm_stack_agent_ds=(.+)\]-(.+)/ {
    grok {
      match => {
        "message" => [ "\[utm_stack_agent_ds=%{DATA:dataSource}\]-%{GREEDYDATA:original_log_message}" ]
      }
    }
  }
  if [original_log_message] {
    mutate {
      update => { "message" => "%{[original_log_message]}" }
    }
  }

	if ![dataType] {
		#First, search for common fields and parse them
		grok {
			match => {
				"message" => [
				"device=%{QUOTEDSTRING:device} date=%{DATA:syslog_timestamp} time=%{TIME:xg_time} timezone=%{DATA:xg_timezone} device_name=%{QUOTEDSTRING:device_name} device_id=%{DATA:device_id} log_id=%{DATA:log_id} log_type=%{QUOTEDSTRING:log_type} log_component=%{QUOTEDSTRING:log_component} %{GREEDYDATA:msg}",
				"%{GREEDYDATA}device=%{QUOTEDSTRING:device} date=%{DATA:syslog_timestamp} time=%{TIME:xg_time} timezone=%{DATA:xg_timezone} device_name=%{QUOTEDSTRING:device_name} device_id=%{DATA:device_id} log_id=%{DATA:log_id} log_type=%{QUOTEDSTRING:log_type} log_component=%{QUOTEDSTRING:log_component} %{GREEDYDATA:msg}"
				]
			}
		}
		#Replacing string quotation for common fields
			mutate {
				gsub => ["device", ''"'', ""]
				gsub => ["device_name", ''"'', ""]
				gsub => ["log_type", ''"'', ""]
				gsub => ["log_component", ''"'', ""]
			}
		if [log_type] and ([log_type] == "Firewall" or [log_type] == "Content Filtering" or [log_type] == "Event"
		   or [log_type] == "WAF" or [log_type] == "System Health" or [log_type] == "IDP"
		   or [log_type] == "ATP" or [log_type] == "EATP" or ([log_type] == "Antivirus" or [log_type] == "Anti-Virus")
		   or [log_type] == "Anti-spam" or [log_type] == "Anti-Spam"
		   or [log_type] == "Heartbeat" or [log_type] == "Sandbox"
		   or [log_type] == "Wireless protection" or [log_type] == "Wireless Protection"
		   or [log_type] == "System health" or [log_type] == "Content filtering"
		   or [log_type] == "SSL" ) {
			#Other fields needed for rules in Correlation Engine
		  if [msg] {
			grok {
				match => {
					"msg" => [
					"status=%{QUOTEDSTRING:status} %{GREEDYDATA}",
					"%{GREEDYDATA} status=%{QUOTEDSTRING:status} %{GREEDYDATA}"
					]
				}
			}
			grok {
				match => {
					"msg" => [
					"log_subtype=%{QUOTEDSTRING:log_subtype} %{GREEDYDATA}",
					"%{GREEDYDATA} log_subtype=%{QUOTEDSTRING:log_subtype} %{GREEDYDATA}"
					]
				}
			}
			grok {
				match => {
					"msg" => [
					"priority=%{WORD:priority} %{GREEDYDATA}",
					"%{GREEDYDATA} priority=%{WORD:priority} %{GREEDYDATA}"
					]
				}
			}
			grok {
				match => {
					"msg" => [
					"%{GREEDYDATA} (sent_bytes|bytes_sent)=%{INT:sent_bytes} %{GREEDYDATA}"
					]
				}
			}
			grok {
				match => {
					"msg" => [
					"%{GREEDYDATA} (recv_bytes|bytes_received|bytes_recv)=%{INT:recv_bytes} %{GREEDYDATA}"
					]
				}
			}
		  }
			#Adding common fields to logx tree structure
			mutate {
				add_field => { "[dataType]" => "firewall-sophos-xg" }
				rename => { "[device]" => "[logx][sophos][device]" }
				rename => { "[device_name]" => "[logx][sophos][device_name]" }
				rename => { "[device_id]" => "sophosDataSource" }
				rename => { "[log_id]" => "[logx][sophos][log_id]" }
				rename => { "[log_type]" => "[logx][sophos][log_type]" }
				rename => { "[log_component]" => "[logx][sophos][log_component]" }
				rename => { "[status]" => "[logx][sophos][status]" }
				rename => { "[log_subtype]" => "[logx][sophos][log_subtype]" }
				rename => { "[message]" => "[logx][sophos][message]" }
				rename => { "[syslog_timestamp]" => "[logx][sophos][syslog_timestamp]" }
				rename => { "[xg_time]" => "[logx][sophos][xg_time]" }
				rename => { "[xg_timezone]" => "[logx][sophos][xg_timezone]" }
				rename => { "[priority]" => "[logx][sophos][priority]" }
				rename => { "[sent_bytes]" => "[logx][sophos][sent_bytes]" }
				rename => { "[recv_bytes]" => "[logx][sophos][recv_bytes]" }
			}

#......................................................................#
#Generating dataSource field required by CurrelationRulesEngine
#Checks if sophosDataSource exists, if true, the dataSource field take its value, if not, take the agent dataSource value
    if ([sophosDataSource]){
        if [dataSource] {
          mutate {
            update => { "dataSource" => "%{[sophosDataSource]}" }
          }
        } else {
          mutate {
            add_field => { "dataSource" => "%{sophosDataSource}" }
          }
        }
    }
#Finally evaluates to the host variable if can not be calculated
    if ![dataSource] {
       mutate {
          add_field => { "dataSource" => "%{host}" }
       }
    }

		if [logx][sophos][device] and [logx][sophos][device] == "SFW" {
			if [msg] {
			#Fields from Firewall log_type
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} (src_ip|sourceip)=%{IP:src_ip} %{GREEDYDATA}"
						]
					}
				}
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} (dst_ip|destinationip)=%{IP:dst_ip} %{GREEDYDATA}"
						]
					}
				}
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} protocol=%{QUOTEDSTRING:proto} %{GREEDYDATA}"
						]
					}
				}
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} src_port=%{NUMBER:src_port} %{GREEDYDATA}"
						]
					}
				}
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} dst_port=%{NUMBER:dst_port} %{GREEDYDATA}"
						]
					}
				}
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} application=%{QUOTEDSTRING:application} %{GREEDYDATA}"
						]
					}
				}
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} (application_risk|app_risk)=%{NUMBER:application_risk} %{GREEDYDATA}"
						]
					}
				}
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} (application_technology|app_technology)=%{QUOTEDSTRING:application_technology} %{GREEDYDATA}"
						]
					}
				}
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} (application_name|app_name)=%{QUOTEDSTRING:application_name} %{GREEDYDATA}"
						]
					}
				}
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} (application_category|app_category)=%{QUOTEDSTRING:application_category} %{GREEDYDATA}"
						]
					}
				}
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} (user_name)=%{QUOTEDSTRING:user_name} %{GREEDYDATA}"
						]
					}
				}
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} (src_country_code|src_country)=%{WORD:src_country_code} %{GREEDYDATA}"
						]
					}
				}
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} (dst_country_code|dst_country)=%{WORD:dst_country_code} %{GREEDYDATA}"
						]
					}
				}
				#1.3.7
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} dst_mac=%{QUOTEDSTRING:dst_mac} %{GREEDYDATA}"
						]
					}
				}
			#New fields from Content Filtering
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} category=%{QUOTEDSTRING:category} %{GREEDYDATA}"
						]
					}
				}
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} category_type=%{QUOTEDSTRING:category_type} %{GREEDYDATA}"
						]
					}
				}
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} (url|FTP_url)=%{NOTSPACE:url} %{GREEDYDATA}"
						]
					}
				}
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} download_file_name=%{QUOTEDSTRING:download_file_name} %{GREEDYDATA}"
						]
					}
				}
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} download_file_type=%{QUOTEDSTRING:download_file_type} %{GREEDYDATA}"
						]
					}
				}
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} upload_file_name=%{QUOTEDSTRING:upload_file_name} %{GREEDYDATA}"
						]
					}
				}
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} upload_file_type=%{QUOTEDSTRING:upload_file_type} %{GREEDYDATA}"
						]
					}
				}

			#New fields from Event log_type
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} reason=%{QUOTEDSTRING:reason} %{GREEDYDATA}"
						]
					}
				}
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} message=%{QUOTEDSTRING:event_message} %{GREEDYDATA}"
						]
					}
				}
				#1.3.7
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} src_mac=%{QUOTEDSTRING:src_mac} %{GREEDYDATA}"
						]
					}
				}
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} (client_used|auth_client)=%{QUOTEDSTRING:client_used} %{GREEDYDATA}"
						]
					}
				}
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} gatewayname=%{QUOTEDSTRING:gateway_name} %{GREEDYDATA}"
						]
					}
				}
			#Fields from WAF log_type
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} server=%{NOTSPACE:server} %{GREEDYDATA}"
						]
					}
				}
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} contenttype=%{QUOTEDSTRING:contenttype} %{GREEDYDATA}"
						]
					}
				}
			#Fields from Antivirus log_type
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} (status_code|httpstatus)=%{NUMBER:httpstatus} %{GREEDYDATA}"
						]
					}
				}
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} (user_agent|useragent)=%{QUOTEDSTRING:useragent} %{GREEDYDATA}"
						]
					}
				}
			#New fields from 1.3.7
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} severity=%{QUOTEDSTRING:severity} %{GREEDYDATA}",
						"%{GREEDYDATA} severity=%{WORD:severity} %{GREEDYDATA}"
						]
					}
				}
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} malware=%{QUOTEDSTRING:malware_name} %{GREEDYDATA}"
						]
					}
				}
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} (domain|domainname|src_domainname)=%{QUOTEDSTRING:domain} %{GREEDYDATA}"
						]
					}
				}
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} virus=%{QUOTEDSTRING:malware_name} %{GREEDYDATA}"
						]
					}
				}
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} (user_group|user_gp|usergroupname)=%{QUOTEDSTRING:user_group} %{GREEDYDATA}"
						]
					}
				}
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} (con_direction|FTP_direction)=%{QUOTEDSTRING:direction} %{GREEDYDATA}"
						]
					}
				}
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} file_path=%{QUOTEDSTRING:file_path} %{GREEDYDATA}"
						]
					}
				}
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} (parent_app|parent_application)=%{QUOTEDSTRING:parent_application_name} %{GREEDYDATA}"
						]
					}
				}
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} (parent_app_category|parent_application_category)=%{QUOTEDSTRING:parent_application_category} %{GREEDYDATA}"
						]
					}
				}
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} (parent_app_risk|parent_application_risk)=%{QUOTEDSTRING:parent_application_risk} %{GREEDYDATA}"
						]
					}
				}
			#Fields from IDP log_type
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} signature_msg=%{QUOTEDSTRING:event_message} %{GREEDYDATA}"
						]
					}
				}
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} classification=%{QUOTEDSTRING:classification} %{GREEDYDATA}"
						]
					}
				}
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} platform=%{QUOTEDSTRING:platform} %{GREEDYDATA}"
						]
					}
				}
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} target=%{QUOTEDSTRING:target} %{GREEDYDATA}"
						]
					}
				}
			#Fields from ATP log_type
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} destinationip=%{IP:dst_ip} %{GREEDYDATA}"
						]
					}
				}
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} threatname=%{NOTSPACE:threatname} %{GREEDYDATA}"
						]
					}
				}
				#1.3.7
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} (reported_user|login_user)=%{QUOTEDSTRING:login_user} %{GREEDYDATA}"
						]
					}
				}
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} (process_user|proc_user)=%{QUOTEDSTRING:process_user} %{GREEDYDATA}"
						]
					}
				}
			#Fields from Anti-Spam log_type
			#1.3.7
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} (action|spamaction)=%{QUOTEDSTRING:action} %{GREEDYDATA}",
						"%{GREEDYDATA} (action|spamaction)=%{WORD:action} %{GREEDYDATA}"
						]
					}
				}
			#Fields from System Health log_type
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} users=%{NUMBER:users} %{GREEDYDATA}"
						]
					}
				}
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} display_interface=%{QUOTEDSTRING:display_interface} %{GREEDYDATA}"
						]
					}
				}
			}

                mutate {
					#Common Fields
					gsub => ["[logx][sophos][status]", ''"'', ""]
					gsub => ["[logx][sophos][log_subtype]", ''"'', ""]
					gsub => ["[logx][sophos][xg_timezone]", ''"'', ""]

					#Fields from Firewall log_type
					gsub => ["src_ip", ''"'', ""]
					gsub => ["src_port", ''"'', ""]
					gsub => ["dst_ip", ''"'', ""]
					gsub => ["dest_port", ''"'', ""]
					gsub => ["proto", ''"'', ""]
					gsub => ["application", ''"'', ""]
					gsub => ["application_risk", ''"'', ""]
					gsub => ["application_technology", ''"'', ""]
					gsub => ["application_name", ''"'', ""]
					gsub => ["application_category", ''"'', ""]
					gsub => ["user_name", ''"'', ""]
					gsub => ["src_country_code", ''"'', ""]
					gsub => ["dst_country_code", ''"'', ""]
					#1.3.7
					gsub => ["dst_mac", ''"'', ""]

					#New fields from Content Filtering log_type
					gsub => ["category", ''"'', ""]
					gsub => ["category_type", ''"'', ""]
					gsub => ["url", ''"'', ""]
					gsub => ["download_file_name", ''"'', ""]
					gsub => ["download_file_type", ''"'', ""]
					gsub => ["upload_file_name", ''"'', ""]
					gsub => ["upload_file_type", ''"'', ""]

					#New fields from Event log_type
					gsub => ["reason", ''"'', ""]
					gsub => ["event_message", ''"'', ""]
					#1.3.7
					gsub => ["src_mac", ''"'', ""]
					gsub => ["client_used", ''"'', ""]
					gsub => ["src_host", ''"'', ""]
					gsub => ["reported_ip", ''"'', ""]
					gsub => ["updated_ip", ''"'', ""]
					gsub => ["gateway_name", ''"'', ""]

					#Fields from WAF log_type
					gsub => ["server", ''"'', ""]
					gsub => ["contenttype", ''"'', ""]
					gsub => ["useragent", ''"'', ""]

					#Fields from Antivirus log_type
					#1.3.7
					gsub => ["severity", ''"'', ""]
					gsub => ["malware_name", ''"'', ""]
					gsub => ["domain", ''"'', ""]
					gsub => ["user_group", ''"'', ""]
					gsub => ["direction", ''"'', ""]
					gsub => ["file_path", ''"'', ""]
					gsub => ["parent_application_name", ''"'', ""]
					gsub => ["parent_application_category", ''"'', ""]
					gsub => ["parent_application_risk", ''"'', ""]

					#Fields from IDP log_type
					gsub => ["classification", ''"'', ""]
					gsub => ["platform", ''"'', ""]
					gsub => ["target", ''"'', ""]

					#Fields from ATP log_type
					gsub => ["threatname", ''"'', ""]
					#1.3.7
					gsub => ["login_user", ''"'', ""]
					gsub => ["process_user", ''"'', ""]

					#Fields from Anti-Spam log_type
					#1.3.7
					gsub => ["action", ''"'', ""]

					#Fields from System Health log_type
					gsub => ["users", ''"'', ""]
					gsub => ["display_interface", ''"'', ""]

					}

			#Do specific mutations to unify field names across log_type
			if ([logx][sophos][log_type] == "Antivirus" or [logx][sophos][log_type] == "Anti-Virus")
			and [logx][sophos][log_component] == "FTP" {
				if ([direction]) and ([direction] == "Upload" or [direction] == "upload") {
					grok {
						match => {
							"msg" => [
							"%{GREEDYDATA} (filename|file_name)=%{QUOTEDSTRING:upload_file_name} %{GREEDYDATA}"
							]
						}
					}
					mutate {
						gsub => ["upload_file_name", ''"'', ""]
					}

				} else {
					grok {
						match => {
							"msg" => [
							"%{GREEDYDATA} (filename|file_name)=%{QUOTEDSTRING:download_file_name} %{GREEDYDATA}"
							]
						}
					}
					mutate {
						gsub => ["download_file_name", ''"'', ""]
					}
				}
			} else if [logx][sophos][log_type] == "WAF" {
				grok {
					match => {
						"msg" => [
						"%{GREEDYDATA} localip=%{IP:local_ip} %{GREEDYDATA}"
						]
					}
				}
				mutate {
					gsub => ["local_ip", ''"'', ""]
				}
			} else if [logx][sophos][log_type] == "Event" {
				if ([logx][sophos][log_component] == "L2TP" or [logx][sophos][log_component] == "PPTP") {
					grok {
						match => {
							"msg" => [
							"%{GREEDYDATA} localip=%{IP:src_ip} %{GREEDYDATA}"
							]
						}
					}
					grok {
						match => {
							"msg" => [
							"%{GREEDYDATA} remotepeer=%{IP:dst_ip} %{GREEDYDATA}"
							]
						}
					}
					mutate {
						gsub => ["src_ip", ''"'', ""]
						gsub => ["dst_ip", ''"'', ""]
					}
				} else if ([logx][sophos][log_component] == "DDNS" or [logx][sophos][log_component] == "DHCP Server") {
					grok {
						match => {
							"msg" => [
							"%{GREEDYDATA} (src_host|host|client_host_name|reported_host)=%{IPORHOST:src_host} %{GREEDYDATA}"
							]
						}
					}
					grok {
						match => {
							"msg" => [
							"%{GREEDYDATA} client_physical_address=%{QUOTEDSTRING:src_mac} %{GREEDYDATA}"
							]
						}
					}
					if ![src_ip] {
						grok {
							match => {
								"msg" => [
								"%{GREEDYDATA} (reported_ip|reportedip)=%{IPORHOST:src_ip} %{GREEDYDATA}",
								"%{GREEDYDATA} (reported_ip|reportedip)=%{QUOTEDSTRING:src_ip} %{GREEDYDATA}"
								]
							}
						}
					}
					if ![src_ip] {
						grok {
							match => {
								"msg" => [
								"%{GREEDYDATA} (updatedip|updated_ip)=%{IPORHOST:src_ip} %{GREEDYDATA}",
								"%{GREEDYDATA} (updatedip|updated_ip)=%{QUOTEDSTRING:src_ip} %{GREEDYDATA}"
								]
							}
						}
					}
					if ![src_ip] {
						grok {
							match => {
								"msg" => [
								"%{GREEDYDATA} ipaddress=%{IPORHOST:src_ip} %{GREEDYDATA}",
								"%{GREEDYDATA} ipaddress=%{QUOTEDSTRING:src_ip} %{GREEDYDATA}"
								]
							}
						}
					}
					if ![src_ip] {
						grok {
							match => {
								"msg" => [
								"%{GREEDYDATA} leased_ip=%{IPORHOST:src_ip} %{GREEDYDATA}",
								"%{GREEDYDATA} leased_ip=%{QUOTEDSTRING:src_ip} %{GREEDYDATA}"
								]
							}
						}
					}
					mutate {
						gsub => ["src_ip", ''"'', ""]
						gsub => ["src_mac", ''"'', ""]
						gsub => ["src_host", ''"'', ""]
					}
				} else if [logx][sophos][log_component] == "Quarantine" {
					grok {
						match => {
							"msg" => [
							"%{GREEDYDATA} from=%{QUOTEDSTRING:email_sender} %{GREEDYDATA}"
							]
						}
					}
					grok {
						match => {
							"msg" => [
							"%{GREEDYDATA} to=%{QUOTEDSTRING:email_recipient} %{GREEDYDATA}"
							]
						}
					}
					mutate {
						gsub => ["email_sender", ''"'', ""]
						gsub => ["email_recipient", ''"'', ""]
					}
				}
			} else if ([logx][sophos][log_type] == "Anti-spam" or [logx][sophos][log_type] == "Anti-Spam")
					or ([log_type] == "Antivirus" or [log_type] == "Anti-Virus") {
				if ([logx][sophos][log_component] == "SMTP" or [logx][sophos][log_component] == "SMTPS"
				or [logx][sophos][log_component] == "POP3" or [logx][sophos][log_component] == "IMAP4"
				or [logx][sophos][log_component] == "IMAPS" or [logx][sophos][log_component] == "POPS") {
					grok {
						match => {
							"msg" => [
							"%{GREEDYDATA} (sender|from_email_address)=%{QUOTEDSTRING:email_sender} %{GREEDYDATA}"
							]
						}
					}
					grok {
						match => {
							"msg" => [
							"%{GREEDYDATA} (recipient|to_email_address)=%{QUOTEDSTRING:email_recipient} %{GREEDYDATA}"
							]
						}
					}
					mutate {
						gsub => ["email_sender", ''"'', ""]
						gsub => ["email_recipient", ''"'', ""]
					}
				}
			} else if [logx][sophos][log_type] == "Sandbox" {
					grok {
						match => {
							"msg" => [
							"%{GREEDYDATA} source=%{QUOTEDSTRING:domain} %{GREEDYDATA}"
							]
						}
					}
					grok {
						match => {
							"msg" => [
							"%{GREEDYDATA} (file_hash|sha1sum)=%{QUOTEDSTRING:file_hash} %{GREEDYDATA}"
							]
						}
					}
					mutate {
						gsub => ["file_hash", ''"'', ""]
					}
			}


			#Set logx tree structure
				mutate {
					#Fields from Firewall log_type, adding to logx tree structure
					rename => { "[src_ip]" => "[logx][sophos][src_ip]" }
					rename => { "[src_port]" => "[logx][sophos][src_port]" }
					rename => { "[dst_ip]" => "[logx][sophos][dest_ip]" }
					rename => { "[dst_port]" => "[logx][sophos][dest_port]" }
					rename => { "[proto]" => "[logx][sophos][proto]" }
					rename => { "[application]" => "[logx][sophos][application]" }
					rename => { "[application_risk]" => "[logx][sophos][application_risk]" }
					rename => { "[application_technology]" => "[logx][sophos][application_technology]" }
					rename => { "[application_name]" => "[logx][sophos][application_name]" }
					rename => { "[application_category]" => "[logx][sophos][application_category]" }
					rename => { "[user_name]" => "[logx][sophos][user_name]" }
					rename => { "[src_country_code]" => "[logx][sophos][src_country_code]" }
					rename => { "[dst_country_code]" => "[logx][sophos][dst_country_code]" }
					#1.3.7
					rename => { "[dst_mac]" => "[logx][sophos][dst_mac]" }

					#New fields from Content Filtering log_type
					rename => { "[category]" => "[logx][sophos][category]" }
					rename => { "[category_type]" => "[logx][sophos][category_type]" }
					rename => { "[url]" => "[logx][sophos][url]" }
					rename => { "[download_file_name]" => "[logx][sophos][download_file_name]" }
					rename => { "[download_file_type]" => "[logx][sophos][download_file_type]" }
					rename => { "[upload_file_name]" => "[logx][sophos][upload_file_name]" }
					rename => { "[upload_file_type]" => "[logx][sophos][upload_file_type]" }

					#New fields from Event log_type
					rename => { "[reason]" => "[logx][sophos][reason]" }
					rename => { "[event_message]" => "[logx][sophos][event_message]" }
					#1.3.7
					rename => { "[src_mac]" => "[logx][sophos][src_mac]" }
					rename => { "[client_used]" => "[logx][sophos][client_used]" }
					rename => { "[src_host]" => "[logx][sophos][src_host]" }
					rename => { "[reported_ip]" => "[logx][sophos][reported_ip]" }
					rename => { "[updated_ip]" => "[logx][sophos][updated_ip]" }
					rename => { "[gateway_name]" => "[logx][sophos][gateway_name]" }

					#New fields from WAF log_type
					rename => { "[server]" => "[logx][sophos][server]" }
					rename => { "[httpstatus]" => "[logx][sophos][httpstatus]" }
					rename => { "[contenttype]" => "[logx][sophos][contenttype]" }
					rename => { "[useragent]" => "[logx][sophos][useragent]" }
					#1.3.7
					rename => { "[local_ip]" => "[logx][sophos][local_ip]" }

					#New fields from Antivirus log_type
					#1.3.7
					rename => { "[severity]" => "[logx][sophos][severity]" }
					rename => { "[malware_name]" => "[logx][sophos][malware_name]" }
					rename => { "[domain]" => "[logx][sophos][domain]" }
					rename => { "[user_group]" => "[logx][sophos][user_group]" }
					rename => { "[direction]" => "[logx][sophos][direction]" }
					rename => { "[file_path]" => "[logx][sophos][file_path]" }
					rename => { "[parent_application_name]" => "[logx][sophos][parent_application_name]" }
					rename => { "[parent_application_category]" => "[logx][sophos][parent_application_category]" }
					rename => { "[parent_application_risk]" => "[logx][sophos][parent_application_risk]" }

					#New fields from IDP log_type
					rename => { "[classification]" => "[logx][sophos][classification]" }
					rename => { "[platform]" => "[logx][sophos][platform]" }
					rename => { "[target]" => "[logx][sophos][target]" }

					#New fields from ATP log_type
					rename => { "[threatname]" => "[logx][sophos][threatname]" }
					#1.3.7
					rename => { "[login_user]" => "[logx][sophos][login_user]" }
					rename => { "[process_user]" => "[logx][sophos][process_user]" }

					#New fields from Anti-Spam log_type
					#1.3.7
					rename => { "[email_sender]" => "[logx][sophos][email_sender]" }
					rename => { "[email_recipient]" => "[logx][sophos][email_recipient]" }
					rename => { "[action]" => "[logx][sophos][log_action]" }

					#New fields from System Health log_type
					rename => { "[users]" => "[logx][sophos][users]" }
					rename => { "[display_interface]" => "[logx][sophos][display_interface]" }

					#New fields from Sandbox log_type
					#1.3.7
					rename => { "[file_hash]" => "[logx][sophos][file_hash]" }

				}
		}
       #Generating action field used by Correlation engine
       if [logx][sophos][status] and [logx][sophos][status] =~/(Allow|Allow Session|Successful|Established|Connected|Success|Renew)/ {
          mutate {
            add_field => { "[logx][utm][action]" => "Success" }
          }
       } else if ([logx][sophos][status] and [logx][sophos][status] == "Interim") and
                ([logx][sophos][sent_bytes] and [logx][sophos][sent_bytes] != "0") and ([logx][sophos][recv_bytes] and [logx][sophos][recv_bytes] != "0") {
          mutate {
            add_field => { "[logx][utm][action]" => "Success" }
          }
       } else if ([logx][sophos][log_subtype] and [logx][sophos][log_subtype] == "Allowed") and
                (![logx][sophos][status] or [logx][sophos][status] == "") and
                ([logx][sophos][sent_bytes] and [logx][sophos][sent_bytes] != "0") and
				([logx][sophos][recv_bytes] and [logx][sophos][recv_bytes] != "0") {
          mutate {
            add_field => { "[logx][utm][action]" => "Success" }
          }
       } else if [logx][sophos][log_component] and ([logx][sophos][log_component] == "FTP" or [logx][sophos][log_component] == "HTTP") and
                 ([logx][sophos][recv_bytes] and [logx][sophos][recv_bytes] != "0") {
          mutate {
            add_field => { "[logx][utm][action]" => "Success" }
          }
       } else if [logx][sophos][log_type] == "SSL" and ([logx][sophos][log_subtype] == "Decrypt"
	          or [logx][sophos][log_subtype] == "Do not decrypt" ) {
          mutate {
            add_field => { "[logx][utm][action]" => "Success" }
          }

	   }
       #Finally, remove unnecessary fields
       mutate {
         remove_field => ["@version","path","tags","type","msg"]
       }

     }
   }
   #Also, remove unwanted fields if the message not match with conditions
   mutate {
      remove_field => ["sophosDataSource","original_log_message","headers"]
   }
}
'
WHERE id=801;
----------------------------------------------------------------------------------------------------------------------------------------
-- VMWARE  --
----------------------------------------------------------------------------------------------------------------------------------------
UPDATE utm_logstash_filter
SET filter_version='2.0.1',logstash_filter='filter {
# VMWare ESXi filter, version 2.0.1
# Based on https://core.vmware.com/esxi-log-message-formats (june, 2022)
# and real logs provided

    split {
     field => "message"
     terminator => "<utm-log-separator>"
    }

    #Looking for datasource generated by an agent and parse original message
    if [message]=~/\[utm_stack_agent_ds=(.+)\]-(.+)/ {
      grok {
        match => {
          "message" => [ "\[utm_stack_agent_ds=%{DATA:dataSource}\]-%{GREEDYDATA:original_log_message}" ]
        }
      }
    }
    if [original_log_message] {
      mutate {
        update => { "message" => "%{[original_log_message]}" }
      }
    }

    if ![dataType] {
      if ([message]) {
        grok {
            match => {
                "message" => [
                    "%{TIMESTAMP_ISO8601:timestamp} %{IPORHOST:vmwareDataSource} %{WORD:process}: %{WORD:level} %{GREEDYDATA:msg}",
                    "%{DATA}>%{TIMESTAMP_ISO8601:timestamp} %{IPORHOST:vmwareDataSource} %{WORD:process}: %{WORD:level} %{GREEDYDATA:msg}",
                    "(<%{NUMBER:priority}>)?%{TIMESTAMP_ISO8601:timestamp} %{IPORHOST:vmwareDataSource} %{DATA:process}(\[%{INT:pid}\])?: %{GREEDYDATA:msg}"
                ]
            }
        }
      }
    }
    #......................................................................#
    #Generating dataSource field required by CurrelationRulesEngine
    #Checks if vmwareDataSource exists, if true, the dataSource field take its value, if not, take the agent dataSource value
     if ([vmwareDataSource]){
            if [dataSource] {
              mutate {
                update => { "dataSource" => "%{[vmwareDataSource]}" }
              }
            } else {
              mutate {
                add_field => { "dataSource" => "%{vmwareDataSource}" }
              }
            }
     }
    #Finally evaluates to the host variable if can not be calculated
     if ![dataSource] {
        mutate {
           add_field => { "dataSource" => "%{host}" }
         }
     }

    if [process] and ([process] == "Hostd" or [process] == "VVold" or [process] == "Vpxa"
    or [process] == "Rhttpproxy" or [process] == "vmkernel" or [process] == "Fdm"
    or [process] == "vmkwarning" or [process] == "vobd" or [process] == "osfsd"
    or ([process] == "hostd-probe" and ([msg] and "ESXi" in [msg])) or ([process] == "crx-cli" and ([msg] and "VMware ESXi" in [msg])) ){
        mutate {
            remove_field => [ "message" ]
            add_field => {"[dataType]" => "vmware-esxi"}
        }
    }
   #Also, remove unwanted fields if the message not match with conditions
   mutate {
      remove_field => ["vmwareDataSource","original_log_message","headers"]
   }
}
'
WHERE id=1001;
----------------------------------------------------------------------------------------------------------------------------------------
-- WINDOWS EVENTS  --
----------------------------------------------------------------------------------------------------------------------------------------
UPDATE utm_logstash_filter
SET filter_version='3.0.1',logstash_filter='filter {

#Filter Version 3.0.1
#Based on https://www.elastic.co/guide/en/beats/winlogbeat/8.5/exported-fields-winlog.html
#And https://www.elastic.co/guide/en/beats/libbeat/7.0/breaking-changes-7.0.html

    split {
      field => "message"
      terminator => "<utm-log-separator>"
    }
    json {
      source => "message"
    }

    if ([winlog][api] and [winlog][api] == "wineventlog") or ([type] and [type] == "wineventlog") {

        mutate {
            add_field => { "dataType" => "wineventlog" }

            add_field => {"[global][type]" => "logx"}
            remove_field => ["fileset"]
            remove_field => ["fields"]
        }

        #If winlogbeat is of old version
        if [type] and [type] == "wineventlog"{
            mutate {
                rename => { "[beat][name]" => "[dataSource]" }
                rename => {"[type]" => "[logx][type]"}

                rename => {"[activity_id]" => "[logx][wineventlog][activity_id]"}
                rename => {"[beat]" => "[logx][wineventlog][beat]"}
                rename => {"[event_data]" => "[logx][wineventlog][event_data]"}
                rename => {"[event_id]" => "[logx][wineventlog][event_id]"}
                rename => {"[keywords]" => "[logx][wineventlog][keywords]"}
                rename => {"[level]" => "[logx][wineventlog][level]"}
                rename => {"[log]" => "[logx][wineventlog][log]"}
                rename => {"[log_name]" => "[logx][wineventlog][log_name]"}
                rename => {"[opcode]" => "[logx][wineventlog][opcode]"}
                rename => {"[process_id]" => "[logx][wineventlog][process_id]"}
                rename => {"[provider_guid]" => "[logx][wineventlog][provider_guid]"}
                rename => {"[record_number]" => "[logx][wineventlog][record_number]"}
                rename => {"[source_name]" => "[logx][wineventlog][source_name]"}
                rename => {"[task]" => "[logx][wineventlog][task]"}
                rename => {"[thread_id]" => "[logx][wineventlog][thread_id]"}
                rename => {"[user]" => "[logx][wineventlog][user]"}
                rename => {"[user_data]" => "[logx][wineventlog][user_data]"}
                rename => {"[version]" => "[logx][wineventlog][version]"}

                rename => {"[meta]" => "[logx][wineventlog][meta]"}
                rename => {"[docker]" => "[logx][wineventlog][docker]"}
                rename => {"[related_activity_id]" => "[logx][wineventlog][related_activity_id]"}
            }
        }

        #If winlogbeat is of version 8.5.1
        if [winlog][api] and [winlog][api] == "wineventlog"{
           mutate {
                rename => { "[host][hostname]" => "[dataSource]" }
                rename => {"[winlog][api]" => "[logx][type]"}

                rename => {"[winlog][activity_id]" => "[logx][wineventlog][activity_id]"}
                rename => {"[event][timezone]" => "[logx][wineventlog][beat][timezone]"}
                rename => {"[agent][name]" => "[logx][wineventlog][beat][hostname]"}
                rename => {"[agent][version]" => "[logx][wineventlog][beat][version]"}
                rename => {"[event][original]" => "[xml]"}
                rename => {"[winlog][event_data]" => "[logx][wineventlog][event_data]"}
                rename => {"[winlog][event_id]" => "[logx][wineventlog][event_id]"}
                rename => {"[winlog][keywords]" => "[logx][wineventlog][keywords]"}
                rename => {"[log][level]" => "[logx][wineventlog][level]"}
                rename => {"[winlog][channel]" => "[logx][wineventlog][log_name]"}
                rename => {"[winlog][opcode]" => "[logx][wineventlog][opcode]"}
                rename => {"[winlog][process][pid]" => "[logx][wineventlog][process_id]"}
                rename => {"[winlog][provider_guid]" => "[logx][wineventlog][provider_guid]"}
                rename => {"[winlog][record_id]" => "[logx][wineventlog][record_number]"}
                rename => {"[winlog][provider_name]" => "[logx][wineventlog][source_name]"}
                rename => {"[winlog][task]" => "[logx][wineventlog][task]"}
                rename => {"[winlog][process][thread][id]" => "[logx][wineventlog][thread_id]"}
                rename => {"[winlog][user]" => "[logx][wineventlog][user]"}
                rename => {"[winlog][user_data]" => "[logx][wineventlog][user_data]"}
                rename => {"[winlog][version]" => "[logx][wineventlog][version]"}

                rename => {"[cloud]" => "[logx][wineventlog][meta][cloud]"}
                rename => {"[container]" => "[logx][wineventlog][docker][container]"}
                rename => {"[winlog][computer_name]" => "[computer_name]"}
                rename => {"[winlog][related_activity_id]" => "[logx][wineventlog][related_activity_id]"}
                rename => {"[ecs]" => "[logx][wineventlog][ecs]"}
                rename => {"[winlog][computerObject]" => "[logx][wineventlog][computerObject]"}
                rename => {"[winlog][time_created]" => "[logx][wineventlog][time_created]"}
                rename => {"[winlog][trustAttribute]" => "[logx][wineventlog][trustAttribute]"}
                rename => {"[winlog][trustDirection]" => "[logx][wineventlog][trustDirection]"}
                rename => {"[winlog][trustType]" => "[logx][wineventlog][trustType]"}
           }

           mutate { convert => { "[logx][wineventlog][event_id]" => "integer" }}
        }

        mutate {
            rename => {"[clienthost]" => "[logx][wineventlog][clienthost]"}
            rename => {"[geoip]" => "[logx][wineventlog][geoip]"}
            rename => {"[host]" => "[logx][wineventlog][host]"}
            rename => {"[input]" => "[logx][wineventlog][input]"}
            rename => {"[log_timestamp]" => "[logx][wineventlog][log_timestamp]"}
            rename => {"[message]" => "[logx][wineventlog][message]"}
            rename => {"[method]" => "[logx][wineventlog][method]"}
            rename => {"[offset]" => "[logx][wineventlog][offset]"}
            rename => {"[page]" => "[logx][wineventlog][page]"}
            rename => {"[port]" => "[logx][wineventlog][port]"}
            rename => {"[prospector]" => "[logx][wineventlog][prospector]"}
            rename => {"[querystring]" => "[logx][wineventlog][querystring]"}
            rename => {"[referer]" => "[logx][wineventlog][referer]"}
            rename => {"[response]" => "[logx][wineventlog][response]"}
            rename => {"[scstatus]" => "[logx][wineventlog][scstatus]"}
            rename => {"[site]" => "[logx][wineventlog][site]"}
            rename => {"[source]" => "[logx][wineventlog][source]"}
            rename => {"[subresponse]" => "[logx][wineventlog][subresponse]"}
            rename => {"[tags]" => "[logx][wineventlog][tags]"}
            rename => {"[timetaken]" => "[logx][wineventlog][timetaken]"}
            rename => {"[user_agent]" => "[logx][wineventlog][useragent]"}
            rename => {"[username]" => "[logx][wineventlog][username]"}
            rename => {"[error]" => "[logx][wineventlog][error]"}
            rename => {"[timeseries]" => "[logx][wineventlog][timeseries]"}
            rename => {"[event]" => "[logx][wineventlog][event]"}
            rename => {"[agent]" => "[logx][wineventlog][agent]"}
            rename => {"[as]" => "[logx][wineventlog][as]"}
            rename => {"[client]" => "[logx][wineventlog][client]"}
            rename => {"[code_signature]" => "[logx][wineventlog][code_signature]"}
            rename => {"[data_stream]" => "[logx][wineventlog][data_stream]"}
            rename => {"[destination]" => "[logx][wineventlog][destination]"}
            rename => {"[dll]" => "[logx][wineventlog][dll]"}
            rename => {"[dns]" => "[logx][wineventlog][dns]"}
            rename => {"[els]" => "[logx][wineventlog][els]"}
            rename => {"[faas]" => "[logx][wineventlog][faas]"}
            rename => {"[file]" => "[logx][wineventlog][file]"}
            rename => {"[geo]" => "[logx][wineventlog][geo]"}
            rename => {"[group]" => "[logx][wineventlog][group]"}
            rename => {"[http]" => "[logx][wineventlog][http]"}
            rename => {"[interface]" => "[logx][wineventlog][interface]"}
            rename => {"[network]" => "[logx][wineventlog][network]"}
            rename => {"[observer]" => "[logx][wineventlog][observer]"}
            rename => {"[orchestrator]" => "[logx][wineventlog][orchestrator]"}
            rename => {"[os]" => "[logx][wineventlog][os]"}
            rename => {"[package]" => "[logx][wineventlog][package]"}
            rename => {"[pe]" => "[logx][wineventlog][pe]"}
            rename => {"[registry]" => "[logx][wineventlog][registry]"}
            rename => {"[related]" => "[logx][wineventlog][related]"}
            rename => {"[rule]" => "[logx][wineventlog][rule]"}
            rename => {"[server]" => "[logx][wineventlog][server]"}
            rename => {"[service]" => "[logx][wineventlog][service]"}
            rename => {"[threat]" => "[logx][wineventlog][threat]"}
            rename => {"[tls]" => "[logx][wineventlog][tls]"}
            rename => {"[url]" => "[logx][wineventlog][url]"}
            rename => {"[vlan]" => "[logx][wineventlog][vlan]"}
            rename => {"[vulnerability]" => "[logx][wineventlog][vulnerability]"}
            rename => {"[x509]" => "[logx][wineventlog][x509]"}
            rename => {"[process]" => "[logx][wineventlog][process]"}
            rename => {"[powershell]" => "[logx][wineventlog][powershell]"}
        }

        mutate {
            remove_field => ["winlog"]
            remove_field => ["log"]
        }

        if [logx][wineventlog][event_id] {
            if [logx][wineventlog][event_id] == 1100 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The event logging service has shut down"}
                }
            }
            else if [logx][wineventlog][event_id] == 1101 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Audit events have been dropped by the transport."}
                }
            }
            else if [logx][wineventlog][event_id] == 1102 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The audit log was cleared"}
                }
            }
            else if [logx][wineventlog][event_id] == 1104 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The security Log is now full"}
                }
            }
            else if [logx][wineventlog][event_id] == 1105 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Event log automatic backup"}
                }
            }
            else if [logx][wineventlog][event_id] == 1108 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The event logging service encountered an error"}
                }
            }
            else if [logx][wineventlog][event_id] == 4608 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Windows is starting up"}
                }
            }
            else if [logx][wineventlog][event_id] == 4609 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Windows is shutting down"}
                }
            }
            else if [logx][wineventlog][event_id] == 4610 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An authentication package has been loaded by the Local Security Authority"}
                }
            }
            else if [logx][wineventlog][event_id] == 4611 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A trusted logon process has been registered with the Local Security Authority"}
                }
            }
            else if [logx][wineventlog][event_id] == 4612 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Internal resources allocated for the queuing of audit messages have been exhausted: leading to the loss of some audits."}
                }
            }
            else if [logx][wineventlog][event_id] == 4614 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A notification package has been loaded by the Security Account Manager."}
                }
            }
            else if [logx][wineventlog][event_id] == 4615 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Invalid use of LPC port"}
                }
            }
            else if [logx][wineventlog][event_id] == 4616 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The system time was changed."}
                }
            }
            else if [logx][wineventlog][event_id] == 4618 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A monitored security event pattern has occurred"}
                }
            }
            else if [logx][wineventlog][event_id] == 4621 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Administrator recovered system from CrashOnAuditFail"}
                }
            }
            else if [logx][wineventlog][event_id] == 4622 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A security package has been loaded by the Local Security Authority."}
                }
            }
            else if [logx][wineventlog][event_id] == 4624 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An account was successfully logged on"}
                }
            }
            else if [logx][wineventlog][event_id] == 4625 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An account failed to log on"}
                }
            }
            else if [logx][wineventlog][event_id] == 4626 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "User/Device claims information"}
                }
            }
            else if [logx][wineventlog][event_id] == 4627 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Group membership information."}
                }
            }
            else if [logx][wineventlog][event_id] == 4634 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An account was logged off"}
                }
            }
            else if [logx][wineventlog][event_id] == 4646 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "IKE DoS-prevention mode started"}
                }
            }
            else if [logx][wineventlog][event_id] == 4647 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "User initiated logoff"}
                }
            }
            else if [logx][wineventlog][event_id] == 4648 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A logon was attempted using explicit credentials"}
                }
            }
            else if [logx][wineventlog][event_id] == 4649 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A replay attack was detected"}
                }
            }
            else if [logx][wineventlog][event_id] == 4650 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An IPsec Main Mode security association was established"}
                }
            }
            else if [logx][wineventlog][event_id] == 4651 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An IPsec Main Mode security association was established"}
                }
            }
            else if [logx][wineventlog][event_id] == 4652 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An IPsec Main Mode negotiation failed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4653 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An IPsec Main Mode negotiation failed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4654 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An IPsec Quick Mode negotiation failed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4655 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An IPsec Main Mode security association ended"}
                }
            }
            else if [logx][wineventlog][event_id] == 4656 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A handle to an object was requested"}
                }
            }
            else if [logx][wineventlog][event_id] == 4657 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A registry value was modified"}
                }
            }
            else if [logx][wineventlog][event_id] == 4658 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The handle to an object was closed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4659 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A handle to an object was requested with intent to delete"}
                }
            }
            else if [logx][wineventlog][event_id] == 4660 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An object was deleted"}
                }
            }
            else if [logx][wineventlog][event_id] == 4661 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A handle to an object was requested"}
                }
            }
            else if [logx][wineventlog][event_id] == 4662 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An operation was performed on an object"}
                }
            }
            else if [logx][wineventlog][event_id] == 4663 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An attempt was made to access an object"}
                }
            }
            else if [logx][wineventlog][event_id] == 4664 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An attempt was made to create a hard link"}
                }
            }
            else if [logx][wineventlog][event_id] == 4665 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An attempt was made to create an application client context."}
                }
            }
            else if [logx][wineventlog][event_id] == 4666 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An application attempted an operation"}
                }
            }
            else if [logx][wineventlog][event_id] == 4667 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An application client context was deleted"}
                }
            }
            else if [logx][wineventlog][event_id] == 4668 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An application was initialized"}
                }
            }
            else if [logx][wineventlog][event_id] == 4670 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Permissions on an object were changed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4671 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An application attempted to access a blocked ordinal through the TBS"}
                }
            }
            else if [logx][wineventlog][event_id] == 4672 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Special privileges assigned to new logon"}
                }
            }
            else if [logx][wineventlog][event_id] == 4673 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A privileged service was called"}
                }
            }
            else if [logx][wineventlog][event_id] == 4674 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An operation was attempted on a privileged object"}
                }
            }
            else if [logx][wineventlog][event_id] == 4675 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "SIDs were filtered"}
                }
            }
            else if [logx][wineventlog][event_id] == 4688 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A new process has been created"}
                }
            }
            else if [logx][wineventlog][event_id] == 4689 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A process has exited"}
                }
            }
            else if [logx][wineventlog][event_id] == 4690 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An attempt was made to duplicate a handle to an object"}
                }
            }
            else if [logx][wineventlog][event_id] == 4691 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Indirect access to an object was requested"}
                }
            }
            else if [logx][wineventlog][event_id] == 4692 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Backup of data protection master key was attempted"}
                }
            }
            else if [logx][wineventlog][event_id] == 4693 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Recovery of data protection master key was attempted"}
                }
            }
            else if [logx][wineventlog][event_id] == 4694 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Protection of auditable protected data was attempted"}
                }
            }
            else if [logx][wineventlog][event_id] == 4695 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Unprotection of auditable protected data was attempted"}
                }
            }
            else if [logx][wineventlog][event_id] == 4696 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A primary token was assigned to process"}
                }
            }
            else if [logx][wineventlog][event_id] == 4697 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A service was installed in the system"}
                }
            }
            else if [logx][wineventlog][event_id] == 4698 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A scheduled task was created"}
                }
            }
            else if [logx][wineventlog][event_id] == 4699 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A scheduled task was deleted"}
                }
            }
            else if [logx][wineventlog][event_id] == 4700 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A scheduled task was enabled"}
                }
            }
            else if [logx][wineventlog][event_id] == 4701 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A scheduled task was disabled"}
                }
            }
            else if [logx][wineventlog][event_id] == 4702 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A scheduled task was updated"}
                }
            }
            else if [logx][wineventlog][event_id] == 4703 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A token right was adjusted"}
                }
            }
            else if [logx][wineventlog][event_id] == 4704 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A user right was assigned"}
                }
            }
            else if [logx][wineventlog][event_id] == 4705 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A user right was removed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4706 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A new trust was created to a domain"}
                }
            }
            else if [logx][wineventlog][event_id] == 4707 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A trust to a domain was removed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4709 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "IPsec Services was started"}
                }
            }
            else if [logx][wineventlog][event_id] == 4710 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "IPsec Services was disabled"}
                }
            }
            else if [logx][wineventlog][event_id] == 4711 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "PAStore Engine (1%)"}
                }
            }
            else if [logx][wineventlog][event_id] == 4712 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "IPsec Services encountered a potentially serious failure"}
                }
            }
            else if [logx][wineventlog][event_id] == 4713 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Kerberos policy was changed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4714 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Encrypted data recovery policy was changed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4715 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The audit policy (SACL) on an object was changed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4716 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Trusted domain information was modified"}
                }
            }
            else if [logx][wineventlog][event_id] == 4717 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "System security access was granted to an account"}
                }
            }
            else if [logx][wineventlog][event_id] == 4718 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "System security access was removed from an account"}
                }
            }
            else if [logx][wineventlog][event_id] == 4719 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "System audit policy was changed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4720 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A user account was created"}
                }
            }
            else if [logx][wineventlog][event_id] == 4722 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A user account was enabled"}
                }
            }
            else if [logx][wineventlog][event_id] == 4723 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An attempt was made to change an account''s password"}
                }
            }
            else if [logx][wineventlog][event_id] == 4724 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An attempt was made to reset an accounts password"}
                }
            }
            else if [logx][wineventlog][event_id] == 4725 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A user account was disabled"}
                }
            }
            else if [logx][wineventlog][event_id] == 4726 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A user account was deleted"}
                }
            }
            else if [logx][wineventlog][event_id] == 4727 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A security-enabled global group was created"}
                }
            }
            else if [logx][wineventlog][event_id] == 4728 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A member was added to a security-enabled global group"}
                }
            }
            else if [logx][wineventlog][event_id] == 4729 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A member was removed from a security-enabled global group"}
                }
            }
            else if [logx][wineventlog][event_id] == 4730 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A security-enabled global group was deleted"}
                }
            }
            else if [logx][wineventlog][event_id] == 4731 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A security-enabled local group was created"}
                }
            }
            else if [logx][wineventlog][event_id] == 4732 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A member was added to a security-enabled local group"}
                }
            }
            else if [logx][wineventlog][event_id] == 4733 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A member was removed from a security-enabled local group"}
                }
            }
            else if [logx][wineventlog][event_id] == 4734 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A security-enabled local group was deleted"}
                }
            }
            else if [logx][wineventlog][event_id] == 4735 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A security-enabled local group was changed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4737 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A security-enabled global group was changed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4738 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A user account was changed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4739 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Domain Policy was changed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4740 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A user account was locked out"}
                }
            }
            else if [logx][wineventlog][event_id] == 4741 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A computer account was created"}
                }
            }
            else if [logx][wineventlog][event_id] == 4742 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A computer account was changed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4743 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A computer account was deleted"}
                }
            }
            else if [logx][wineventlog][event_id] == 4744 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A security-disabled local group was created"}
                }
            }
            else if [logx][wineventlog][event_id] == 4745 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A security-disabled local group was changed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4746 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A member was added to a security-disabled local group"}
                }
            }
            else if [logx][wineventlog][event_id] == 4747 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A member was removed from a security-disabled local group"}
                }
            }
            else if [logx][wineventlog][event_id] == 4748 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A security-disabled local group was deleted"}
                }
            }
            else if [logx][wineventlog][event_id] == 4749 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A security-disabled global group was created"}
                }
            }
            else if [logx][wineventlog][event_id] == 4750 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A security-disabled global group was changed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4751 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A member was added to a security-disabled global group"}
                }
            }
            else if [logx][wineventlog][event_id] == 4752 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A member was removed from a security-disabled global group"}
                }
            }
            else if [logx][wineventlog][event_id] == 4753 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A security-disabled global group was deleted"}
                }
            }
            else if [logx][wineventlog][event_id] == 4754 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A security-enabled universal group was created"}
                }
            }
            else if [logx][wineventlog][event_id] == 4755 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A security-enabled universal group was changed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4756 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A member was added to a security-enabled universal group"}
                }
            }
            else if [logx][wineventlog][event_id] == 4757 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A member was removed from a security-enabled universal group"}
                }
            }
            else if [logx][wineventlog][event_id] == 4758 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A security-enabled universal group was deleted"}
                }
            }
            else if [logx][wineventlog][event_id] == 4759 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A security-disabled universal group was created"}
                }
            }
            else if [logx][wineventlog][event_id] == 4760 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A security-disabled universal group was changed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4761 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A member was added to a security-disabled universal group"}
                }
            }
            else if [logx][wineventlog][event_id] == 4762 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A member was removed from a security-disabled universal group"}
                }
            }
            else if [logx][wineventlog][event_id] == 4763 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A security-disabled universal group was deleted"}
                }
            }
            else if [logx][wineventlog][event_id] == 4764 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A groups type was changed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4765 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "SID History was added to an account"}
                }
            }
            else if [logx][wineventlog][event_id] == 4766 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An attempt to add SID History to an account failed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4767 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A user account was unlocked"}
                }
            }
            else if [logx][wineventlog][event_id] == 4768 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A Kerberos authentication ticket (TGT) was requested"}
                }
            }
            else if [logx][wineventlog][event_id] == 4769 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A Kerberos service ticket was requested"}
                }
            }
            else if [logx][wineventlog][event_id] == 4770 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A Kerberos service ticket was renewed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4771 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Kerberos pre-authentication failed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4772 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A Kerberos authentication ticket request failed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4773 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A Kerberos service ticket request failed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4774 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An account was mapped for logon"}
                }
            }
            else if [logx][wineventlog][event_id] == 4775 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An account could not be mapped for logon"}
                }
            }
            else if [logx][wineventlog][event_id] == 4776 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The domain controller attempted to validate the credentials for an account"}
                }
            }
            else if [logx][wineventlog][event_id] == 4777 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The domain controller failed to validate the credentials for an account"}
                }
            }
            else if [logx][wineventlog][event_id] == 4778 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A session was reconnected to a Window Station"}
                }
            }
            else if [logx][wineventlog][event_id] == 4779 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A session was disconnected from a Window Station"}
                }
            }
            else if [logx][wineventlog][event_id] == 4780 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The ACL was set on accounts which are members of administrators groups"}
                }
            }
            else if [logx][wineventlog][event_id] == 4781 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The name of an account was changed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4782 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The password hash an account was accessed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4783 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A basic application group was created"}
                }
            }
            else if [logx][wineventlog][event_id] == 4784 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A basic application group was changed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4785 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A member was added to a basic application group"}
                }
            }
            else if [logx][wineventlog][event_id] == 4786 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A member was removed from a basic application group"}
                }
            }
            else if [logx][wineventlog][event_id] == 4787 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A non-member was added to a basic application group"}
                }
            }
            else if [logx][wineventlog][event_id] == 4788 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A non-member was removed from a basic application group."}
                }
            }
            else if [logx][wineventlog][event_id] == 4789 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A basic application group was deleted"}
                }
            }
            else if [logx][wineventlog][event_id] == 4790 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An LDAP query group was created"}
                }
            }
            else if [logx][wineventlog][event_id] == 4791 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A basic application group was changed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4792 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An LDAP query group was deleted"}
                }
            }
            else if [logx][wineventlog][event_id] == 4793 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The Password Policy Checking API was called"}
                }
            }
            else if [logx][wineventlog][event_id] == 4794 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An attempt was made to set the Directory Services Restore Mode administrator password"}
                }
            }
            else if [logx][wineventlog][event_id] == 4797 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An attempt was made to query the existence of a blank password for an account"}
                }
            }
            else if [logx][wineventlog][event_id] == 4798 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A user''s local group membership was enumerated."}
                }
            }
            else if [logx][wineventlog][event_id] == 4799 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A security-enabled local group membership was enumerated"}
                }
            }
            else if [logx][wineventlog][event_id] == 4800 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The workstation was locked"}
                }
            }
            else if [logx][wineventlog][event_id] == 4801 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The workstation was unlocked"}
                }
            }
            else if [logx][wineventlog][event_id] == 4802 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The screen saver was invoked"}
                }
            }
            else if [logx][wineventlog][event_id] == 4803 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The screen saver was dismissed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4816 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "RPC detected an integrity violation while decrypting an incoming message"}
                }
            }
            else if [logx][wineventlog][event_id] == 4817 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Auditing settings on object were changed."}
                }
            }
            else if [logx][wineventlog][event_id] == 4818 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Proposed Central Access Policy does not grant the same access permissions as the current Central Access Policy"}
                }
            }
            else if [logx][wineventlog][event_id] == 4819 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Central Access Policies on the machine have been changed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4820 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A Kerberos Ticket-granting-ticket (TGT) was denied because the device does not meet the access control restrictions"}
                }
            }
            else if [logx][wineventlog][event_id] == 4821 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A Kerberos service ticket was denied because the user: device: or both does not meet the access control restrictions"}
                }
            }
            else if [logx][wineventlog][event_id] == 4822 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "NTLM authentication failed because the account was a member of the Protected User group"}
                }
            }
            else if [logx][wineventlog][event_id] == 4823 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "NTLM authentication failed because access control restrictions are required"}
                }
            }
            else if [logx][wineventlog][event_id] == 4824 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Kerberos preauthentication by using DES or RC4 failed because the account was a member of the Protected User group"}
                }
            }
            else if [logx][wineventlog][event_id] == 4825 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A user was denied the access to Remote Desktop. By default: users are allowed to connect only if they are members of the Remote Desktop Users group or Administrators group"}
                }
            }
            else if [logx][wineventlog][event_id] == 4826 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Boot Configuration Data loaded"}
                }
            }
            else if [logx][wineventlog][event_id] == 4830 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "SID History was removed from an account"}
                }
            }
            else if [logx][wineventlog][event_id] == 4864 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A namespace collision was detected"}
                }
            }
            else if [logx][wineventlog][event_id] == 4865 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A trusted forest information entry was added"}
                }
            }
            else if [logx][wineventlog][event_id] == 4866 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A trusted forest information entry was removed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4867 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A trusted forest information entry was modified"}
                }
            }
            else if [logx][wineventlog][event_id] == 4868 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The certificate manager denied a pending certificate request"}
                }
            }
            else if [logx][wineventlog][event_id] == 4869 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Certificate Services received a resubmitted certificate request"}
                }
            }
            else if [logx][wineventlog][event_id] == 4870 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Certificate Services revoked a certificate"}
                }
            }
            else if [logx][wineventlog][event_id] == 4871 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Certificate Services received a request to publish the certificate revocation list (CRL)"}
                }
            }
            else if [logx][wineventlog][event_id] == 4872 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Certificate Services published the certificate revocation list (CRL)"}
                }
            }
            else if [logx][wineventlog][event_id] == 4873 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A certificate request extension changed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4874 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "One or more certificate request attributes changed."}
                }
            }
            else if [logx][wineventlog][event_id] == 4875 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Certificate Services received a request to shut down"}
                }
            }
            else if [logx][wineventlog][event_id] == 4876 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Certificate Services backup started"}
                }
            }
            else if [logx][wineventlog][event_id] == 4877 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Certificate Services backup completed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4878 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Certificate Services restore started"}
                }
            }
            else if [logx][wineventlog][event_id] == 4879 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Certificate Services restore completed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4880 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Certificate Services started"}
                }
            }
            else if [logx][wineventlog][event_id] == 4881 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Certificate Services stopped"}
                }
            }
            else if [logx][wineventlog][event_id] == 4882 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The security permissions for Certificate Services changed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4883 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Certificate Services retrieved an archived key"}
                }
            }
            else if [logx][wineventlog][event_id] == 4884 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Certificate Services imported a certificate into its database"}
                }
            }
            else if [logx][wineventlog][event_id] == 4885 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The audit filter for Certificate Services changed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4886 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Certificate Services received a certificate request"}
                }
            }
            else if [logx][wineventlog][event_id] == 4887 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Certificate Services approved a certificate request and issued a certificate"}
                }
            }
            else if [logx][wineventlog][event_id] == 4888 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Certificate Services denied a certificate request"}
                }
            }
            else if [logx][wineventlog][event_id] == 4889 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Certificate Services set the status of a certificate request to pending"}
                }
            }
            else if [logx][wineventlog][event_id] == 4890 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The certificate manager settings for Certificate Services changed."}
                }
            }
            else if [logx][wineventlog][event_id] == 4891 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A configuration entry changed in Certificate Services"}
                }
            }
            else if [logx][wineventlog][event_id] == 4892 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A property of Certificate Services changed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4893 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Certificate Services archived a key"}
                }
            }
            else if [logx][wineventlog][event_id] == 4894 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Certificate Services imported and archived a key"}
                }
            }
            else if [logx][wineventlog][event_id] == 4895 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Certificate Services published the CA certificate to Active Directory Domain Services"}
                }
            }
            else if [logx][wineventlog][event_id] == 4896 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "One or more rows have been deleted from the certificate database"}
                }
            }
            else if [logx][wineventlog][event_id] == 4897 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Role separation enabled"}
                }
            }
            else if [logx][wineventlog][event_id] == 4898 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Certificate Services loaded a template"}
                }
            }
            else if [logx][wineventlog][event_id] == 4899 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A Certificate Services template was updated"}
                }
            }
            else if [logx][wineventlog][event_id] == 4900 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Certificate Services template security was updated"}
                }
            }
            else if [logx][wineventlog][event_id] == 4902 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The Per-user audit policy table was created"}
                }
            }
            else if [logx][wineventlog][event_id] == 4904 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An attempt was made to register a security event source"}
                }
            }
            else if [logx][wineventlog][event_id] == 4905 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An attempt was made to unregister a security event source"}
                }
            }
            else if [logx][wineventlog][event_id] == 4906 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The CrashOnAuditFail value has changed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4907 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Auditing settings on object were changed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4908 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Special Groups Logon table modified"}
                }
            }
            else if [logx][wineventlog][event_id] == 4909 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The local policy settings for the TBS were changed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4910 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The group policy settings for the TBS were changed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4911 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Resource attributes of the object were changed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4912 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Per User Audit Policy was changed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4913 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Central Access Policy on the object was changed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4928 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An Active Directory replica source naming context was established"}
                }
            }
            else if [logx][wineventlog][event_id] == 4929 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An Active Directory replica source naming context was removed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4930 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An Active Directory replica source naming context was modified"}
                }
            }
            else if [logx][wineventlog][event_id] == 4931 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An Active Directory replica destination naming context was modified"}
                }
            }
            else if [logx][wineventlog][event_id] == 4932 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Synchronization of a replica of an Active Directory naming context has begun"}
                }
            }
            else if [logx][wineventlog][event_id] == 4933 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Synchronization of a replica of an Active Directory naming context has ended"}
                }
            }
            else if [logx][wineventlog][event_id] == 4934 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Attributes of an Active Directory object were replicated"}
                }
            }
            else if [logx][wineventlog][event_id] == 4935 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Replication failure begins"}
                }
            }
            else if [logx][wineventlog][event_id] == 4936 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Replication failure ends"}
                }
            }
            else if [logx][wineventlog][event_id] == 4937 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A lingering object was removed from a replica"}
                }
            }
            else if [logx][wineventlog][event_id] == 4944 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The following policy was active when the Windows Firewall started"}
                }
            }
            else if [logx][wineventlog][event_id] == 4945 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A rule was listed when the Windows Firewall started"}
                }
            }
            else if [logx][wineventlog][event_id] == 4946 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A change has been made to Windows Firewall exception list. A rule was added"}
                }
            }
            else if [logx][wineventlog][event_id] == 4947 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A change has been made to Windows Firewall exception list. A rule was modified"}
                }
            }
            else if [logx][wineventlog][event_id] == 4948 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A change has been made to Windows Firewall exception list. A rule was deleted"}
                }
            }
            else if [logx][wineventlog][event_id] == 4949 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Windows Firewall settings were restored to the default values"}
                }
            }
            else if [logx][wineventlog][event_id] == 4950 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A Windows Firewall setting has changed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4951 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A rule has been ignored because its major version number was not recognized by Windows Firewall"}
                }
            }
            else if [logx][wineventlog][event_id] == 4952 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Parts of a rule have been ignored because its minor version number was not recognized by Windows Firewall"}
                }
            }
            else if [logx][wineventlog][event_id] == 4953 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A rule has been ignored by Windows Firewall because it could not parse the rule"}
                }
            }
            else if [logx][wineventlog][event_id] == 4954 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Windows Firewall Group Policy settings has changed. The new settings have been applied"}
                }
            }
            else if [logx][wineventlog][event_id] == 4956 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Windows Firewall has changed the active profile"}
                }
            }
            else if [logx][wineventlog][event_id] == 4957 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Windows Firewall did not apply the following rule"}
                }
            }
            else if [logx][wineventlog][event_id] == 4958 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Windows Firewall did not apply the following rule because the rule referred to items not configured on this computer"}
                }
            }
            else if [logx][wineventlog][event_id] == 4960 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "IPsec dropped an inbound packet that failed an integrity check"}
                }
            }
            else if [logx][wineventlog][event_id] == 4961 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "IPsec dropped an inbound packet that failed a replay check"}
                }
            }
            else if [logx][wineventlog][event_id] == 4962 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "IPsec dropped an inbound packet that failed a replay check"}
                }
            }
            else if [logx][wineventlog][event_id] == 4963 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "IPsec dropped an inbound clear text packet that should have been secured"}
                }
            }
            else if [logx][wineventlog][event_id] == 4964 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Special groups have been assigned to a new logon"}
                }
            }
            else if [logx][wineventlog][event_id] == 4965 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "IPsec received a packet from a remote computer with an incorrect Security Parameter Index (SPI)."}
                }
            }
            else if [logx][wineventlog][event_id] == 4976 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "During Main Mode negotiation: IPsec received an invalid negotiation packet."}
                }
            }
            else if [logx][wineventlog][event_id] == 4977 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "During Quick Mode negotiation: IPsec received an invalid negotiation packet."}
                }
            }
            else if [logx][wineventlog][event_id] == 4978 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "During Extended Mode negotiation: IPsec received an invalid negotiation packet."}
                }
            }
            else if [logx][wineventlog][event_id] == 4979 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "IPsec Main Mode and Extended Mode security associations were established."}
                }
            }
            else if [logx][wineventlog][event_id] == 4980 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "IPsec Main Mode and Extended Mode security associations were established"}
                }
            }
            else if [logx][wineventlog][event_id] == 4981 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "IPsec Main Mode and Extended Mode security associations were established"}
                }
            }
            else if [logx][wineventlog][event_id] == 4982 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "IPsec Main Mode and Extended Mode security associations were established"}
                }
            }
            else if [logx][wineventlog][event_id] == 4983 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An IPsec Extended Mode negotiation failed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4984 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An IPsec Extended Mode negotiation failed"}
                }
            }
            else if [logx][wineventlog][event_id] == 4985 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The state of a transaction has changed"}
                }
            }
            else if [logx][wineventlog][event_id] == 5024 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The Windows Firewall Service has started successfully"}
                }
            }
            else if [logx][wineventlog][event_id] == 5025 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The Windows Firewall Service has been stopped"}
                }
            }
            else if [logx][wineventlog][event_id] == 5027 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The Windows Firewall Service was unable to retrieve the security policy from the local storage"}
                }
            }
            else if [logx][wineventlog][event_id] == 5028 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The Windows Firewall Service was unable to parse the new security policy."}
                }
            }
            else if [logx][wineventlog][event_id] == 5029 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The Windows Firewall Service failed to initialize the driver"}
                }
            }
            else if [logx][wineventlog][event_id] == 5030 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The Windows Firewall Service failed to start"}
                }
            }
            else if [logx][wineventlog][event_id] == 5031 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The Windows Firewall Service blocked an application from accepting incoming connections on the network."}
                }
            }
            else if [logx][wineventlog][event_id] == 5032 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Windows Firewall was unable to notify the user that it blocked an application from accepting incoming connections on the network"}
                }
            }
            else if [logx][wineventlog][event_id] == 5033 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The Windows Firewall Driver has started successfully"}
                }
            }
            else if [logx][wineventlog][event_id] == 5034 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The Windows Firewall Driver has been stopped"}
                }
            }
            else if [logx][wineventlog][event_id] == 5035 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The Windows Firewall Driver failed to start"}
                }
            }
            else if [logx][wineventlog][event_id] == 5037 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The Windows Firewall Driver detected critical runtime error. Terminating"}
                }
            }
            else if [logx][wineventlog][event_id] == 5038 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Code integrity determined that the image hash of a file is not valid"}
                }
            }
            else if [logx][wineventlog][event_id] == 5039 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A registry key was virtualized."}
                }
            }
            else if [logx][wineventlog][event_id] == 5040 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A change has been made to IPsec settings. An Authentication Set was added."}
                }
            }
            else if [logx][wineventlog][event_id] == 5041 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A change has been made to IPsec settings. An Authentication Set was modified"}
                }
            }
            else if [logx][wineventlog][event_id] == 5042 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A change has been made to IPsec settings. An Authentication Set was deleted"}
                }
            }
            else if [logx][wineventlog][event_id] == 5043 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A change has been made to IPsec settings. A Connection Security Rule was added"}
                }
            }
            else if [logx][wineventlog][event_id] == 5044 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A change has been made to IPsec settings. A Connection Security Rule was modified"}
                }
            }
            else if [logx][wineventlog][event_id] == 5045 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A change has been made to IPsec settings. A Connection Security Rule was deleted"}
                }
            }
            else if [logx][wineventlog][event_id] == 5046 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A change has been made to IPsec settings. A Crypto Set was added"}
                }
            }
            else if [logx][wineventlog][event_id] == 5047 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A change has been made to IPsec settings. A Crypto Set was modified"}
                }
            }
            else if [logx][wineventlog][event_id] == 5048 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A change has been made to IPsec settings. A Crypto Set was deleted"}
                }
            }
            else if [logx][wineventlog][event_id] == 5049 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An IPsec Security Association was deleted"}
                }
            }
            else if [logx][wineventlog][event_id] == 5050 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An attempt to programmatically disable the Windows Firewall using a call to INetFwProfile.FirewallEnabled(FALSE)"}
                }
            }
            else if [logx][wineventlog][event_id] == 5051 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A file was virtualized"}
                }
            }
            else if [logx][wineventlog][event_id] == 5056 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A cryptographic self test was performed"}
                }
            }
            else if [logx][wineventlog][event_id] == 5057 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A cryptographic primitive operation failed"}
                }
            }
            else if [logx][wineventlog][event_id] == 5058 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Key file operation"}
                }
            }
            else if [logx][wineventlog][event_id] == 5059 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Key migration operation"}
                }
            }
            else if [logx][wineventlog][event_id] == 5060 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Verification operation failed"}
                }
            }
            else if [logx][wineventlog][event_id] == 5061 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Cryptographic operation"}
                }
            }
            else if [logx][wineventlog][event_id] == 5062 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A kernel-mode cryptographic self test was performed"}
                }
            }
            else if [logx][wineventlog][event_id] == 5063 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A cryptographic provider operation was attempted"}
                }
            }
            else if [logx][wineventlog][event_id] == 5064 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A cryptographic context operation was attempted"}
                }
            }
            else if [logx][wineventlog][event_id] == 5065 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A cryptographic context modification was attempted"}
                }
            }
            else if [logx][wineventlog][event_id] == 5066 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A cryptographic function operation was attempted"}
                }
            }
            else if [logx][wineventlog][event_id] == 5067 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A cryptographic function modification was attempted"}
                }
            }
            else if [logx][wineventlog][event_id] == 5068 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A cryptographic function provider operation was attempted"}
                }
            }
            else if [logx][wineventlog][event_id] == 5069 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A cryptographic function property operation was attempted"}
                }
            }
            else if [logx][wineventlog][event_id] == 5070 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A cryptographic function property operation was attempted"}
                }
            }
            else if [logx][wineventlog][event_id] == 5071 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Key access denied by Microsoft key distribution service"}
                }
            }
            else if [logx][wineventlog][event_id] == 5120 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "OCSP Responder Service Started"}
                }
            }
            else if [logx][wineventlog][event_id] == 5121 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "OCSP Responder Service Stopped"}
                }
            }
            else if [logx][wineventlog][event_id] == 5122 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A Configuration entry changed in the OCSP Responder Service"}
                }
            }
            else if [logx][wineventlog][event_id] == 5123 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A configuration entry changed in the OCSP Responder Service"}
                }
            }
            else if [logx][wineventlog][event_id] == 5124 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A security setting was updated on OCSP Responder Service"}
                }
            }
            else if [logx][wineventlog][event_id] == 5125 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A request was submitted to OCSP Responder Service"}
                }
            }
            else if [logx][wineventlog][event_id] == 5126 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Signing Certificate was automatically updated by the OCSP Responder Service"}
                }
            }
            else if [logx][wineventlog][event_id] == 5127 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The OCSP Revocation Provider successfully updated the revocation information"}
                }
            }
            else if [logx][wineventlog][event_id] == 5136 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A directory service object was modified"}
                }
            }
            else if [logx][wineventlog][event_id] == 5137 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A directory service object was created"}
                }
            }
            else if [logx][wineventlog][event_id] == 5138 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A directory service object was undeleted"}
                }
            }
            else if [logx][wineventlog][event_id] == 5139 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A directory service object was moved"}
                }
            }
            else if [logx][wineventlog][event_id] == 5140 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A network share object was accessed"}
                }
            }
            else if [logx][wineventlog][event_id] == 5141 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A directory service object was deleted"}
                }
            }
            else if [logx][wineventlog][event_id] == 5142 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A network share object was added."}
                }
            }
            else if [logx][wineventlog][event_id] == 5143 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A network share object was modified"}
                }
            }
            else if [logx][wineventlog][event_id] == 5144 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A network share object was deleted."}
                }
            }
            else if [logx][wineventlog][event_id] == 5145 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A network share object was checked to see whether client can be granted desired access"}
                }
            }
            else if [logx][wineventlog][event_id] == 5146 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The Windows Filtering Platform has blocked a packet"}
                }
            }
            else if [logx][wineventlog][event_id] == 5147 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A more restrictive Windows Filtering Platform filter has blocked a packet"}
                }
            }
            else if [logx][wineventlog][event_id] == 5148 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The Windows Filtering Platform has detected a DoS attack and entered a defensive mode; packets associated with this attack will be discarded."}
                }
            }
            else if [logx][wineventlog][event_id] == 5149 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The DoS attack has subsided and normal processing is being resumed."}
                }
            }
            else if [logx][wineventlog][event_id] == 5150 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The Windows Filtering Platform has blocked a packet."}
                }
            }
            else if [logx][wineventlog][event_id] == 5151 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A more restrictive Windows Filtering Platform filter has blocked a packet."}
                }
            }
            else if [logx][wineventlog][event_id] == 5152 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The Windows Filtering Platform blocked a packet"}
                }
            }
            else if [logx][wineventlog][event_id] == 5153 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A more restrictive Windows Filtering Platform filter has blocked a packet"}
                }
            }
            else if [logx][wineventlog][event_id] == 5154 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The Windows Filtering Platform has permitted an application or service to listen on a port for incoming connections"}
                }
            }
            else if [logx][wineventlog][event_id] == 5155 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The Windows Filtering Platform has blocked an application or service from listening on a port for incoming connections"}
                }
            }
            else if [logx][wineventlog][event_id] == 5156 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The Windows Filtering Platform has allowed a connection"}
                }
            }
            else if [logx][wineventlog][event_id] == 5157 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The Windows Filtering Platform has blocked a connection"}
                }
            }
            else if [logx][wineventlog][event_id] == 5158 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The Windows Filtering Platform has permitted a bind to a local port"}
                }
            }
            else if [logx][wineventlog][event_id] == 5159 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The Windows Filtering Platform has blocked a bind to a local port"}
                }
            }
            else if [logx][wineventlog][event_id] == 5168 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Spn check for SMB/SMB2 fails."}
                }
            }
            else if [logx][wineventlog][event_id] == 5169 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A directory service object was modified"}
                }
            }
            else if [logx][wineventlog][event_id] == 5170 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A directory service object was modified during a background cleanup task"}
                }
            }
            else if [logx][wineventlog][event_id] == 5376 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Credential Manager credentials were backed up"}
                }
            }
            else if [logx][wineventlog][event_id] == 5377 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Credential Manager credentials were restored from a backup"}
                }
            }
            else if [logx][wineventlog][event_id] == 5378 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The requested credentials delegation was disallowed by policy"}
                }
            }
            else if [logx][wineventlog][event_id] == 5379 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Credential Manager credentials were read"}
                }
            }
            else if [logx][wineventlog][event_id] == 5380 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Vault Find Credential"}
                }
            }
            else if [logx][wineventlog][event_id] == 5381 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Vault credentials were read"}
                }
            }
            else if [logx][wineventlog][event_id] == 5382 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Vault credentials were read"}
                }
            }
            else if [logx][wineventlog][event_id] == 5440 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The following callout was present when the Windows Filtering Platform Base Filtering Engine started"}
                }
            }
            else if [logx][wineventlog][event_id] == 5441 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The following filter was present when the Windows Filtering Platform Base Filtering Engine started"}
                }
            }
            else if [logx][wineventlog][event_id] == 5442 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The following provider was present when the Windows Filtering Platform Base Filtering Engine started"}
                }
            }
            else if [logx][wineventlog][event_id] == 5443 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The following provider context was present when the Windows Filtering Platform Base Filtering Engine started"}
                }
            }
            else if [logx][wineventlog][event_id] == 5444 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The following sub-layer was present when the Windows Filtering Platform Base Filtering Engine started"}
                }
            }
            else if [logx][wineventlog][event_id] == 5446 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A Windows Filtering Platform callout has been changed"}
                }
            }
            else if [logx][wineventlog][event_id] == 5447 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A Windows Filtering Platform filter has been changed"}
                }
            }
            else if [logx][wineventlog][event_id] == 5448 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A Windows Filtering Platform provider has been changed"}
                }
            }
            else if [logx][wineventlog][event_id] == 5449 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A Windows Filtering Platform provider context has been changed"}
                }
            }
            else if [logx][wineventlog][event_id] == 5450 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A Windows Filtering Platform sub-layer has been changed"}
                }
            }
            else if [logx][wineventlog][event_id] == 5451 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An IPsec Quick Mode security association was established"}
                }
            }
            else if [logx][wineventlog][event_id] == 5452 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An IPsec Quick Mode security association ended"}
                }
            }
            else if [logx][wineventlog][event_id] == 5453 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An IPsec negotiation with a remote computer failed because the IKE and AuthIP IPsec Keying Modules (IKEEXT) service is not started"}
                }
            }
            else if [logx][wineventlog][event_id] == 5456 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "PAStore Engine applied Active Directory storage IPsec policy on the computer"}
                }
            }
            else if [logx][wineventlog][event_id] == 5457 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "PAStore Engine failed to apply Active Directory storage IPsec policy on the computer"}
                }
            }
            else if [logx][wineventlog][event_id] == 5458 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "PAStore Engine applied locally cached copy of Active Directory storage IPsec policy on the computer"}
                }
            }
            else if [logx][wineventlog][event_id] == 5459 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "PAStore Engine failed to apply locally cached copy of Active Directory storage IPsec policy on the computer"}
                }
            }
            else if [logx][wineventlog][event_id] == 5460 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "PAStore Engine applied local registry storage IPsec policy on the computer"}
                }
            }
            else if [logx][wineventlog][event_id] == 5461 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "PAStore Engine failed to apply local registry storage IPsec policy on the computer"}
                }
            }
            else if [logx][wineventlog][event_id] == 5462 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "PAStore Engine failed to apply some rules of the active IPsec policy on the computer"}
                }
            }
            else if [logx][wineventlog][event_id] == 5463 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "PAStore Engine polled for changes to the active IPsec policy and detected no changes"}
                }
            }
            else if [logx][wineventlog][event_id] == 5464 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "PAStore Engine polled for changes to the active IPsec policy: detected changes: and applied them to IPsec Services"}
                }
            }
            else if [logx][wineventlog][event_id] == 5465 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "PAStore Engine received a control for forced reloading of IPsec policy and processed the control successfully"}
                }
            }
            else if [logx][wineventlog][event_id] == 5466 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "PAStore Engine polled for changes to the Active Directory IPsec policy: determined that Active Directory cannot be reached: and will use the cached copy of the Active Directory IPsec policy instead"}
                }
            }
            else if [logx][wineventlog][event_id] == 5467 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "PAStore Engine polled for changes to the Active Directory IPsec policy: determined that Active Directory can be reached: and found no changes to the policy"}
                }
            }
            else if [logx][wineventlog][event_id] == 5468 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "PAStore Engine polled for changes to the Active Directory IPsec policy: determined that Active Directory can be reached: found changes to the policy: and applied those changes"}
                }
            }
            else if [logx][wineventlog][event_id] == 5471 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "PAStore Engine loaded local storage IPsec policy on the computer"}
                }
            }
            else if [logx][wineventlog][event_id] == 5472 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "PAStore Engine failed to load local storage IPsec policy on the computer"}
                }
            }
            else if [logx][wineventlog][event_id] == 5473 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "PAStore Engine loaded directory storage IPsec policy on the computer"}
                }
            }
            else if [logx][wineventlog][event_id] == 5474 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "PAStore Engine failed to load directory storage IPsec policy on the computer"}
                }
            }
            else if [logx][wineventlog][event_id] == 5477 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "PAStore Engine failed to add quick mode filter"}
                }
            }
            else if [logx][wineventlog][event_id] == 5478 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "IPsec Services has started successfully"}
                }
            }
            else if [logx][wineventlog][event_id] == 5479 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "IPsec Services has been shut down successfully"}
                }
            }
            else if [logx][wineventlog][event_id] == 5480 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "IPsec Services failed to get the complete list of network interfaces on the computer"}
                }
            }
            else if [logx][wineventlog][event_id] == 5483 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "IPsec Services failed to initialize RPC server. IPsec Services could not be started"}
                }
            }
            else if [logx][wineventlog][event_id] == 5484 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "IPsec Services has experienced a critical failure and has been shut down"}
                }
            }
            else if [logx][wineventlog][event_id] == 5485 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "IPsec Services failed to process some IPsec filters on a plug-and-play event for network interfaces"}
                }
            }
            else if [logx][wineventlog][event_id] == 5632 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A request was made to authenticate to a wireless network"}
                }
            }
            else if [logx][wineventlog][event_id] == 5633 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A request was made to authenticate to a wired network"}
                }
            }
            else if [logx][wineventlog][event_id] == 5712 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A Remote Procedure Call (RPC) was attempted"}
                }
            }
            else if [logx][wineventlog][event_id] == 5888 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An object in the COM+ Catalog was modified"}
                }
            }
            else if [logx][wineventlog][event_id] == 5889 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An object was deleted from the COM+ Catalog"}
                }
            }
            else if [logx][wineventlog][event_id] == 5890 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "An object was added to the COM+ Catalog"}
                }
            }
            else if [logx][wineventlog][event_id] == 6144 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Security policy in the group policy objects has been applied successfully"}
                }
            }
            else if [logx][wineventlog][event_id] == 6145 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "One or more errors occured while processing security policy in the group policy objects"}
                }
            }
            else if [logx][wineventlog][event_id] == 6272 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Network Policy Server granted access to a user"}
                }
            }
            else if [logx][wineventlog][event_id] == 6273 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Network Policy Server denied access to a user"}
                }
            }
            else if [logx][wineventlog][event_id] == 6274 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Network Policy Server discarded the request for a user"}
                }
            }
            else if [logx][wineventlog][event_id] == 6275 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Network Policy Server discarded the accounting request for a user"}
                }
            }
            else if [logx][wineventlog][event_id] == 6276 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Network Policy Server quarantined a user"}
                }
            }
            else if [logx][wineventlog][event_id] == 6277 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Network Policy Server granted access to a user but put it on probation because the host did not meet the defined health policy"}
                }
            }
            else if [logx][wineventlog][event_id] == 6278 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Network Policy Server granted full access to a user because the host met the defined health policy"}
                }
            }
            else if [logx][wineventlog][event_id] == 6279 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Network Policy Server locked the user account due to repeated failed authentication attempts"}
                }
            }
            else if [logx][wineventlog][event_id] == 6280 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Network Policy Server unlocked the user account"}
                }
            }
            else if [logx][wineventlog][event_id] == 6281 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Code Integrity determined that the page hashes of an image file are not valid..."}
                }
            }
            else if [logx][wineventlog][event_id] == 6400 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "BranchCache: Received an incorrectly formatted response while discovering availability of content."}
                }
            }
            else if [logx][wineventlog][event_id] == 6401 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "BranchCache: Received invalid data from a peer. Data discarded."}
                }
            }
            else if [logx][wineventlog][event_id] == 6402 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "BranchCache: The message to the hosted cache offering it data is incorrectly formatted."}
                }
            }
            else if [logx][wineventlog][event_id] == 6403 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "BranchCache: The hosted cache sent an incorrectly formatted response to the client''s message to offer it data."}
                }
            }
            else if [logx][wineventlog][event_id] == 6404 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "BranchCache: Hosted cache could not be authenticated using the provisioned SSL certificate."}
                }
            }
            else if [logx][wineventlog][event_id] == 6405 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "BranchCache: %2 instance(s) of event id %1 occurred."}
                }
            }
            else if [logx][wineventlog][event_id] == 6406 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "%1 registered to Windows Firewall to control filtering for the following:"}
                }
            }
            else if [logx][wineventlog][event_id] == 6408 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Registered product %1 failed and Windows Firewall is now controlling the filtering for %2."}
                }
            }
            else if [logx][wineventlog][event_id] == 6409 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "BranchCache: A service connection point object could not be parsed"}
                }
            }
            else if [logx][wineventlog][event_id] == 6410 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Code integrity determined that a file does not meet the security requirements to load into a process. This could be due to the use of shared sections or other issues"}
                }
            }
            else if [logx][wineventlog][event_id] == 6416 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A new external device was recognized by the system."}
                }
            }
            else if [logx][wineventlog][event_id] == 6417 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The FIPS mode crypto selftests succeeded"}
                }
            }
            else if [logx][wineventlog][event_id] == 6418 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The FIPS mode crypto selftests failed"}
                }
            }
            else if [logx][wineventlog][event_id] == 6419 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A request was made to disable a device"}
                }
            }
            else if [logx][wineventlog][event_id] == 6420 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A device was disabled"}
                }
            }
            else if [logx][wineventlog][event_id] == 6421 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A request was made to enable a device"}
                }
            }
            else if [logx][wineventlog][event_id] == 6422 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "A device was enabled"}
                }
            }
            else if [logx][wineventlog][event_id] == 6423 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The installation of this device is forbidden by system policy"}
                }
            }
            else if [logx][wineventlog][event_id] == 6424 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "The installation of this device was allowed: after having previously been forbidden by policy"}
                }
            }
            else if [logx][wineventlog][event_id] == 8191 {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "Highest System-Defined Audit Message Value"}
                }
            }
            else {
                mutate {
                    add_field => {"[logx][wineventlog][event_name]" => "None"}
                }
            }

            if [logx][wineventlog][event_id] == 4663 {
            if [logx][wineventlog][event_data][AccessMask]{
                if [logx][wineventlog][event_data][AccessMask] == "0x1" {
                    mutate {
                        add_field => {"[logx][wineventlog][access_type]" => "read"}
                        add_field => {"[logx][wineventlog][access_description]" => "For a file object, the right to read the corresponding file data. For a directory object, the right to read the corresponding directory data.\n For a directory, the right to list the contents of the directory.\n For registry objects, this is, Query key value."}
                    }
                }
                else if [logx][wineventlog][event_data][AccessMask] == "0x2" {
                    mutate {
                        add_field => {"[logx][wineventlog][access_type]" => "write"}
                        add_field => {"[logx][wineventlog][access_description]" => "For a file object, the right to write data to the file.\n For a directory object, the right to create a file in the directory.\n For registry objects, this is, Set key value."}
                    }
                }
                else if [logx][wineventlog][event_data][AccessMask] == "0x4" {
                    mutate {
                        add_field => {"[logx][wineventlog][access_type]" => "append"}
                        add_field => {"[logx][wineventlog][access_description]" => "For a file object, the right to append data to the file. (For local files, write operations will not overwrite existing data if this flag is specified without FILE_WRITE_DATA.)\n For a directory object, the right to create a subdirectory.\n For a named pipe, the right to create a pipe."}
                    }
                }
                else if [logx][wineventlog][event_data][AccessMask] == "0x8" {
                    mutate {
                        add_field => {"[logx][wineventlog][access_type]" => "read_extended_attributes"}
                        add_field => {"[logx][wineventlog][access_description]" => "The right to read extended file attributes.\n For registry objects, this is, Enumerate sub-keys."}
                    }
                }
                else if [logx][wineventlog][event_data][AccessMask] == "0x10" {
                    mutate {
                        add_field => {"[logx][wineventlog][access_type]" => "write_extended_attributes"}
                        add_field => {"[logx][wineventlog][access_description]" => "The right to write extended file attributes."}
                    }
                }
                else if [logx][wineventlog][event_data][AccessMask] == "0x20" {
                    mutate {
                        add_field => {"[logx][wineventlog][access_type]" => "execute"}
                        add_field => {"[logx][wineventlog][access_description]" => "For a native code file, the right to execute the file. This access right given to scripts may cause the script to be executable, depending on the script interpreter.\n For a directory, the right to traverse the directory. By default, users are assigned the BYPASS_TRAVERSE_CHECKING privilege, which ignores the FILE_TRAVERSE access right."}
                    }
                }
                else if [logx][wineventlog][event_data][AccessMask] == "0x40" {
                    mutate {
                        add_field => {"[logx][wineventlog][access_type]" => "delete_child"}
                        add_field => {"[logx][wineventlog][access_description]" => "For a directory, the right to delete a directory and all the files it contains, including read-only files."}
                    }
                }
                else if [logx][wineventlog][event_data][AccessMask] == "0x80" {
                    mutate {
                        add_field => {"[logx][wineventlog][access_type]" => "read_attributes"}
                        add_field => {"[logx][wineventlog][access_description]" => "The right to read file attributes."}
                    }
                }
                else if [logx][wineventlog][event_data][AccessMask] == "0x100" {
                    mutate {
                        add_field => {"[logx][wineventlog][access_type]" => "write_attributes"}
                        add_field => {"[logx][wineventlog][access_description]" => "The right to write file attributes."}
                    }
                }
                else if [logx][wineventlog][event_data][AccessMask] == "0x10000" {
                    mutate {
                        add_field => {"[logx][wineventlog][access_type]" => "delete"}
                        add_field => {"[logx][wineventlog][access_description]" => "The right to delete the object."}
                    }
                }
                else if [logx][wineventlog][event_data][AccessMask] == "0x20000" {
                    mutate {
                        add_field => {"[logx][wineventlog][access_type]" => "read_control"}
                        add_field => {"[logx][wineventlog][access_description]" => "The right to read the information in the object''s security descriptor, not including the information in the system access control list (SACL)."}
                    }
                }
                else if [logx][wineventlog][event_data][AccessMask] == "0x40000" {
                    mutate {
                        add_field => {"[logx][wineventlog][access_type]" => "write_dac"}
                        add_field => {"[logx][wineventlog][access_description]" => "The right to modify the discretionary access control list (DACL) in the object''s security descriptor."}
                    }
                }
                else if [logx][wineventlog][event_data][AccessMask] == "0x80000" {
                    mutate {
                        add_field => {"[logx][wineventlog][access_type]" => "write_owner"}
                        add_field => {"[logx][wineventlog][access_description]" => "The right to change the owner in the object''s security descriptor"}
                    }
                }
                else if [logx][wineventlog][event_data][AccessMask] == "0x100000" {
                    mutate {
                        add_field => {"[logx][wineventlog][access_type]" => "synchronize"}
                        add_field => {"[logx][wineventlog][access_description]" => "The right to use the object for synchronization. This enables a thread to wait until the object is in the signaled state. Some object types do not support this access right."}
                    }
                }
                else if [logx][wineventlog][event_data][AccessMask] == "0x1000000" {
                    mutate {
                        add_field => {"[logx][wineventlog][access_type]" => "access_sys_sec"}
                        add_field => {"[logx][wineventlog][access_description]" => "The ACCESS_SYS_SEC access right controls the ability to get or set the SACL in an object''s security descriptor."}
                    }
                }
            }
            }
            if [logx][wineventlog][event_id] == 4625 {
            if [logx][wineventlog][event_data][FailureReason] {
                if [logx][wineventlog][event_data][FailureReason] == "%%2305" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][FailureReasonDescription]" => "The specified user account has expired."}
                    }
                }
                else if [logx][wineventlog][event_data][FailureReason] == "%%2309" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][FailureReasonDescription]" => "The specified account''s password has expired"}
                    }
                }
                else if [logx][wineventlog][event_data][FailureReason] == "%%2310" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][FailureReasonDescription]" => "Account currently disabled"}
                    }
                }
                else if [logx][wineventlog][event_data][FailureReason] == "%%2311" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][FailureReasonDescription]" => "Account logon time restriction violation"}
                    }
                }
                else if [logx][wineventlog][event_data][FailureReason] == "%%2312" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][FailureReasonDescription]" => "User not allowed to logon at this computer"}
                    }
                }
                else if [logx][wineventlog][event_data][FailureReason] == "%%2313" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][FailureReasonDescription]" => "Unknown user name or bad password"}
                    }
                }
                else if [logx][wineventlog][event_data][FailureReason] == "%%2304" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][FailureReasonDescription]" => "An Error occurred during Logon"}
                    }
                }
                else {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][FailureReasonDescription]" => "None"}
                    }
                }
            }
            if [logx][wineventlog][event_data][Status] {
                if [logx][wineventlog][event_data][Status] == "0xC0000234" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Account locked out"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0xC0000193" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Account expired"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0xC0000133" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Clocks out of sync"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0xC0000224" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Password change required"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0xc000015b" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "User does not have logon right"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0xc000006d" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Logon failure"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0xc000006e" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Account restriction"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0xc00002ee" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "An error occurred during logon"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0xC0000071" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Password expired"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0xC0000072" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Account disabled"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0xC0000413" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Authentication firewall prohibits logon"}
                    }
                }
                else {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "None"}
                    }
                }
            }
            if [logx][wineventlog][event_data][SubStatus] {
                if [logx][wineventlog][event_data][SubStatus] == "0xC0000234" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Account locked out"}
                    }
                }
                else if [logx][wineventlog][event_data][SubStatus] == "0xC0000193" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][SubStatusDescription]" => "Account expired"}
                    }
                }
                else if [logx][wineventlog][event_data][SubStatus] == "0xC0000133" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][SubStatusDescription]" => "Clocks out of sync"}
                    }
                }
                else if [logx][wineventlog][event_data][SubStatus] == "0xC0000224" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][SubStatusDescription]" => "Password change required"}
                    }
                }
                else if [logx][wineventlog][event_data][SubStatus] == "0xc000015b" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][SubStatusDescription]" => "User does not have logon right"}
                    }
                }
                else if [logx][wineventlog][event_data][SubStatus] == "0xc000006d" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][SubStatusDescription]" => "Logon failure"}
                    }
                }
                else if [logx][wineventlog][event_data][SubStatus] == "0xc000006e" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][SubStatusDescription]" => "Account restriction"}
                    }
                }
                else if [logx][wineventlog][event_data][SubStatus] == "0xc00002ee" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][SubStatusDescription]" => "An error occurred during logon"}
                    }
                }
                else if [logx][wineventlog][event_data][SubStatus] == "0xC0000071" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][SubStatusDescription]" => "Password expired"}
                    }
                }
                else if [logx][wineventlog][event_data][SubStatus] == "0xC0000072" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][SubStatusDescription]" => "Account disabled"}
                    }
                }
                else if [logx][wineventlog][event_data][SubStatus] == "0xC0000413" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][SubStatusDescription]" => "Authentication firewall prohibits logon"}
                    }
                }
                else if [logx][wineventlog][event_data][SubStatus] == "0xc000006a" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][SubStatusDescription]" => "Incorrect password"}
                    }
                }
                else if [logx][wineventlog][event_data][SubStatus] == "0xc0000064" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][SubStatusDescription]" => "Account does not exist"}
                    }
                }
                else {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][SubStatusDescription]" => "None"}
                    }
                }
            }
            }
            if [logx][wineventlog][event_id] == 4771 {
            if [logx][wineventlog][event_data][Status] {
                if [logx][wineventlog][event_data][Status] == "0x1" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Client''s entry in database has expired"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0x2" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Server''s entry in database has expired"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0x3" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Requested protocol version not supported"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0x4" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Client''s key encrypted in old master key"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0x5" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Server''s key encrypted in old master key"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0x6" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Client not found in Kerberos database"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0x7" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Server not found in Kerberos database"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0x8" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Multiple principal entries in database"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0x9" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "The client or server has a null key"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0xA" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Ticket not eligible for postdating"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0xB" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Requested start time is later than end time"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0xC" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "KDC policy rejects request"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0xD" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "KDC cannot accommodate requested option"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0xE" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "KDC has no support for encryption type"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0xF" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "KDC has no support for checksum type"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0x10" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "KDC has no support for padata type"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0x11" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "KDC has no support for transited type"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0x12" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Clients credentials have been revoked"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0x13" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Credentials for server have been revoked"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0x14" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "TGT has been revoked"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0x15" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Client not yet valid - try again later"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0x16" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Server not yet valid - try again later"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0x17" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Password has expired"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0x18" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Pre-authentication information was invalid"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0x19" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Additional pre-authentication required"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0x1F" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Integrity check on decrypted field failed"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0x20" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Ticket expired"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0x21" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Ticket not yet valid"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0x22" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Request is a replay"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0x23" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "The ticket isn''t for us"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0x24" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Ticket and authenticator don''t match"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0x25" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Clock skew too great"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0x26" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Incorrect net address"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0x27" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Protocol version mismatch"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0x28" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Invalid msg type"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0x29" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Message stream modified"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0x2A" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Message out of order"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0x2C" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Specified version of key is not available"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0x2D" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Service key not available"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0x2E" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Mutual authentication failed"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0x2F" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Incorrect message direction"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0x30" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Alternative authentication method required"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0x31" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Incorrect sequence number in message"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0x32" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Inappropriate type of checksum in message"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0x3C" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Generic error (description in e-text)"}
                    }
                }
                else if [logx][wineventlog][event_data][Status] == "0x3D" {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "Field is too long for this implementation"}
                    }
                }
                else {
                    mutate {
                        add_field => {"[logx][wineventlog][event_data][StatusDescription]" => "None"}
                    }
                }
            }
            }
      }
    }
   #Also, remove unwanted fields if the message not match with conditions
   mutate {
      remove_field => ["headers"]
   }
}'
WHERE id=701;
----------------------------------------------------------------------------------------------------------------------------------------
-- IIS  --
----------------------------------------------------------------------------------------------------------------------------------------
UPDATE public.utm_logstash_filter
SET filter_version='3.0.1',logstash_filter='filter {
  #Fields based on https://learn.microsoft.com/en-us/previous-versions/iis/6.0-sdk/ms525807(v=vs.90)
  #and https://www.elastic.co/guide/en/beats/filebeat/7.13/exported-fields-iis.html
  #and https://httpd.apache.org/docs/2.2/logs.html
  #and filebeat fields.yml version 7.13.4 oss

  #Filebeat IIS, version 3.0.1
  #Filter Input requirements -> fileset: datatype
  #                access: plain text
  #                error: plain text

  split {
    field => "message"
    terminator => "<utm-log-separator>"
  }
  json {
    source => "message"
  }

  if ([event][module] and [event][module] == "iis")
  or ([service][type] and [service][type] == "iis") {
     grok {
         match => {
           "message" => [
             "%{TIMESTAMP_ISO8601:timestamp} %{IPORHOST:site} %{WORD:method} %{URIPATH:page} %{NOTSPACE:querystring} %{NUMBER:port} %{NOTSPACE:username} %{IPORHOST:clienthost} %{NOTSPACE:useragent} %{NOTSPACE:referer} %{NUMBER:response} %{NUMBER:subresponse} %{NUMBER:scstatus} %{NUMBER:timetaken:int}",
             "%{TIMESTAMP_ISO8601:timestamp} %{WORD:iisSite} %{NOTSPACE:computername} %{IPORHOST:site} %{WORD:method} %{URIPATH:page} %{NOTSPACE:querystring} %{NUMBER:port} %{NOTSPACE:username} %{IPORHOST:clienthost} %{NOTSPACE:protocol} %{NOTSPACE:useragent} %{NOTSPACE:referer} %{IPORHOST:cshost} %{NUMBER:response} %{NUMBER:subresponse} %{NUMBER:scstatus} %{NUMBER:bytessent:int} %{NUMBER:bytesrecvd:int} %{NUMBER:timetaken:int}"
           ]
         }
     }
     date {
      match => [ "timestamp", "ISO8601" ]
      target => "@timestamp"
     }
     geoip {
      source => "clienthost"
     }
     mutate{
        add_field => { "[dataType]" => "iis" }
        rename => { "[host][name]" => "[dataSource]" }
     }
     #......................................................................#
    #Then add all possible fields to the json tree structure

        #Fields from module
        mutate {
            rename => { "iis" => "[logx][iis]" }
        }
        mutate {
        #General fields from ECS
            rename => { "host" => "[logx][iis][host]" }
            rename => { "service" => "[logx][iis][service]" }
            rename => { "ecs" => "[logx][iis][ecs]" }
            rename => { "agent" => "[logx][iis][agent]" }
            rename => { "fileset" => "[logx][iis][fileset]" }
            rename => { "event" => "[logx][iis][event]" }
            rename => { "input" => "[logx][iis][input]" }
            rename => { "labels" => "[logx][iis][labels]" }
            rename => { "as" => "[logx][iis][as]" }
            rename => { "client" => "[logx][iis][client]" }
            rename => { "cloud" => "[logx][iis][cloud]" }
            rename => { "code_signature" => "[logx][iis][code_signature]" }
            rename => { "container" => "[logx][iis][container]" }
            rename => { "destination" => "[logx][iis][destination]" }
            rename => { "dll" => "[logx][iis][dll]" }
            rename => { "dns" => "[logx][iis][dns]" }
            rename => { "error" => "[logx][iis][error]" }
            rename => { "file" => "[logx][iis][file]" }
            rename => { "geo" => "[logx][iis][geo]" }
            rename => { "hash" => "[logx][iis][hash]" }
            rename => { "http" => "[logx][iis][http]" }
            rename => { "interface" => "[logx][iis][interface]" }
            rename => { "network" => "[logx][iis][network]" }
            rename => { "observer" => "[logx][iis][observer]" }
            rename => { "organization" => "[logx][iis][organization]" }
            rename => { "package" => "[logx][iis][package]" }
            rename => { "pe" => "[logx][iis][pe]" }
            rename => { "process" => "[logx][iis][process]" }
            rename => { "registry" => "[logx][iis][registry]" }
            rename => { "related" => "[logx][iis][related]" }
            rename => { "rule" => "[logx][iis][rule]" }
            rename => { "server" => "[logx][iis][server]" }
            rename => { "source" => "[logx][iis][source]" }
            rename => { "threat" => "[logx][iis][threat]" }
            rename => { "tls" => "[logx][iis][tls]" }
            rename => { "span.id" => "[logx][iis][span.id]" }
            rename => { "trace.id" => "[logx][iis][trace.id]" }
            rename => { "transaction.id" => "[logx][iis][transaction.id]" }
            rename => { "url" => "[logx][iis][url]" }
            rename => { "user" => "[logx][iis][user]" }
            rename => { "vlan" => "[logx][iis][vlan]" }
            rename => { "vulnerability" => "[logx][iis][vulnerability]" }
            rename => { "x509" => "[logx][iis][x509]" }

            #Rename fields from iis module to add it to the structure
            rename => { "subresponse" => "[logx][iis][subresponse]" }
            rename => { "page" => "[logx][iis][page]" }
            rename => { "clienthost" => "[logx][iis][clienthost]" }
            rename => { "referer" => "[logx][iis][referer]" }
            rename => { "username" => "[logx][iis][username]" }
            rename => { "site" => "[logx][iis][site]" }
            rename => { "iisSite" => "[logx][iis][iisSite]" }
            rename => { "timetaken" => "[logx][iis][timetaken]" }
            rename => { "response" => "[logx][iis][response]" }
            rename => { "useragent" => "[logx][iis][useragent]" }
            rename => { "method" => "[logx][iis][method]" }
            rename => { "port" => "[logx][iis][port]" }
            rename => { "querystring" => "[logx][iis][querystring]" }
            rename => { "scstatus" => "[logx][iis][scstatus]" }
            rename => { "computername" => "[logx][iis][computername]" }
            rename => { "protocol" => "[logx][iis][protocol]" }
            rename => { "bytessent" => "[logx][iis][bytes_sent]" }
            rename => { "bytesrecvd" => "[logx][iis][bytes_recvd]" }
            rename => { "geoip" => "[logx][iis][geoip]" }
            rename => { "timestamp" => "[logx][iis][log_time]" }
            rename => { "message" => "[logx][iis][message]" }

        }
        #......................................................................#
        #Finally, remove unnecessary fields
        mutate {
            remove_field => ["@version","tags","log"]
        }
  }
   #Also, remove unwanted fields if the message not match with conditions
   mutate {
      remove_field => ["headers"]
   }
}
'
WHERE id=702;

            ]]>
        </sql>
    </changeSet>
</databaseChangeLog>
